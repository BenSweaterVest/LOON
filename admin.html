<!DOCTYPE html>
<!--
================================================================================
LOON Admin Panel (admin.html)
================================================================================

Content editor interface for LOON CMS.
Users authenticate with Username + Password, receiving a session token.
Role-based access control (RBAC) determines what users can edit.

FEATURES:
- Username/password login (stored in Cloudflare KV)
- Session tokens (24-hour expiry)
- Role-based access control
- User management UI (admin only)
- Content metadata tracking (createdBy, modifiedBy)
- Session expiry detection
- Dark mode support

ROLES:
- Admin: Edit any content, manage users
- Editor: Edit any content
- Contributor: Create new content, edit only own content

AUTHENTICATION:
- Users stored in Cloudflare KV (LOON_DB)
- Login via /api/auth returns session token
- Token included in Authorization header for all requests
- Logout via DELETE /api/auth

API ENDPOINTS USED:
- POST /api/auth   - Login
- DELETE /api/auth - Logout
- POST /api/save   - Save content (with RBAC)
- /api/users       - User management (admin only)

PREREQUISITES:
- Cloudflare KV namespace "LOON_DB" configured
- Initial setup token configured for first-run admin creation (SETUP_TOKEN)
================================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOON Team Admin</title>
    <meta name="description" content="LOON Admin Panel">
    <meta name="robots" content="noindex, nofollow">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>L</text></svg>">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #1e4d8f;
            --primary-hover: #173f76;
            --success: #17803d;
            --error: #c33232;
            --warning: #b7791f;
            --panel-background: rgba(255, 255, 255, 0.92);
            --panel-border: rgba(148, 163, 184, 0.35);
            --panel-shadow: 0 12px 28px rgba(15, 23, 42, 0.1);
            --surface-muted: rgba(203, 213, 225, 0.25);
        }

        [data-theme="forest"] {
            --primary: #1f6b5c;
            --primary-hover: #185349;
        }

        [data-theme="sunset"] {
            --primary: #b45309;
            --primary-hover: #92400e;
        }

        body {
            padding-top: 1rem;
            background:
                radial-gradient(circle at 20% 10%, rgba(30, 77, 143, 0.12), transparent 35%),
                radial-gradient(circle at 80% 0%, rgba(14, 116, 144, 0.1), transparent 32%),
                linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
            min-height: 100vh;
            font-family: "IBM Plex Sans", "Segoe UI", Tahoma, sans-serif;
        }

        main.container {
            max-width: 1200px;
        }
        
        .hidden { display: none !important; }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--muted-border-color);
            gap: 1rem;
        }
        
        .header h1 { margin: 0; font-size: 1.5rem; }
        .header .user-info { font-size: 0.9rem; color: var(--muted-color); }
        .header .role-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 0.5rem;
        }
        .role-admin { background: var(--primary); color: white; }
        .role-editor { background: var(--success); color: white; }
        .role-contributor { background: var(--warning); color: black; }
        
        .tab-nav {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--muted-border-color);
        }
        .tab-nav button {
            background: none;
            border: none;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            color: var(--muted-color);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }
        .tab-nav button:hover { color: var(--primary); }
        .tab-nav button.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        .tab-nav .logout-btn {
            margin-left: auto;
            color: var(--error);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-controls label {
            margin-bottom: 0;
            font-size: 0.85rem;
            color: var(--muted-color);
        }

        .header-controls select {
            margin-bottom: 0;
            min-width: 150px;
        }
        
        .login-container {
            max-width: 400px;
            margin: 4rem auto;
            padding: 2rem;
            border: 1px solid var(--muted-border-color);
            border-radius: 8px;
            background: var(--panel-background);
            box-shadow: var(--panel-shadow);
        }
        .login-container h2 { text-align: center; margin-bottom: 1.5rem; }
        
        .form-field { margin-bottom: 1rem; }
        .form-field label { display: block; margin-bottom: 0.25rem; font-weight: 500; }
        .form-field small { display: block; color: var(--muted-color); margin-top: 0.25rem; }
        
        .status-message {
            padding: 0.75rem 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            white-space: pre-line;
        }
        .status-success { background: #dcfce7; color: #166534; }
        .status-error { background: #fee2e2; color: #991b1b; }
        .status-info { background: #dbeafe; color: #1e40af; }
        .onboarding-card {
            max-width: 640px;
            margin: 1rem auto 2rem auto;
            padding: 1.25rem;
            border: 1px solid var(--muted-border-color);
            border-radius: 8px;
            background: var(--card-background-color);
            box-shadow: var(--panel-shadow);
        }
        .onboarding-card h3 {
            margin: 0 0 0.75rem 0;
            font-size: 1.1rem;
        }
        .onboarding-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
            margin: 0.75rem 0 1rem 0;
        }
        .onboarding-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.6rem;
            border: 1px solid var(--muted-border-color);
            border-radius: 6px;
            background: var(--background-color);
        }
        .onboarding-item small {
            display: block;
            color: var(--muted-color);
        }
        .check-chip {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 999px;
            padding: 0.25rem 0.55rem;
            letter-spacing: 0.02em;
            white-space: nowrap;
        }
        .check-pass { background: #dcfce7; color: #166534; }
        .check-warn { background: #fef3c7; color: #92400e; }
        .check-fail { background: #fee2e2; color: #991b1b; }
        .check-pending { background: #dbeafe; color: #1e40af; }
        .onboarding-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .onboarding-help {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border: 1px dashed var(--muted-border-color);
            border-radius: 6px;
            background: var(--background-color);
        }
        .onboarding-help .grid {
            margin-bottom: 0.5rem;
        }
        .setup-check-shell {
            max-width: 760px;
            margin: 2rem auto;
            padding: 1rem;
        }
        .setup-check-shell h1 {
            margin-bottom: 0.5rem;
        }
        .step-list {
            margin: 0.25rem 0 0.25rem 1rem;
        }
        
        .user-table { width: 100%; }
        .user-table th { text-align: left; }
        .user-table td { vertical-align: middle; }
        .user-table .actions { text-align: right; }
        .user-table .actions button {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            margin-left: 0.25rem;
        }
        
        .add-user-form {
            background: var(--card-background-color);
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 2rem;
            border: 1px solid var(--panel-border);
        }
        .add-user-form h4 { margin-top: 0; }
        
        .page-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .page-selector input { flex: 1; }

        .editor-guide {
            margin: 0 0 1rem 0;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            background: var(--surface-muted);
            padding: 0.8rem 0.9rem;
        }

        .editor-guide summary {
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .editor-guide ol {
            margin: 0.35rem 0 0.25rem 1.25rem;
        }
        
        .editor-container {
            background: var(--card-background-color);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            box-shadow: var(--panel-shadow);
        }
        .editor-container h3 { margin-top: 0; }
        
        .save-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--muted-border-color);
            gap: 1rem;
            flex-wrap: wrap;
        }
        .save-bar .last-saved { font-size: 0.85rem; color: var(--muted-color); }
        .edit-dirty-chip {
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 999px;
            padding: 0.2rem 0.55rem;
            background: var(--surface-muted);
            color: var(--muted-color);
        }
        .edit-dirty-chip.dirty {
            background: rgba(245, 158, 11, 0.2);
            color: #92400e;
        }

        .batch-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0;
            font-size: 0.85rem;
            color: var(--muted-color);
        }

        .batch-toggle input {
            margin: 0;
        }

        .queue-summary {
            margin-top: 0.65rem;
            font-size: 0.8rem;
            color: var(--muted-color);
        }

        .workflow-assistant {
            margin: 0.75rem 0 1rem 0;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.7rem 0.8rem;
            background: var(--panel-background);
        }

        .workflow-assistant strong {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.92rem;
        }

        .workflow-assistant small {
            color: var(--muted-color);
            display: block;
            margin-bottom: 0.35rem;
        }

        .editor-tools {
            margin-top: 0.9rem;
            display: grid;
            gap: 0.75rem;
        }

        .editor-tools details {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            background: var(--panel-background);
        }

        .editor-tools summary {
            font-weight: 600;
            cursor: pointer;
        }

        .autosave-indicator {
            margin-top: 0.35rem;
            font-size: 0.8rem;
            color: var(--muted-color);
        }

        .diff-view {
            max-height: 380px;
            overflow: auto;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.6rem;
            background: var(--panel-background);
            font-family: "IBM Plex Mono", "Consolas", monospace;
            font-size: 0.82rem;
            white-space: pre-wrap;
        }
        .diff-line {
            margin: 0;
            padding: 0.08rem 0.2rem;
            border-radius: 4px;
        }
        .diff-add {
            background: rgba(22, 163, 74, 0.12);
            color: #166534;
        }
        .diff-remove {
            background: rgba(220, 38, 38, 0.12);
            color: #991b1b;
        }
        .diff-same {
            color: var(--muted-color);
        }

        code {
            font-family: "IBM Plex Mono", "Consolas", monospace;
        }
        
        .meta-info {
            font-size: 0.8rem;
            color: var(--muted-color);
            margin-top: 1rem;
            padding: 0.5rem;
            background: var(--muted-border-color);
            border-radius: 4px;
        }
        
        /* Dark mode */
        @media (prefers-color-scheme: dark) {
            .status-success { background: #166534; color: #dcfce7; }
            .status-error { background: #991b1b; color: #fee2e2; }
            .status-info { background: #1e40af; color: #dbeafe; }
            body {
                background:
                    radial-gradient(circle at 20% 10%, rgba(56, 189, 248, 0.18), transparent 38%),
                    radial-gradient(circle at 80% 0%, rgba(16, 185, 129, 0.14), transparent 34%),
                    linear-gradient(180deg, #0b1220 0%, #111827 100%);
            }
        }
        
        /* Password field with toggle */
        .password-wrapper {
            position: relative;
        }
        .password-wrapper input { padding-right: 3rem; }
        .password-toggle {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: var(--muted-color);
        }
    </style>
</head>
<body>
    <main class="container">
        <div id="onboarding-guide" class="onboarding-card hidden">
            <h3>Guided Setup Assistant</h3>
            <p style="margin: 0.25rem 0 0.5rem 0; color: var(--muted-color);">
                Complete setup entirely in your browser using Cloudflare, GitHub, and this LOON page.
            </p>
            <div id="onboarding-summary" class="status-message status-info" style="margin-top: 0.5rem;">Checking system status...</div>
            <small id="onboarding-last-verified" style="display:block; color: var(--muted-color); margin-top: -0.35rem;"></small>
            <div class="onboarding-grid" id="onboarding-checks"></div>
            <div id="onboarding-next" class="status-message status-info hidden"></div>
            <h4 style="margin: 0.75rem 0 0.4rem 0;">Next Steps</h4>
            <ol id="onboarding-steps" class="step-list"></ol>
            <div class="onboarding-actions">
                <button type="button" onclick="refreshOnboardingStatus()">Refresh Checks</button>
                <button type="button" class="contrast" onclick="runFullReadinessCheck()">Run Full Readiness Check</button>
                <button type="button" class="secondary" onclick="openCloudflareSetupHelp()">Cloudflare Setup Help</button>
                <button type="button" class="secondary" onclick="openSetupCheckView()">Open Diagnostics View</button>
            </div>
            <div id="full-readiness-result" class="status-message status-info hidden"></div>

            <div class="onboarding-help">
                <h4 style="margin: 0 0 0.4rem 0;">Quick Helpers</h4>
                <div class="grid">
                    <div>
                        <label for="repo-owner-input">GitHub Owner (suggested)</label>
                        <input id="repo-owner-input" type="text" placeholder="your-org-or-username">
                    </div>
                    <div>
                        <label for="repo-name-input">Repository Name (suggested)</label>
                        <input id="repo-name-input" type="text" placeholder="your-loon-repo">
                    </div>
                </div>
                <div class="onboarding-actions" style="margin-bottom: 0.5rem;">
                    <button type="button" onclick="copyGithubRepoSuggestion()">Copy GITHUB_REPO Suggestion</button>
                    <button type="button" onclick="generateAndCopySetupToken()">Generate SETUP_TOKEN</button>
                    <button type="button" onclick="copyEnvTemplate()">Copy Env Template</button>
                </div>
                <small style="color: var(--muted-color);">
                    `GITHUB_REPO` must be exactly `owner/repo`. `SETUP_TOKEN` is only for first-admin setup and should be rotated after setup.
                </small>
            </div>
        </div>

        <div id="setup-check-view" class="setup-check-shell hidden">
            <h1>LOON Setup Diagnostics</h1>
            <p style="color: var(--muted-color); margin-top: 0;">
                Browser-only diagnostics view. Use this page to confirm readiness before opening the full admin app.
            </p>
            <div class="onboarding-actions">
                <a href="/admin.html" role="button">Open Admin Login</a>
                <button type="button" class="secondary" onclick="refreshOnboardingStatus()">Refresh Checks</button>
            </div>
        </div>

        <!-- Login Section -->
        <div id="login-section">
            <div class="login-container">
                <h2>LOON Admin</h2>
                
                <div class="form-field">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Enter username" autocomplete="username">
                </div>
                
                <div class="form-field">
                    <label for="password">Password</label>
                    <div class="password-wrapper">
                        <input type="password" id="password" placeholder="Enter password" autocomplete="current-password">
                        <button type="button" class="password-toggle" onclick="togglePassword()">Show</button>
                    </div>
                </div>
                
                <div class="form-field">
                    <label>
                        <input type="checkbox" id="remember-me">
                        Remember me
                    </label>
                </div>
                
                <button onclick="login()" style="width: 100%;">Login</button>
                
                <div style="text-align: center; margin: 1rem 0; color: var(--muted-color);">or</div>
                
                <button onclick="loginWithPasskey()" style="width: 100%;" class="secondary">
                    Login with Passkey
                </button>
                
                <div id="login-error" class="status-message status-error hidden"></div>
            </div>
        </div>

        <!-- Initial Setup Section (shown only when no admin exists) -->
        <div id="setup-section" class="hidden">
            <div class="login-container">
                <h2>LOON Initial Setup</h2>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">
                    Create the first admin account to finish setup.
                </p>

                <div class="form-field">
                    <label for="setup-token">Setup Token</label>
                    <input type="password" id="setup-token" placeholder="Enter SETUP_TOKEN from Cloudflare secret">
                    <small>
                        One-time setup gate only. After first admin is created, rotate/remove this value in Cloudflare.
                    </small>
                </div>

                <div class="form-field">
                    <label for="setup-username">Admin Username</label>
                    <input type="text" id="setup-username" value="admin" autocomplete="username">
                    <small>This becomes your real LOON login username.</small>
                </div>

                <div class="form-field">
                    <label for="setup-password">Admin Password</label>
                    <input type="password" id="setup-password" placeholder="Minimum 8 characters" autocomplete="new-password">
                    <small>This becomes your real LOON login password.</small>
                </div>

                <div class="form-field">
                    <label for="setup-password-confirm">Confirm Password</label>
                    <input type="password" id="setup-password-confirm" placeholder="Re-enter password" autocomplete="new-password">
                </div>

                <button onclick="completeInitialSetup()" style="width: 100%;">Create Admin & Continue</button>

                <div id="setup-error" class="status-message status-error hidden"></div>
            </div>
        </div>

        <!-- App Section (shown after login) -->
        <div id="app-section" class="hidden">
            <header class="header">
                <div>
                    <h1>LOON Admin</h1>
                    <span class="user-info">
                        Logged in as <strong id="display-username"></strong>
                        <span id="display-role" class="role-badge"></span>
                    </span>
                </div>
                <div class="header-controls">
                    <label for="theme-select">Theme</label>
                    <select id="theme-select" onchange="setTheme(this.value)">
                        <option value="default">Slate</option>
                        <option value="forest">Forest</option>
                        <option value="sunset">Sunset</option>
                    </select>
                </div>
            </header>

            <nav class="tab-nav">
                <button onclick="switchTab('editor')" id="tab-editor" class="active">Content Editor</button>
                <button onclick="switchTab('users')" id="tab-users" class="hidden">Manage Users</button>
                <button onclick="switchTab('sessions')" id="tab-sessions" class="hidden">Sessions</button>
                <button onclick="switchTab('audit')" id="tab-audit" class="hidden">Audit Log</button>
                <button onclick="switchTab('account')" id="tab-account">My Account</button>
                <button onclick="logout()" class="logout-btn">Logout</button>
            </nav>
            <div id="post-setup-banner" class="status-message status-info hidden">
                Initial setup is complete.
                Security recommendation: rotate or remove SETUP_TOKEN in Cloudflare Pages environment variables.
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.6rem;">
                    <button type="button" onclick="copySetupTokenRotationReminder()">Copy Rotation Reminder</button>
                    <button type="button" class="secondary" onclick="dismissPostSetupBanner()">Dismiss</button>
                </div>
            </div>
            <div id="first-page-wizard" class="status-message status-info hidden">
                First-time setup helper: create and save your first page now to verify the full GitHub write path.
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.6rem;">
                    <button type="button" onclick="startFirstPageWizard()">Start First Page Wizard</button>
                    <button type="button" class="secondary" onclick="dismissFirstPageWizard()">Dismiss</button>
                </div>
            </div>

            <!-- Editor Tab -->
            <div id="view-editor">
                <details class="editor-guide">
                    <summary>Editor Quick Guide</summary>
                    <ol>
                        <li>Load a page, edit fields, then save directly or stage changes with Batch Session Mode.</li>
                        <li>Use <code>Ctrl/Cmd+S</code> to save/stage quickly. Use <code>Ctrl/Cmd+Shift+S</code> to save as draft.</li>
                        <li>Import existing content from <code>.json</code>, <code>.tid</code>, markdown, text, or HTML.</li>
                        <li>Publish only after staged changes are pushed and reviewed.</li>
                    </ol>
                </details>
                <div class="page-selector">
                    <input type="text" id="pageId" placeholder="Enter Page ID (e.g., demo, blog-post)">
                    <button onclick="loadEditor()" class="secondary" title="Open this page in the editor">Open Page</button>
                    <button onclick="loadPageList()" class="outline" style="margin-left: 0.5rem;" title="Browse pages you can access">Browse Pages</button>
                    <button onclick="showNewPageDialog()" class="contrast" style="margin-left: 0.5rem;" title="Create a new page with optional template">+ Create Page</button>
                </div>
                
                <!-- New Page Dialog -->
                <div id="new-page-dialog" class="hidden" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--muted-border-color); border-radius: 4px;">
                    <h4>Create New Page</h4>
                    <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-field">
                            <label for="new-page-id">Page ID *</label>
                            <input type="text" id="new-page-id" placeholder="e.g., my-page (lowercase, hyphens ok)" pattern="^[a-z0-9-]+$">
                            <small style="color: var(--muted-color);">lowercase letters, numbers, hyphens only</small>
                        </div>
                        <div class="form-field">
                            <label for="new-page-title">Page Title</label>
                            <input type="text" id="new-page-title" placeholder="e.g., My Page">
                        </div>
                    </div>
                    <div class="form-field">
                        <label for="new-page-template">Template (optional)</label>
                        <select id="new-page-template">
                            <option value="">Blank Page</option>
                            <option value="blog-post">Blog Post</option>
                            <option value="directory-entry">Directory Entry</option>
                            <option value="faq">FAQ</option>
                        </select>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="createNewPage()" class="contrast">Create Page</button>
                        <button onclick="cancelNewPage()" class="outline">Cancel</button>
                    </div>
                    <div id="new-page-status"></div>
                </div>
                
                <!-- Page Browser -->
                <div id="page-browser" class="hidden" style="margin-bottom: 1.5rem;">
                    <h4>Available Pages</h4>
                    <input type="text" id="page-browser-filter" placeholder="Filter pages by title or id..." style="margin-bottom: 0.65rem;" oninput="filterPageBrowserList()">
                    <div id="page-list" style="display: grid; gap: 0.5rem; max-height: 300px; overflow-y: auto;"></div>
                    <div id="page-browser-status"></div>
                </div>
                
                <div id="editor-container" class="editor-container hidden">
                    <h3 id="editor-title">Page Editor</h3>
                    <div id="editor-form"></div>
                    
                    <div id="content-meta" class="meta-info hidden"></div>
                    <div id="content-status" style="margin: 1rem 0; padding: 0.75rem; background: #e7f3ff; border-left: 4px solid #2196F3; display: none;">
                        <strong id="status-text"></strong>
                    </div>
                    <div id="workflow-assistant" class="workflow-assistant">
                        <strong>Workflow Assistant</strong>
                        <small>Load a page to see recommended next actions.</small>
                        <div id="workflow-assistant-body"></div>
                    </div>
                    
                    <div class="save-bar">
                        <span class="last-saved" id="last-saved"></span>
                        <span id="edit-dirty-chip" class="edit-dirty-chip">No local edits</span>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <label class="batch-toggle" for="batch-mode-toggle" title="Stage edits during this session, then push all at once">
                                <input type="checkbox" id="batch-mode-toggle" onchange="setBatchModeEnabled(this.checked)">
                                Batch Session Mode
                            </label>
                            <button onclick="triggerImportFileDialog()" id="import-btn" class="outline" title="Import JSON, .tid, markdown, HTML, or text into this form">
                                Import File
                            </button>
                            <button onclick="pushAllChanges()" id="push-all-btn" class="secondary hidden">
                                Push All Changes (0)
                            </button>
                            <button onclick="saveContentAsDraft()" id="draft-btn" style="display: none;">Save as Draft</button>
                            <button onclick="saveContent()" id="save-btn">Save Changes</button>
                            <button onclick="publishContent()" id="publish-btn" class="contrast" style="display: none;">Publish</button>
                            <button onclick="deleteContent()" id="delete-btn" class="outline" style="color: var(--error); display: none;">Delete</button>
                        </div>
                    </div>
                    <div id="queue-summary" class="queue-summary"></div>
                    <div id="autosave-indicator" class="autosave-indicator"></div>
                    <div class="editor-tools">
                        <details>
                            <summary>Internal Link Tools</summary>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                <select id="link-page-select" style="min-width:220px;">
                                    <option value="">Select a page link...</option>
                                </select>
                                <button type="button" class="secondary" onclick="insertSelectedPageLink()">Insert [[page-id]]</button>
                                <button type="button" class="outline" onclick="refreshLinkPageList()">Refresh Pages</button>
                                <button type="button" class="outline" onclick="findBacklinks()">Find Backlinks</button>
                            </div>
                            <div id="backlinks-status" style="margin-top:0.5rem;"></div>
                            <div id="backlinks-list" style="margin-top:0.5rem;"></div>
                        </details>
                        <details>
                            <summary>Revision History</summary>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                <button type="button" class="secondary" onclick="loadRevisionHistory()">Load Revisions</button>
                                <button type="button" class="outline" onclick="openDiffForLatestTwo()">Diff Latest Two</button>
                            </div>
                            <div id="revision-status" style="margin-top:0.5rem;"></div>
                            <div id="revision-list" style="margin-top:0.5rem;"></div>
                            <div id="revision-diff" class="diff-view" style="margin-top:0.6rem; display:none;"></div>
                        </details>
                        <details>
                            <summary>Workflow + Watchlist</summary>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                <select id="workflow-status-select" style="min-width:180px;">
                                    <option value="draft">Draft</option>
                                    <option value="in_review">In Review</option>
                                    <option value="approved">Approved</option>
                                    <option value="scheduled">Scheduled</option>
                                    <option value="published">Published</option>
                                </select>
                                <input type="datetime-local" id="workflow-scheduled-for">
                                <button type="button" class="secondary" onclick="updateWorkflowStatus()">Update Workflow</button>
                                <button type="button" class="outline" onclick="runScheduledPublishNow()">Run Scheduled Publish</button>
                            </div>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                <button type="button" class="outline" id="watch-toggle-btn" onclick="toggleWatchPage()">Watch Page</button>
                                <button type="button" class="outline" onclick="loadWatchActivity()">Refresh Watch Activity</button>
                            </div>
                            <div id="workflow-status-panel" style="margin-top:0.5rem;"></div>
                            <div id="watch-activity-list" style="margin-top:0.5rem;"></div>
                        </details>
                        <details>
                            <summary>Reusable Blocks</summary>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                <select id="block-select" style="min-width:220px;">
                                    <option value="">Select a reusable block...</option>
                                </select>
                                <button type="button" class="secondary" onclick="insertSelectedBlock()">Insert Block</button>
                                <button type="button" class="outline" onclick="loadReusableBlocks()">Refresh Blocks</button>
                            </div>
                            <div id="blocks-status" style="margin-top:0.5rem;"></div>
                        </details>
                    </div>
                    <input type="file" id="import-file-input" class="hidden" accept=".json,.tid,.md,.markdown,.txt,.html,.htm" onchange="handleImportFileChosen(event)">
                </div>
                
                <div id="editor-status"></div>
            </div>

            <!-- Users Tab (Admin only) -->
            <div id="view-users" class="hidden">
                <h3>Team Members</h3>
                
                <table class="user-table" role="grid">
                    <thead>
                        <tr>
                            <th>Username</th>
                            <th>Role</th>
                            <th>Created</th>
                            <th class="actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="user-list"></tbody>
                </table>
                
                <div id="users-status"></div>
                
                <div class="add-user-form">
                    <h4>Add New User</h4>
                    <div class="grid">
                        <div class="form-field">
                            <label for="new-username">Username</label>
                            <input type="text" id="new-username" placeholder="lowercase, no spaces">
                        </div>
                        <div class="form-field">
                            <label for="new-password">Password (optional)</label>
                            <input type="text" id="new-password" placeholder="Leave blank to auto-generate">
                        </div>
                        <div class="form-field">
                            <label for="new-role">Role</label>
                            <select id="new-role">
                                <option value="contributor">Contributor</option>
                                <option value="editor">Editor</option>
                                <option value="admin">Admin</option>
                            </select>
                        </div>
                    </div>
                    <button onclick="createUser()">Create User</button>
                    
                    <div id="create-user-result" class="hidden"></div>
                </div>
            </div>

            <!-- Sessions Tab (Admin only) -->
            <div id="view-sessions" class="hidden">
                <h3>Active Sessions</h3>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">Monitor and manage user sessions for security.</p>
                
                <table class="user-table" role="grid">
                    <thead>
                        <tr>
                            <th>User</th>
                            <th>Role</th>
                            <th>Login Time</th>
                            <th>IP Address</th>
                            <th class="actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="session-list"></tbody>
                </table>
                
                <div id="sessions-status"></div>
                
                <div style="margin-top: 1.5rem; padding: 1rem; background: var(--muted-border-color); border-radius: 8px;">
                    <h4>Force Logout User</h4>
                    <p style="color: var(--muted-color); font-size: 0.9rem; margin-bottom: 1rem;">Revoke all sessions for a user (useful if account is compromised).</p>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" id="force-logout-username" placeholder="Username" style="flex: 1;">
                        <button onclick="forceLogoutUser()" class="secondary">Revoke All Sessions</button>
                    </div>
                </div>
            </div>

            <!-- Account Tab -->
            <div id="view-account" class="hidden">
                <h3>My Account</h3>
                
                <div class="account-info" style="margin-bottom: 2rem; padding: 1rem; background: var(--muted-border-color); border-radius: 8px;">
                    <p><strong>Username:</strong> <span id="account-username"></span></p>
                    <p><strong>Role:</strong> <span id="account-role"></span></p>
                </div>
                
                <div class="change-password-form" style="max-width: 400px;">
                    <h4>Change Password</h4>
                    
                    <div class="form-field">
                        <label for="current-password">Current Password</label>
                        <input type="password" id="current-password" autocomplete="current-password">
                    </div>
                    
                    <div class="form-field">
                        <label for="new-password-self">New Password</label>
                        <input type="password" id="new-password-self" autocomplete="new-password">
                        <small style="color: var(--muted-color);">Minimum 8 characters</small>
                    </div>
                    
                    <div class="form-field">
                        <label for="confirm-password">Confirm New Password</label>
                        <input type="password" id="confirm-password" autocomplete="new-password">
                    </div>
                    
                    <button onclick="changePassword()">Change Password</button>
                    
                    <div id="password-change-status"></div>
                </div>
                
                <!-- Passkeys Section -->
                <div class="passkeys-section" style="margin-top: 3rem;">
                    <h4>Passkeys</h4>
                    <p style="color: var(--muted-color); margin-bottom: 1rem;">
                        Passkeys are more secure than passwords and protect against phishing. 
                        <a href="/docs/PASSKEYS_GUIDE.md" target="_blank">Learn more</a>
                    </p>
                    
                    <div id="passkey-browser-check" class="hidden" style="padding: 1rem; background: var(--warning); color: black; border-radius: 8px; margin-bottom: 1rem;">
                        <strong>Passkeys not supported</strong> - Your browser doesn't support WebAuthn. Please use Chrome, Edge, Safari, or Firefox.
                    </div>
                    
                    <div id="passkeys-list" style="margin-bottom: 1.5rem;">
                        <h5 style="margin-bottom: 0.5rem;">Your Passkeys</h5>
                        <div id="passkeys-list-container"></div>
                    </div>
                    
                    <button id="register-passkey-btn" onclick="registerPasskey()" class="secondary">+ Register New Passkey</button>
                    
                    <div id="passkey-status" style="margin-top: 1rem;"></div>
                    
                    <!-- Recovery Codes Modal -->
                    <div id="recovery-codes-modal" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 9999;">
                        <div style="background: var(--background-color); padding: 2rem; border-radius: 8px; max-width: 500px; width: 90%;">
                            <h4>Save Your Recovery Codes</h4>
                            <p style="color: var(--muted-color);">
                                If you lose access to all your passkeys, these codes can help you recover your account. 
                                <strong>Store them securely</strong> - each code can only be used once.
                            </p>
                            <div id="recovery-codes-display" style="background: var(--code-background-color); padding: 1rem; border-radius: 4px; font-family: monospace; margin: 1rem 0; line-height: 1.8;"></div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="downloadRecoveryCodes()" class="secondary">Download</button>
                                <button onclick="copyRecoveryCodes()" class="outline">Copy</button>
                                <button onclick="closeRecoveryCodesModal()" style="margin-left: auto;">I've Saved Them</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Audit Log Tab (Admin only) -->
            <div id="view-audit" class="hidden">
                <h3>Audit Log</h3>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">Track admin actions and content changes.</p>
                
                <div style="margin-bottom: 1.5rem; display: flex; gap: 0.5rem; align-items: center;">
                    <input type="number" id="audit-limit" value="100" style="width: 80px;" placeholder="Limit">
                    <button onclick="loadAuditLog()" class="secondary">Load</button>
                    <button onclick="downloadAuditLog()" class="outline">Download CSV</button>
                </div>
                
                <div id="audit-loading" class="hidden" style="text-align: center; padding: 2rem; color: var(--muted-color);">Loading...</div>
                
                <table class="user-table" role="grid" id="audit-table" style="font-size: 0.9rem;">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>User</th>
                            <th>Action</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody id="audit-list"></tbody>
                </table>
                
                <div id="audit-status"></div>
            </div>
        </div>
    </main>

    <footer class="container" style="text-align: center; margin-top: 3rem; color: var(--muted-color);">
        <small>LOON Admin Panel</small>
    </footer>

    <script>
        // =================================================================
        // STATE
        // =================================================================
        let SESSION = null;
        let CURRENT_SCHEMA = null;
        let CURRENT_CONTENT = null;
        let CURRENT_PAGE_ID = null;
        let BATCH_MODE_ENABLED = false;
        let PENDING_CHANGES = [];
        let AUTO_STAGE_TIMER = null;
        let AUTOSAVE_TIMER = null;
        let LAST_FOCUSED_FIELD_ID = null;
        let PAGE_CACHE = [];
        let WATCHED_PAGES = [];
        let BLOCK_CACHE = [];
        let REVISION_CACHE = [];
        let PAGE_BROWSER_ITEMS = [];
        let PAGE_BROWSER_CAN_EDIT_ALL = false;
        let HAS_LOCAL_CHANGES = false;
        let EDITOR_BUSY = false;
        let PASSKEY_ENV_READY = null;

        const STORAGE_KEYS = {
            SESSION: 'loon_session',
            LAST_PAGE: 'loon_last_page',
            POST_SETUP_NOTICE: 'loon_post_setup_notice',
            LAST_READINESS: 'loon_last_readiness',
            FIRST_PAGE_WIZARD_DISMISSED: 'loon_first_page_wizard_dismissed',
            THEME: 'loon_theme',
            BATCH_MODE: 'loon_batch_mode',
            PENDING_CHANGES: 'loon_pending_changes',
            AUTOSAVE_PREFIX: 'loon_autosave_'
        };
        let ONBOARDING_TIMER = null;
        const VIEW_MODE = new URLSearchParams(window.location.search).get('view') || 'default';

        // =================================================================
        // INITIALIZATION
        // =================================================================
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initBatchMode();
            prefillRepoSuggestion();
            hydrateLastReadinessStamp();

            if (VIEW_MODE === 'setup-check') {
                startOnboardingMonitor();
                showSetupCheckView();
                return;
            }

            // Check for saved session (localStorage or sessionStorage)
            const saved = localStorage.getItem(STORAGE_KEYS.SESSION) || sessionStorage.getItem(STORAGE_KEYS.SESSION);
            if (saved) {
                try {
                    SESSION = JSON.parse(saved);
                    
                    // Check if session expired client-side
                    if (SESSION.expiresAt && Date.now() > SESSION.expiresAt) {
                        console.log('Session expired client-side');
                        localStorage.removeItem(STORAGE_KEYS.SESSION);
                        sessionStorage.removeItem(STORAGE_KEYS.SESSION);
                        SESSION = null;
                    } else {
                        showApp();
                        // Verify session is still valid server-side
                        verifySession();
                    }
                } catch (e) {
                    localStorage.removeItem(STORAGE_KEYS.SESSION);
                    sessionStorage.removeItem(STORAGE_KEYS.SESSION);
                    SESSION = null;
                }
            }

            if (!SESSION) {
                startOnboardingMonitor();
                checkInitialSetupStatus();
            }

            // Restore last page ID
            const lastPage = localStorage.getItem(STORAGE_KEYS.LAST_PAGE);
            if (lastPage) {
                document.getElementById('pageId').value = lastPage;
            }

            // Enter key handlers
            document.getElementById('username').addEventListener('keypress', e => {
                if (e.key === 'Enter') document.getElementById('password').focus();
            });
            document.getElementById('password').addEventListener('keypress', e => {
                if (e.key === 'Enter') login();
            });
            document.getElementById('setup-password-confirm').addEventListener('keypress', e => {
                if (e.key === 'Enter') completeInitialSetup();
            });
            document.getElementById('pageId').addEventListener('keypress', e => {
                if (e.key === 'Enter') loadEditor();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', e => {
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    if (CURRENT_SCHEMA) handlePrimarySaveAction();
                }
                if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'S' || e.key === 's')) {
                    e.preventDefault();
                    if (CURRENT_SCHEMA && SESSION && SESSION.role !== 'contributor') {
                        saveContentAsDraft();
                    }
                }
            });
        });

        function initTheme() {
            const savedTheme = localStorage.getItem(STORAGE_KEYS.THEME) || 'default';
            setTheme(savedTheme, false);
        }

        function setTheme(theme, persist = true) {
            const normalized = ['default', 'forest', 'sunset'].includes(theme) ? theme : 'default';
            if (normalized === 'default') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', normalized);
            }

            const select = document.getElementById('theme-select');
            if (select) select.value = normalized;
            if (persist) localStorage.setItem(STORAGE_KEYS.THEME, normalized);
        }

        function initBatchMode() {
            BATCH_MODE_ENABLED = localStorage.getItem(STORAGE_KEYS.BATCH_MODE) === '1';
            const rawQueue = localStorage.getItem(STORAGE_KEYS.PENDING_CHANGES);
            if (rawQueue) {
                try {
                    const parsed = JSON.parse(rawQueue);
                    if (Array.isArray(parsed)) {
                        PENDING_CHANGES = parsed;
                    }
                } catch {
                    PENDING_CHANGES = [];
                }
            }

            const toggle = document.getElementById('batch-mode-toggle');
            if (toggle) {
                toggle.checked = BATCH_MODE_ENABLED;
            }
            updateBatchUi();
        }

        window.addEventListener('beforeunload', (event) => {
            if (PENDING_CHANGES.length > 0 || HAS_LOCAL_CHANGES) {
                event.preventDefault();
                event.returnValue = '';
            }
        });

        function setEditorBusy(busy) {
            EDITOR_BUSY = !!busy;
            const ids = ['save-btn', 'draft-btn', 'publish-btn', 'push-all-btn', 'delete-btn', 'import-btn'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                el.disabled = EDITOR_BUSY;
            });
        }

        function markEditorDirty(isDirty) {
            HAS_LOCAL_CHANGES = !!isDirty;
            const chip = document.getElementById('edit-dirty-chip');
            if (!chip) return;
            if (HAS_LOCAL_CHANGES) {
                chip.textContent = 'Unsaved local edits';
                chip.classList.add('dirty');
            } else {
                chip.textContent = 'No local edits';
                chip.classList.remove('dirty');
            }
        }

        function setBatchModeEnabled(enabled) {
            BATCH_MODE_ENABLED = !!enabled;
            localStorage.setItem(STORAGE_KEYS.BATCH_MODE, BATCH_MODE_ENABLED ? '1' : '0');
            if (!BATCH_MODE_ENABLED && AUTO_STAGE_TIMER) {
                clearTimeout(AUTO_STAGE_TIMER);
                AUTO_STAGE_TIMER = null;
            }
            updateBatchUi();
            if (BATCH_MODE_ENABLED) {
                showStatus('editor-status', 'Batch Session Mode enabled. Changes are staged in your browser until you click Push All Changes.', 'info');
            } else {
                showStatus('editor-status', 'Batch Session Mode disabled. Save actions now commit immediately to GitHub.', 'info');
            }
        }

        function persistPendingChanges() {
            localStorage.setItem(STORAGE_KEYS.PENDING_CHANGES, JSON.stringify(PENDING_CHANGES));
        }

        function updateBatchUi() {
            const pushBtn = document.getElementById('push-all-btn');
            const toggle = document.getElementById('batch-mode-toggle');
            const summary = document.getElementById('queue-summary');
            const saveBtn = document.getElementById('save-btn');
            const draftBtn = document.getElementById('draft-btn');
            if (toggle) toggle.checked = BATCH_MODE_ENABLED;

            if (!pushBtn) return;
            pushBtn.textContent = `Push All Changes (${PENDING_CHANGES.length})`;

            if (BATCH_MODE_ENABLED) {
                pushBtn.classList.remove('hidden');
            } else {
                pushBtn.classList.add('hidden');
            }

            if (summary) {
                if (!PENDING_CHANGES.length) {
                    summary.textContent = BATCH_MODE_ENABLED
                        ? 'No staged changes yet. Edit content to stage updates for this session.'
                        : '';
                } else {
                    const pageCount = new Set(PENDING_CHANGES.map(item => item.pageId)).size;
                    summary.textContent = `${PENDING_CHANGES.length} staged change(s) across ${pageCount} page(s). Push all before publishing.`;
                }
            }

            if (saveBtn) {
                saveBtn.textContent = BATCH_MODE_ENABLED ? 'Stage Change' : 'Save Changes';
                saveBtn.title = BATCH_MODE_ENABLED
                    ? 'Stage this page change in your browser queue'
                    : 'Save and commit this change immediately';
            }

            if (draftBtn) {
                draftBtn.textContent = BATCH_MODE_ENABLED ? 'Stage Draft' : 'Save as Draft';
                draftBtn.title = BATCH_MODE_ENABLED
                    ? 'Stage this draft change in your browser queue'
                    : 'Save draft immediately';
            }

            renderWorkflowAssistant();
        }

        function getStagedLabel(saveAs) {
            return saveAs === 'draft' ? 'draft' : 'live';
        }

        function getCurrentPageSaveMode() {
            if (SESSION && SESSION.role === 'contributor') return 'draft';
            return 'live';
        }

        function getQueueKey(pageId, mode) {
            return `${pageId}::${mode}`;
        }

        function getQueuedChangeForPage(pageId, preferredMode = null) {
            const mode = preferredMode || getCurrentPageSaveMode();
            const key = getQueueKey(pageId, mode);
            return PENDING_CHANGES.find(item => item.key === key) || null;
        }

        function hasQueuedChangeForCurrentPage() {
            if (!CURRENT_PAGE_ID) return false;
            return !!getQueuedChangeForPage(CURRENT_PAGE_ID);
        }

        function scheduleAutoStage() {
            if (!BATCH_MODE_ENABLED || !CURRENT_PAGE_ID || !CURRENT_SCHEMA) return;
            if (AUTO_STAGE_TIMER) clearTimeout(AUTO_STAGE_TIMER);
            AUTO_STAGE_TIMER = setTimeout(() => {
                const mode = getCurrentPageSaveMode();
                stageCurrentContentChange(mode === 'draft' ? 'draft' : null, { silent: true });
            }, 450);
        }

        function stageCurrentContentChange(saveAs = null, options = {}) {
            const content = collectCurrentFormContent();
            const mode = saveAs === 'draft' ? 'draft' : 'live';
            const key = getQueueKey(CURRENT_PAGE_ID, mode);
            const entry = {
                key,
                pageId: CURRENT_PAGE_ID,
                saveAs: saveAs === 'draft' ? 'draft' : null,
                content,
                queuedAt: Date.now()
            };

            PENDING_CHANGES = PENDING_CHANGES.filter(item => item.key !== key);
            PENDING_CHANGES.push(entry);
            persistPendingChanges();
            updateBatchUi();

            CURRENT_CONTENT = content;
            document.getElementById('last-saved').textContent = `Staged ${getStagedLabel(saveAs)} change at ${new Date().toLocaleTimeString()}`;
            markEditorDirty(false);
            if (!options.silent) {
                showStatus('editor-status', `Change staged for ${CURRENT_PAGE_ID}. Click "Push All Changes" when ready.`, 'success');
                setTimeout(() => hideStatus('editor-status'), 2500);
            }
        }

        async function pushAllChanges() {
            if (!PENDING_CHANGES.length) {
                showStatus('editor-status', 'No staged changes to push.', 'info');
                return;
            }
            if (EDITOR_BUSY) return;

            setEditorBusy(true);
            const queue = [...PENDING_CHANGES];
            const total = queue.length;

            try {
                for (let i = 0; i < queue.length; i++) {
                    const item = queue[i];
                    showStatus('editor-status', `Pushing staged change ${i + 1}/${total} for "${item.pageId}"...`, 'info');
                    await sendSaveRequest(item.pageId, item.content, item.saveAs);
                    PENDING_CHANGES = PENDING_CHANGES.filter(change => change.key !== item.key);
                    persistPendingChanges();
                    updateBatchUi();
                }

                document.getElementById('last-saved').textContent = `Pushed ${total} staged change(s)`;
                markEditorDirty(false);
                showStatus('editor-status', `Pushed ${total} staged change(s) successfully.`, 'success');
                setTimeout(() => hideStatus('editor-status'), 3000);
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Push failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        function handlePrimarySaveAction() {
            if (SESSION && SESSION.role === 'contributor') {
                return saveContentAsDraft();
            }
            return saveContent();
        }

        function renderWorkflowAssistant() {
            const body = document.getElementById('workflow-assistant-body');
            if (!body) return;

            const pageLoaded = !!CURRENT_PAGE_ID;
            const queuedForPage = hasQueuedChangeForCurrentPage();
            const totalQueued = PENDING_CHANGES.length;
            const canPublish = SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor');

            if (!SESSION) {
                body.innerHTML = '<small>Log in to start editing.</small>';
                return;
            }

            if (!pageLoaded) {
                body.innerHTML = '<small>Next: Load a page or create a new page.</small>';
                return;
            }

            const actions = [];
            actions.push(`Role: <code>${escapeHtml(SESSION.role)}</code>`);
            actions.push(`Mode: <code>${BATCH_MODE_ENABLED ? 'batch staging' : 'immediate commits'}</code>`);
            actions.push(`Queued changes: <code>${totalQueued}</code>`);

            if (BATCH_MODE_ENABLED && totalQueued > 0) {
                actions.push('Recommended: Click <strong>Push All Changes</strong> before ending session.');
            }

            if (queuedForPage && canPublish) {
                actions.push('Publish is blocked until staged changes for this page are pushed.');
            } else if (!queuedForPage && canPublish) {
                actions.push('This page is ready to publish after review.');
            }

            if (SESSION.role === 'contributor') {
                actions.push('Contributors can stage/save drafts but cannot publish.');
            }

            body.innerHTML = `<small>${actions.join(' | ')}</small>`;
        }

        function getAutosaveKey(pageId) {
            return `${STORAGE_KEYS.AUTOSAVE_PREFIX}${pageId}`;
        }

        function clearAutosaveForPage(pageId) {
            if (!pageId) return;
            localStorage.removeItem(getAutosaveKey(pageId));
            updateAutosaveIndicator();
        }

        function updateAutosaveIndicator(message = '') {
            const indicator = document.getElementById('autosave-indicator');
            if (!indicator) return;
            if (message) {
                indicator.textContent = message;
                return;
            }
            if (!CURRENT_PAGE_ID) {
                indicator.textContent = '';
                return;
            }
            const raw = localStorage.getItem(getAutosaveKey(CURRENT_PAGE_ID));
            if (!raw) {
                indicator.textContent = '';
                return;
            }
            try {
                const parsed = JSON.parse(raw);
                if (parsed?.timestamp) {
                    indicator.textContent = `Autosave snapshot: ${new Date(parsed.timestamp).toLocaleTimeString()}`;
                } else {
                    indicator.textContent = 'Autosave snapshot available';
                }
            } catch {
                indicator.textContent = 'Autosave snapshot available';
            }
        }

        function writeAutosaveSnapshot() {
            if (!CURRENT_PAGE_ID || !CURRENT_SCHEMA) return;
            const content = collectCurrentFormContent();
            localStorage.setItem(getAutosaveKey(CURRENT_PAGE_ID), JSON.stringify({
                timestamp: Date.now(),
                content
            }));
            updateAutosaveIndicator(`Autosaved at ${new Date().toLocaleTimeString()}`);
        }

        function scheduleAutosave() {
            if (!CURRENT_PAGE_ID || !CURRENT_SCHEMA) return;
            if (AUTOSAVE_TIMER) clearTimeout(AUTOSAVE_TIMER);
            AUTOSAVE_TIMER = setTimeout(() => {
                writeAutosaveSnapshot();
            }, 1500);
        }

        function maybeRestoreAutosave(pageId) {
            const raw = localStorage.getItem(getAutosaveKey(pageId));
            if (!raw) return false;
            try {
                const parsed = JSON.parse(raw);
                if (!parsed?.content || typeof parsed.content !== 'object') return false;
                const incoming = JSON.stringify(parsed.content || {});
                const current = JSON.stringify(CURRENT_CONTENT || {});
                if (incoming === current) return false;

                const when = parsed.timestamp ? new Date(parsed.timestamp).toLocaleString() : 'recently';
                if (confirm(`A local autosave snapshot from ${when} was found for this page. Restore it?`)) {
                    CURRENT_CONTENT = { ...CURRENT_CONTENT, ...parsed.content };
                    buildForm();
                    markEditorDirty(true);
                    showStatus('editor-status', 'Restored local autosave snapshot. Review and save when ready.', 'info');
                    updateAutosaveIndicator(`Restored autosave from ${when}`);
                    return true;
                }
            } catch {
                return false;
            }
            return false;
        }

        async function refreshLinkPageList() {
            const select = document.getElementById('link-page-select');
            if (!select) return;
            select.innerHTML = '<option value="">Loading pages...</option>';
            try {
                const res = await fetch('/api/pages?minimal=true&limit=200', {
                    headers: SESSION?.token ? { Authorization: `Bearer ${SESSION.token}` } : {}
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load pages');
                PAGE_CACHE = (data.pages || []).map(p => p.pageId).filter(Boolean);
                select.innerHTML = '<option value="">Select a page link...</option>' +
                    PAGE_CACHE.map(pageId => `<option value="${escapeHtml(pageId)}">${escapeHtml(pageId)}</option>`).join('');
            } catch (e) {
                select.innerHTML = '<option value="">Unable to load pages</option>';
            }
        }

        function insertSelectedPageLink() {
            const select = document.getElementById('link-page-select');
            if (!select || !select.value) {
                showStatus('editor-status', 'Select a page link first.', 'error');
                return;
            }
            if (!LAST_FOCUSED_FIELD_ID) {
                showStatus('editor-status', 'Focus a text/textarea field first.', 'error');
                return;
            }
            const input = document.getElementById(LAST_FOCUSED_FIELD_ID);
            if (!input || typeof input.value !== 'string') {
                showStatus('editor-status', 'Focused field does not support text insertion.', 'error');
                return;
            }

            const token = `[[${select.value}]]`;
            const start = input.selectionStart ?? input.value.length;
            const end = input.selectionEnd ?? input.value.length;
            input.value = `${input.value.slice(0, start)}${token}${input.value.slice(end)}`;
            input.focus();
            const nextPos = start + token.length;
            input.setSelectionRange(nextPos, nextPos);
            scheduleAutosave();
            scheduleAutoStage();
            showStatus('editor-status', `Inserted link ${token}`, 'success');
        }

        function collectTextContentStrings(payload) {
            const results = [];
            function walk(node) {
                if (node === null || node === undefined) return;
                if (typeof node === 'string') {
                    results.push(node);
                    return;
                }
                if (Array.isArray(node)) {
                    node.forEach(walk);
                    return;
                }
                if (typeof node === 'object') {
                    Object.values(node).forEach(walk);
                }
            }
            walk(payload);
            return results;
        }

        async function findBacklinks() {
            const statusEl = document.getElementById('backlinks-status');
            const listEl = document.getElementById('backlinks-list');
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            statusEl.textContent = 'Scanning pages for backlinks...';
            listEl.innerHTML = '';

            try {
                if (!PAGE_CACHE.length) {
                    await refreshLinkPageList();
                }
                const candidates = PAGE_CACHE.filter(id => id !== CURRENT_PAGE_ID).slice(0, 120);
                const backlinks = [];
                const needleWiki = `[[${CURRENT_PAGE_ID}]]`;
                const needlePlain = CURRENT_PAGE_ID;

                for (const pageId of candidates) {
                    const res = await fetch(`/data/${pageId}/content.json`, { cache: 'no-store' });
                    if (!res.ok) continue;
                    const content = await res.json();
                    const strings = collectTextContentStrings(content);
                    const linked = strings.some(str => str.includes(needleWiki) || str.includes(needlePlain));
                    if (linked) backlinks.push(pageId);
                }

                statusEl.textContent = `Found ${backlinks.length} backlink(s).`;
                listEl.innerHTML = backlinks.length
                    ? backlinks.map(id => `<div><code>${escapeHtml(id)}</code></div>`).join('')
                    : '<small style="color: var(--muted-color);">No backlinks found.</small>';
            } catch (e) {
                statusEl.textContent = 'Backlink scan failed.';
                listEl.innerHTML = `<small style="color: var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        async function loadRevisionHistory() {
            const statusEl = document.getElementById('revision-status');
            const listEl = document.getElementById('revision-list');
            const diffEl = document.getElementById('revision-diff');
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            statusEl.textContent = 'Loading revision history...';
            listEl.innerHTML = '';
            REVISION_CACHE = [];
            if (diffEl) {
                diffEl.style.display = 'none';
                diffEl.innerHTML = '';
            }

            try {
                const res = await fetch(`/api/history?pageId=${encodeURIComponent(CURRENT_PAGE_ID)}&limit=25`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load history');
                const history = data.history || [];
                REVISION_CACHE = history;
                statusEl.textContent = `${history.length} revision(s) found.`;
                listEl.innerHTML = history.length
                    ? history.map(entry => `
                        <div style="border:1px solid var(--panel-border); border-radius:6px; padding:0.5rem; margin-bottom:0.4rem;">
                            <div><code>${escapeHtml(entry.sha.slice(0, 10))}</code> - ${escapeHtml(entry.message || '(no message)')}</div>
                            <small style="color:var(--muted-color);">${entry.author ? escapeHtml(entry.author) : 'unknown'} | ${entry.date ? new Date(entry.date).toLocaleString() : '-'}</small>
                            <div style="margin-top:0.35rem; display:flex; gap:0.35rem; flex-wrap:wrap;">
                                ${(SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor'))
                                    ? `<button type="button" class="outline" onclick="rollbackToRevision('${escapeHtml(entry.sha)}')">Rollback to This Revision</button>`
                                    : ''}
                                ${entry.url ? `<a href="${escapeHtml(entry.url)}" target="_blank" rel="noopener noreferrer" role="button" class="secondary">Open Commit</a>` : ''}
                            </div>
                        </div>
                    `).join('')
                    : '<small style="color: var(--muted-color);">No revision history available.</small>';
            } catch (e) {
                statusEl.textContent = 'Revision history failed to load.';
                listEl.innerHTML = `<small style="color: var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        async function loadRevisionDiff(fromSha, toSha) {
            const diffEl = document.getElementById('revision-diff');
            if (!diffEl) return;
            diffEl.style.display = 'block';
            diffEl.innerHTML = 'Loading diff...';

            try {
                const query = new URLSearchParams({
                    pageId: CURRENT_PAGE_ID,
                    from: fromSha,
                    to: toSha
                });
                const res = await fetch(`/api/revision-diff?${query.toString()}`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load diff');

                const summary = data.summary || {};
                const rows = Array.isArray(data.diff) ? data.diff : [];
                const html = rows.length
                    ? rows.map(row => {
                        const type = row.type === 'add' ? 'diff-add' : row.type === 'remove' ? 'diff-remove' : 'diff-same';
                        const prefix = row.type === 'add' ? '+' : row.type === 'remove' ? '-' : ' ';
                        return `<div class="diff-line ${type}">${escapeHtml(prefix)} ${escapeHtml(String(row.line ?? ''))}</div>`;
                    }).join('')
                    : '<small style="color: var(--muted-color);">No changes between selected revisions.</small>';

                diffEl.innerHTML = `
                    <div style="margin-bottom:0.5rem;">
                        <strong>Diff ${escapeHtml(fromSha.slice(0, 10))}..${escapeHtml(toSha.slice(0, 10))}</strong><br>
                        <small style="color:var(--muted-color);">
                            +${summary.added || 0} / -${summary.removed || 0} / =${summary.unchanged || 0}
                        </small>
                    </div>
                    ${html}
                `;
            } catch (e) {
                diffEl.innerHTML = `<small style="color: var(--error);">Diff failed: ${escapeHtml(e.message)}</small>`;
            }
        }

        async function openDiffForLatestTwo() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            if (!REVISION_CACHE.length) {
                await loadRevisionHistory();
            }
            if (REVISION_CACHE.length < 2) {
                showStatus('editor-status', 'Need at least 2 revisions to show a diff.', 'error');
                return;
            }
            const toSha = REVISION_CACHE[0].sha;
            const fromSha = REVISION_CACHE[1].sha;
            await loadRevisionDiff(fromSha, toSha);
        }

        async function rollbackToRevision(commitSha) {
            if (!CURRENT_PAGE_ID) return;
            if (!confirm(`Rollback "${CURRENT_PAGE_ID}" to revision ${commitSha.slice(0, 10)}?`)) return;

            showStatus('editor-status', `Rolling back to ${commitSha.slice(0, 10)}...`, 'info');
            try {
                const res = await fetch('/api/rollback', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ pageId: CURRENT_PAGE_ID, commitSha })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Rollback failed');
                clearAutosaveForPage(CURRENT_PAGE_ID);
                showStatus('editor-status', `Rollback complete. Commit: ${data.commit?.slice(0, 10) || 'unknown'}`, 'success');
                await loadEditor();
                await loadRevisionHistory();
            } catch (e) {
                showStatus('editor-status', `Rollback failed: ${e.message}`, 'error');
            }
        }

        async function runScheduledPublishNow() {
            showStatus('editor-status', 'Running scheduled publish...', 'info');
            try {
                const res = await fetch('/api/scheduled-publish', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Scheduled publish failed');

                const publishedCount = Array.isArray(data.published) ? data.published.length : 0;
                const skippedCount = Array.isArray(data.skipped) ? data.skipped.length : 0;
                showStatus('editor-status', `Scheduled publish complete: ${publishedCount} published, ${skippedCount} skipped.`, 'success');

                if (CURRENT_PAGE_ID) {
                    await loadEditor();
                }
            } catch (e) {
                showStatus('editor-status', `Scheduled publish failed: ${e.message}`, 'error');
            }
        }

        function hydrateWorkflowPanelFromContent() {
            const panel = document.getElementById('workflow-status-panel');
            const select = document.getElementById('workflow-status-select');
            const scheduleInput = document.getElementById('workflow-scheduled-for');
            if (!panel || !select) return;
            const meta = CURRENT_CONTENT?._meta || {};
            const status = meta.workflowStatus || meta.status || 'draft';
            select.value = ['draft', 'in_review', 'approved', 'scheduled', 'published'].includes(status) ? status : 'draft';
            if (scheduleInput) {
                if (meta.scheduledFor) {
                    const d = new Date(meta.scheduledFor);
                    if (!Number.isNaN(d.getTime())) {
                        scheduleInput.value = new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                    }
                } else {
                    scheduleInput.value = '';
                }
            }
            panel.innerHTML = `<small>Current workflow: <code>${escapeHtml(status)}</code>${meta.scheduledFor ? ` | Scheduled for ${escapeHtml(meta.scheduledFor)}` : ''}</small>`;
        }

        async function updateWorkflowStatus() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            const select = document.getElementById('workflow-status-select');
            const scheduleInput = document.getElementById('workflow-scheduled-for');
            const status = select?.value || 'draft';
            const scheduledFor = scheduleInput?.value ? new Date(scheduleInput.value).toISOString() : null;

            try {
                const res = await fetch('/api/workflow', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: CURRENT_PAGE_ID,
                        status,
                        scheduledFor: status === 'scheduled' ? scheduledFor : null
                    })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Workflow update failed');
                if (!CURRENT_CONTENT._meta) CURRENT_CONTENT._meta = {};
                CURRENT_CONTENT._meta.workflowStatus = status;
                CURRENT_CONTENT._meta.scheduledFor = status === 'scheduled' ? scheduledFor : undefined;
                hydrateWorkflowPanelFromContent();
                showStatus('editor-status', `Workflow updated to ${status}`, 'success');
                await loadRevisionHistory();
            } catch (e) {
                showStatus('editor-status', `Workflow update failed: ${e.message}`, 'error');
            }
        }

        async function loadWatchActivity() {
            const panel = document.getElementById('watch-activity-list');
            const toggleBtn = document.getElementById('watch-toggle-btn');
            if (!panel || !toggleBtn) return;
            try {
                const res = await fetch('/api/watch', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load watchlist');
                WATCHED_PAGES = data.watchedPages || [];
                const isWatching = CURRENT_PAGE_ID && WATCHED_PAGES.includes(CURRENT_PAGE_ID);
                toggleBtn.textContent = isWatching ? 'Unwatch Page' : 'Watch Page';

                const recent = data.recent || [];
                panel.innerHTML = recent.length
                    ? recent.slice(0, 10).map(item => `
                        <div><small><code>${escapeHtml(item.pageId || '-')}</code> ${escapeHtml(item.action || 'activity')} by ${escapeHtml(item.username || 'unknown')} at ${item.timestamp ? new Date(item.timestamp).toLocaleString() : '-'}</small></div>
                    `).join('')
                    : '<small style="color:var(--muted-color);">No recent watched-page activity.</small>';
            } catch (e) {
                panel.innerHTML = `<small style="color:var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        async function toggleWatchPage() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            const watching = WATCHED_PAGES.includes(CURRENT_PAGE_ID);
            try {
                const res = await fetch('/api/watch', {
                    method: watching ? 'DELETE' : 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ pageId: CURRENT_PAGE_ID })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Watch update failed');
                await loadWatchActivity();
                showStatus('editor-status', watching ? 'Page removed from watchlist' : 'Page added to watchlist', 'success');
            } catch (e) {
                showStatus('editor-status', `Watch update failed: ${e.message}`, 'error');
            }
        }

        async function loadReusableBlocks() {
            const select = document.getElementById('block-select');
            const status = document.getElementById('blocks-status');
            if (!select || !status) return;
            select.innerHTML = '<option value="">Loading blocks...</option>';
            try {
                const res = await fetch('/api/blocks', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load blocks');
                BLOCK_CACHE = data.blocks || [];
                select.innerHTML = '<option value="">Select a reusable block...</option>' +
                    BLOCK_CACHE.map(item => `<option value="${escapeHtml(item.id)}">${escapeHtml(item.label)}</option>`).join('');
                status.innerHTML = `<small>Loaded ${BLOCK_CACHE.length} block(s) from ${escapeHtml(data.source || 'unknown source')}.</small>`;
            } catch (e) {
                select.innerHTML = '<option value="">Unable to load blocks</option>';
                status.innerHTML = `<small style="color:var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        function insertSelectedBlock() {
            const select = document.getElementById('block-select');
            if (!select || !select.value) {
                showStatus('editor-status', 'Select a block first.', 'error');
                return;
            }
            const block = BLOCK_CACHE.find(item => item.id === select.value);
            if (!block) {
                showStatus('editor-status', 'Block not found in cache.', 'error');
                return;
            }
            if (!LAST_FOCUSED_FIELD_ID) {
                showStatus('editor-status', 'Focus a text/textarea field first.', 'error');
                return;
            }
            const input = document.getElementById(LAST_FOCUSED_FIELD_ID);
            if (!input || typeof input.value !== 'string') {
                showStatus('editor-status', 'Focused field does not support text insertion.', 'error');
                return;
            }
            const snippet = `\n${block.content}\n`;
            const start = input.selectionStart ?? input.value.length;
            const end = input.selectionEnd ?? input.value.length;
            input.value = `${input.value.slice(0, start)}${snippet}${input.value.slice(end)}`;
            input.focus();
            const nextPos = start + snippet.length;
            input.setSelectionRange(nextPos, nextPos);
            scheduleAutosave();
            scheduleAutoStage();
            showStatus('editor-status', `Inserted block "${block.label}"`, 'success');
        }

        // =================================================================
        // AUTHENTICATION
        // =================================================================

        async function checkInitialSetupStatus() {
            try {
                const status = await refreshOnboardingStatus();
                const data = status.setupData;
                const resOk = status.setupOk;

                if (resOk && data.setupRequired) {
                    showSetup();

                    if (!data.setupTokenConfigured) {
                        showError('setup-error', [
                            'Initial setup is required, but SETUP_TOKEN is not configured.',
                            'Cloudflare Pages -> Settings -> Environment variables -> add SETUP_TOKEN as a Secret, then redeploy.'
                        ].join('\n'));
                    }
                } else {
                    showLogin();
                }
            } catch (e) {
                // Fall back to login mode if setup status check fails.
                showLogin();
            }
        }

        function showLogin() {
            document.getElementById('onboarding-guide').classList.remove('hidden');
            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('login-section').classList.remove('hidden');
        }

        function showSetup() {
            document.getElementById('onboarding-guide').classList.remove('hidden');
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('setup-section').classList.remove('hidden');
        }

        function showSetupCheckView() {
            document.getElementById('setup-check-view').classList.remove('hidden');
            document.getElementById('onboarding-guide').classList.remove('hidden');
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('app-section').classList.add('hidden');
        }

        function startOnboardingMonitor() {
            if (ONBOARDING_TIMER) clearInterval(ONBOARDING_TIMER);
            refreshOnboardingStatus();
            ONBOARDING_TIMER = setInterval(refreshOnboardingStatus, 30000);
        }

        function stopOnboardingMonitor() {
            if (ONBOARDING_TIMER) {
                clearInterval(ONBOARDING_TIMER);
                ONBOARDING_TIMER = null;
            }
        }

        function openSetupCheckView() {
            window.open('/admin.html?view=setup-check', '_blank', 'noopener,noreferrer');
        }

        function prefillRepoSuggestion() {
            const ownerInput = document.getElementById('repo-owner-input');
            const repoInput = document.getElementById('repo-name-input');
            if (!ownerInput || !repoInput) return;

            const host = window.location.hostname || '';
            const firstLabel = host.split('.')[0] || '';
            let repoGuess = firstLabel
                .replace(/-pages$/, '')
                .replace(/[^a-zA-Z0-9._-]/g, '');
            if (!repoGuess || repoGuess === 'www' || repoGuess === 'localhost') {
                repoGuess = 'your-loon-repo';
            }

            repoInput.value = repoGuess;
            if (!ownerInput.value) ownerInput.value = 'your-github-owner';
        }

        function getRepoSuggestion() {
            const owner = (document.getElementById('repo-owner-input')?.value || '').trim();
            const repo = (document.getElementById('repo-name-input')?.value || '').trim();
            if (!owner || !repo) return null;
            return `${owner}/${repo}`;
        }

        function getPasskeyEnvSuggestion() {
            const host = window.location.hostname || '';
            const isLocal = host === 'localhost' || host === '127.0.0.1';
            const protocol = isLocal ? 'http:' : (window.location.protocol || 'https:');
            const origin = `${protocol}//${host || 'localhost'}`;
            return {
                rpId: host || 'localhost',
                rpOrigin: origin
            };
        }

        async function checkPasskeyServerConfig() {
            try {
                const res = await fetch('/api/health', { cache: 'no-store' });
                if (!res.ok) {
                    PASSKEY_ENV_READY = null;
                    return null;
                }
                const data = await res.json();
                const checks = data?.checks || {};
                const ready = !!checks.passkeys_ready;
                PASSKEY_ENV_READY = ready;
                return {
                    ready,
                    hasRpId: !!checks.passkeys_rp_id,
                    hasRpOrigin: !!checks.passkeys_rp_origin
                };
            } catch {
                PASSKEY_ENV_READY = null;
                return null;
            }
        }

        function showPasskeyOptionalStatus(config) {
            const passkeyEnv = getPasskeyEnvSuggestion();
            const registerBtn = document.getElementById('register-passkey-btn');
            if (registerBtn) {
                registerBtn.disabled = config?.ready === false;
            }

            if (config?.ready) {
                showStatus('passkey-status', 'Passkeys are configured and optional. You can keep using password login, or register a passkey anytime.', 'info');
                return;
            }

            if (config?.ready === false) {
                const msg = [
                    'Passkeys are optional and currently not configured for this deployment.',
                    `To enable later: set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare env vars, then redeploy.`,
                    'Password login continues to work normally.'
                ].join('\n');
                showStatus('passkey-status', msg, 'info');
            }
        }

        async function copyGithubRepoSuggestion() {
            const suggestion = getRepoSuggestion();
            if (!suggestion) {
                alert('Enter both GitHub owner and repository name first.');
                return;
            }
            try {
                await navigator.clipboard.writeText(suggestion);
                alert(`Copied: ${suggestion}`);
            } catch {
                alert(suggestion);
            }
        }

        function generateSecureToken(length = 48) {
            const bytes = new Uint8Array(length);
            crypto.getRandomValues(bytes);
            return Array.from(bytes, b => (b % 36).toString(36)).join('');
        }

        async function generateAndCopySetupToken() {
            const token = generateSecureToken(64);
            try {
                await navigator.clipboard.writeText(token);
                alert('Generated and copied SETUP_TOKEN.');
            } catch {
                alert(token);
            }
        }

        async function copyEnvTemplate() {
            const repo = getRepoSuggestion() || 'owner/repo';
            const setupToken = generateSecureToken(64);
            const passkeyEnv = getPasskeyEnvSuggestion();
            const template = [
                `GITHUB_REPO=${repo}`,
                'GITHUB_TOKEN=<set-as-secret>',
                `SETUP_TOKEN=${setupToken}`,
                `RP_ID=${passkeyEnv.rpId}`,
                `RP_ORIGIN=${passkeyEnv.rpOrigin}`,
                'ENVIRONMENT=production'
            ].join('\n');
            try {
                await navigator.clipboard.writeText(template);
                alert('Copied env template.');
            } catch {
                alert(template);
            }
        }

        function hydrateLastReadinessStamp() {
            const el = document.getElementById('onboarding-last-verified');
            if (!el) return;
            const raw = localStorage.getItem(STORAGE_KEYS.LAST_READINESS);
            if (!raw) return;
            try {
                const parsed = JSON.parse(raw);
                if (parsed?.timestamp && parsed?.status) {
                    el.textContent = `Last verified: ${new Date(parsed.timestamp).toLocaleString()} (${parsed.status})`;
                }
            } catch {
                // no-op
            }
        }

        function storeLastReadiness(statusLabel) {
            const payload = {
                timestamp: Date.now(),
                status: statusLabel
            };
            localStorage.setItem(STORAGE_KEYS.LAST_READINESS, JSON.stringify(payload));
            hydrateLastReadinessStamp();
        }

        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

        async function fetchJsonWithRetry(url, options = {}, config = {}) {
            const retries = typeof config.retries === 'number' ? config.retries : 2;
            const baseDelayMs = typeof config.baseDelayMs === 'number' ? config.baseDelayMs : 1200;
            const onRetry = typeof config.onRetry === 'function' ? config.onRetry : null;
            let lastError = null;

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const res = await fetch(url, options);
                    let data = {};
                    try {
                        data = await res.json();
                    } catch {
                        data = {};
                    }

                    const isTransient = !res.ok && res.status >= 500;
                    if (isTransient && attempt < retries) {
                        if (onRetry) onRetry(attempt + 1, retries + 1, 'server');
                        await sleep(baseDelayMs * (attempt + 1));
                        continue;
                    }

                    return { res, data };
                } catch (err) {
                    lastError = err;
                    if (attempt < retries) {
                        if (onRetry) onRetry(attempt + 1, retries + 1, 'network');
                        await sleep(baseDelayMs * (attempt + 1));
                        continue;
                    }
                }
            }

            throw lastError || new Error('Request failed');
        }

        function renderCheckItem(label, detail, state, fix = null) {
            const chipClass = state === 'pass'
                ? 'check-pass'
                : state === 'fail'
                    ? 'check-fail'
                    : state === 'warn'
                        ? 'check-warn'
                        : 'check-pending';

            const chipLabel = state === 'pass'
                ? 'Ready'
                : state === 'fail'
                    ? 'Required'
                    : state === 'warn'
                        ? 'Action'
                        : 'Checking';

            const fixHtml = fix && state !== 'pass'
                ? `<div style="margin-top:0.35rem;"><a href="${escapeHtml(fix.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(fix.label)}</a></div>`
                : '';

            return `
                <div class="onboarding-item">
                    <div>
                        <strong>${escapeHtml(label)}</strong>
                        <small>${escapeHtml(detail)}</small>
                        ${fixHtml}
                    </div>
                    <span class="check-chip ${chipClass}">${chipLabel}</span>
                </div>
            `;
        }

        function renderOnboarding(status) {
            const summaryEl = document.getElementById('onboarding-summary');
            const checksEl = document.getElementById('onboarding-checks');
            const nextEl = document.getElementById('onboarding-next');
            const stepsEl = document.getElementById('onboarding-steps');

            const checks = status.healthData?.checks || {};
            const setupRequired = !!status.setupData?.setupRequired;
            const setupTokenConfigured = !!status.setupData?.setupTokenConfigured;

            const rows = [
                renderCheckItem(
                    'KV Binding',
                    checks.kv_database ? 'KV binding is available to Functions.' : 'Add LOON_DB (preferred) or KV binding in Cloudflare Pages.',
                    checks.kv_database ? 'pass' : 'fail',
                    { label: 'Open Cloudflare Dashboard', url: 'https://dash.cloudflare.com/' }
                ),
                renderCheckItem(
                    'GitHub Repository',
                    checks.github_repo ? 'GITHUB_REPO is configured.' : 'Set GITHUB_REPO as owner/repo in Cloudflare Pages env vars.',
                    checks.github_repo ? 'pass' : 'fail',
                    { label: 'Open Cloudflare Env Vars', url: 'https://dash.cloudflare.com/' }
                ),
                renderCheckItem(
                    'GitHub Token',
                    checks.github_token ? 'GITHUB_TOKEN is configured.' : 'Set GITHUB_TOKEN Secret with Contents read/write permission.',
                    checks.github_token ? 'pass' : 'fail',
                    { label: 'Create GitHub Token', url: 'https://github.com/settings/personal-access-tokens/new' }
                ),
                renderCheckItem(
                    'Setup Token',
                    setupTokenConfigured ? 'SETUP_TOKEN is configured for first admin setup.' : 'Add SETUP_TOKEN as a Secret in Cloudflare Pages.',
                    setupTokenConfigured ? 'pass' : 'warn',
                    { label: 'Open Cloudflare Env Vars', url: 'https://dash.cloudflare.com/' }
                ),
                renderCheckItem(
                    'Passkeys (RP_ID / RP_ORIGIN)',
                    checks.passkeys_ready
                        ? `Passkeys are configured (${checks.passkeys_rp_id ? 'RP_ID' : ''}${checks.passkeys_rp_id && checks.passkeys_rp_origin ? ', ' : ''}${checks.passkeys_rp_origin ? 'RP_ORIGIN' : ''}).`
                        : 'Set RP_ID and RP_ORIGIN in Cloudflare env vars to enable passkeys in production.',
                    checks.passkeys_ready ? 'pass' : 'warn',
                    { label: 'Open Cloudflare Env Vars', url: 'https://dash.cloudflare.com/' }
                )
            ];
            checksEl.innerHTML = rows.join('');

            const allCoreReady = !!(checks.kv_database && checks.github_repo && checks.github_token);
            if (allCoreReady && (!setupRequired || setupTokenConfigured)) {
                summaryEl.className = 'status-message status-success';
                summaryEl.textContent = setupRequired
                    ? 'System is ready. Complete first admin setup below.'
                    : 'System is ready. You can log in normally.';
                nextEl.classList.add('hidden');
            } else {
                summaryEl.className = 'status-message status-info';
                summaryEl.textContent = 'Some required settings still need attention before setup/login succeeds.';
                nextEl.className = 'status-message status-info';
                nextEl.textContent = 'Make updates in Cloudflare Pages Settings, then click "Refresh Checks".';
                nextEl.classList.remove('hidden');
            }

            const steps = [];
            steps.push(`<li>${allCoreReady ? 'Step 1 complete: core Cloudflare + GitHub config is ready.' : 'Step 1: In Cloudflare Pages, configure KV binding and required env vars.'}</li>`);
            if (setupRequired) {
                steps.push(`<li>${setupTokenConfigured ? 'Step 2: Create first admin in the Initial Setup form on this page.' : 'Step 2: Add SETUP_TOKEN Secret in Cloudflare, redeploy, then return here.'}</li>`);
                steps.push('<li>Step 3: Log in as admin, save a test page, then rotate/remove SETUP_TOKEN.</li>');
                steps.push(`<li>${checks.passkeys_ready ? 'Step 4 complete: passkeys are ready for registration in Account tab.' : `Step 4 (recommended): set RP_ID=${escapeHtml(getPasskeyEnvSuggestion().rpId)} and RP_ORIGIN=${escapeHtml(getPasskeyEnvSuggestion().rpOrigin)} in Cloudflare, redeploy, then register a passkey in Account tab.`}</li>`);
            } else {
                steps.push('<li>Step 2 complete: initial admin already exists.</li>');
                steps.push('<li>Step 3: Log in and continue normal operations from LOON admin.</li>');
                steps.push(`<li>${checks.passkeys_ready ? 'Step 4 complete: passkeys are ready for registration in Account tab.' : `Step 4 (recommended): set RP_ID=${escapeHtml(getPasskeyEnvSuggestion().rpId)} and RP_ORIGIN=${escapeHtml(getPasskeyEnvSuggestion().rpOrigin)} in Cloudflare, redeploy, then register a passkey in Account tab.`}</li>`);
            }
            stepsEl.innerHTML = steps.join('');
        }

        async function refreshOnboardingStatus() {
            const result = {
                healthOk: false,
                setupOk: false,
                healthData: null,
                setupData: null
            };

            try {
                const [healthPack, setupPack] = await Promise.all([
                    fetchJsonWithRetry('/api/health', { cache: 'no-store' }, { retries: 1, baseDelayMs: 900 }),
                    fetchJsonWithRetry('/api/setup', { cache: 'no-store' }, { retries: 1, baseDelayMs: 900 })
                ]);

                result.healthOk = healthPack.res.ok;
                result.setupOk = setupPack.res.ok;
                result.healthData = healthPack.data;
                result.setupData = setupPack.data;
            } catch (err) {
                const summaryEl = document.getElementById('onboarding-summary');
                summaryEl.className = 'status-message status-error';
                summaryEl.textContent = 'Unable to reach setup/health endpoints. Verify the deployment URL and redeploy if needed.';
                storeLastReadiness('failed');
                return result;
            }

            renderOnboarding(result);
            const overall = result.healthData?.status === 'ok' ? 'healthy' : 'degraded';
            storeLastReadiness(overall);
            return result;
        }

        async function runFullReadinessCheck() {
            const resultEl = document.getElementById('full-readiness-result');
            resultEl.className = 'status-message status-info';
            resultEl.textContent = 'Running full readiness check...';
            resultEl.classList.remove('hidden');

            const lines = [];
            const base = await refreshOnboardingStatus();
            const checks = base.healthData?.checks || {};
            lines.push(`${checks.kv_database ? 'PASS' : 'FAIL'} KV binding`);
            lines.push(`${checks.github_repo ? 'PASS' : 'FAIL'} GITHUB_REPO configured`);
            lines.push(`${checks.github_token ? 'PASS' : 'FAIL'} GITHUB_TOKEN configured`);
            lines.push(`${base.setupData?.setupTokenConfigured ? 'PASS' : 'WARN'} SETUP_TOKEN configured`);
            lines.push(`${checks.passkeys_ready ? 'PASS' : 'WARN'} Passkeys RP_ID/RP_ORIGIN configured`);
            lines.push(`${base.setupData?.setupRequired ? 'ACTION' : 'PASS'} Initial setup ${base.setupData?.setupRequired ? 'required' : 'already complete'}`);

            if (SESSION?.token) {
                try {
                    const authPack = await fetchJsonWithRetry('/api/auth', {
                        headers: { Authorization: `Bearer ${SESSION.token}` },
                        cache: 'no-store'
                    }, { retries: 1, baseDelayMs: 800 });
                    lines.push(`${authPack.res.ok ? 'PASS' : 'FAIL'} Session validation`);
                } catch {
                    lines.push('FAIL Session validation');
                }

                try {
                    const pagesPack = await fetchJsonWithRetry('/api/pages?minimal=true&limit=1', {
                        headers: { Authorization: `Bearer ${SESSION.token}` },
                        cache: 'no-store'
                    }, { retries: 1, baseDelayMs: 800 });
                    lines.push(`${pagesPack.res.ok ? 'PASS' : 'FAIL'} GitHub content read path`);
                } catch {
                    lines.push('FAIL GitHub content read path');
                }
            } else {
                lines.push('INFO Log in as admin to include session/content-path checks.');
            }

            const failures = lines.filter(line => line.startsWith('FAIL')).length;
            if (failures > 0) {
                resultEl.className = 'status-message status-error';
            } else {
                resultEl.className = 'status-message status-success';
            }
            resultEl.textContent = lines.join('\n');
        }

        function openCloudflareSetupHelp() {
            const message = [
                'Cloudflare Pages setup path:',
                '1) Project -> Settings -> Functions -> KV namespace bindings',
                '2) Project -> Settings -> Environment variables (Production)',
                '3) Deployments -> Retry deployment'
            ].join('\n');
            alert(message);
        }

        async function completeInitialSetup() {
            const setupToken = document.getElementById('setup-token').value;
            const username = document.getElementById('setup-username').value.trim();
            const password = document.getElementById('setup-password').value;
            const confirmPassword = document.getElementById('setup-password-confirm').value;

            if (!setupToken || !username || !password || !confirmPassword) {
                showError('setup-error', 'All setup fields are required');
                return;
            }

            if (password.length < 8) {
                showError('setup-error', 'Password must be at least 8 characters');
                return;
            }

            if (password !== confirmPassword) {
                showError('setup-error', 'Passwords do not match');
                return;
            }

            hideError('setup-error');

            try {
                const { res, data } = await fetchJsonWithRetry('/api/setup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ setupToken, username, password })
                }, {
                    retries: 2,
                    baseDelayMs: 1200,
                    onRetry: (attempt, total, kind) => {
                        showStatus('setup-error', `Temporary ${kind} issue during setup. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });
                if (!res.ok) {
                    throw new Error(data.error || 'Initial setup failed');
                }

                SESSION = {
                    token: data.token,
                    username: data.username,
                    role: data.role,
                    expiresAt: Date.now() + (data.expiresIn * 1000)
                };

                sessionStorage.setItem(STORAGE_KEYS.POST_SETUP_NOTICE, '1');
                sessionStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                showApp();
            } catch (e) {
                showError('setup-error', mapSetupError(e.message));
            }
        }
        
        /**
         * Verify saved session is still valid server-side
         */
        async function verifySession() {
            if (!SESSION || !SESSION.token) return;
            
            try {
                // Use a lightweight check - try to list users (will fail for non-admins, but that's ok)
                // If we get 401, session is invalid
                const res = await fetch('/api/health');
                // Health check doesn't validate session, so we'll verify on first actual request
                // This is handled by handleSessionError
            } catch (e) {
                // Network error, don't logout - might be offline
                console.log('Session verification skipped (network error)');
            }
        }
        
        /**
         * Handle session errors (401) - logout and redirect to login
         */
        function handleSessionError(error) {
            if (error.message.includes('session') || error.message.includes('expired') || error.message.includes('401')) {
                alert('Your session has expired. Please log in again.');
                logout();
                return true;
            }
            return false;
        }
        
        async function login() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const remember = document.getElementById('remember-me').checked;

            if (!username || !password) {
                showError('login-error', 'Username and password required');
                return;
            }

            hideError('login-error');

            try {
                const { res, data } = await fetchJsonWithRetry('/api/auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                }, {
                    retries: 2,
                    baseDelayMs: 1200,
                    onRetry: (attempt, total, kind) => {
                        showStatus('login-error', `Temporary ${kind} issue during login. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });

                if (!res.ok) {
                    throw new Error(data.error || 'Login failed');
                }

                SESSION = {
                    token: data.token,
                    username: data.username,
                    role: data.role,
                    expiresAt: Date.now() + (data.expiresIn * 1000)
                };

                if (remember) {
                    localStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                } else {
                    sessionStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                }

                showApp();

            } catch (e) {
                showError('login-error', mapLoginError(e.message));
            }
        }

        async function logout() {
            if (SESSION && SESSION.token) {
                try {
                    await fetch('/api/auth', {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${SESSION.token}` }
                    });
                } catch (e) {
                    // Ignore logout errors
                }
            }

            SESSION = null;
            CURRENT_SCHEMA = null;
            CURRENT_CONTENT = null;
            CURRENT_PAGE_ID = null;
            PENDING_CHANGES = [];
            markEditorDirty(false);
            if (AUTO_STAGE_TIMER) {
                clearTimeout(AUTO_STAGE_TIMER);
                AUTO_STAGE_TIMER = null;
            }
            if (AUTOSAVE_TIMER) {
                clearTimeout(AUTOSAVE_TIMER);
                AUTOSAVE_TIMER = null;
            }
            LAST_FOCUSED_FIELD_ID = null;

            localStorage.removeItem(STORAGE_KEYS.SESSION);
            localStorage.removeItem(STORAGE_KEYS.PENDING_CHANGES);
            sessionStorage.removeItem(STORAGE_KEYS.SESSION);

            location.reload();
        }

        function showApp() {
            stopOnboardingMonitor();
            document.getElementById('onboarding-guide').classList.add('hidden');
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('app-section').classList.remove('hidden');

            document.getElementById('display-username').textContent = SESSION.username;
            
            const roleBadge = document.getElementById('display-role');
            roleBadge.textContent = SESSION.role;
            roleBadge.className = `role-badge role-${SESSION.role}`;

            // Show admin tabs if admin
            if (SESSION.role === 'admin') {
                document.getElementById('tab-users').classList.remove('hidden');
                document.getElementById('tab-sessions').classList.remove('hidden');
                document.getElementById('tab-audit').classList.remove('hidden');
            }

            if (sessionStorage.getItem(STORAGE_KEYS.POST_SETUP_NOTICE) === '1') {
                document.getElementById('post-setup-banner').classList.remove('hidden');
            }

            updateBatchUi();
            maybeShowFirstPageWizard();
        }

        // =================================================================
        // TAB NAVIGATION
        // =================================================================
        function switchTab(tab) {
            // Hide all views
            document.querySelectorAll('[id^="view-"]').forEach(el => el.classList.add('hidden'));
            
            // Deactivate all tabs
            document.querySelectorAll('.tab-nav button').forEach(btn => btn.classList.remove('active'));
            
            // Show selected view and activate tab
            document.getElementById(`view-${tab}`).classList.remove('hidden');
            document.getElementById(`tab-${tab}`).classList.add('active');

            // Load data for tab
            if (tab === 'users') {
                loadUsers();
            } else if (tab === 'sessions') {
                loadSessions();
            } else if (tab === 'account') {
                loadAccountInfo();
            }
        }

        // =================================================================
        // ACCOUNT MANAGEMENT
        // =================================================================
        async function changePassword() {
            const currentPassword = document.getElementById('current-password').value;
            const newPassword = document.getElementById('new-password-self').value;
            const confirmPassword = document.getElementById('confirm-password').value;

            // Validation
            if (!currentPassword || !newPassword || !confirmPassword) {
                showStatus('password-change-status', 'All fields are required', 'error');
                return;
            }

            if (newPassword.length < 8) {
                showStatus('password-change-status', 'New password must be at least 8 characters', 'error');
                return;
            }

            if (newPassword !== confirmPassword) {
                showStatus('password-change-status', 'New passwords do not match', 'error');
                return;
            }

            showStatus('password-change-status', 'Changing password...', 'info');

            try {
                const res = await fetch('/api/auth', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        currentPassword: currentPassword,
                        newPassword: newPassword
                    })
                });

                const data = await res.json();

                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error(data.error || 'Unauthorized'))) {
                        return;
                    }
                    throw new Error(data.error || 'Password change failed');
                }

                // Clear form
                document.getElementById('current-password').value = '';
                document.getElementById('new-password-self').value = '';
                document.getElementById('confirm-password').value = '';

                showStatus('password-change-status', 'Password changed successfully', 'success');

            } catch (e) {
                showStatus('password-change-status', e.message, 'error');
            }
        }

        // =================================================================
        // PASSKEY MANAGEMENT
        // =================================================================
        
        /**
         * Check if browser supports WebAuthn
         */
        function checkPasskeySupport() {
            const supported = window.PublicKeyCredential !== undefined && 
                             navigator.credentials !== undefined;
            
            if (!supported) {
                document.getElementById('passkey-browser-check').classList.remove('hidden');
            }
            
            return supported;
        }
        
        /**
         * Load account info and passkeys
         */
        async function loadAccountInfo() {
            if (SESSION) {
                document.getElementById('account-username').textContent = SESSION.username;
                document.getElementById('account-role').textContent = SESSION.role;
                
                // Check passkey support
                checkPasskeySupport();

                const passkeyConfig = await checkPasskeyServerConfig();
                showPasskeyOptionalStatus(passkeyConfig);
                
                // Load passkeys
                await loadPasskeys();
            }
        }
        
        /**
         * Load user's passkeys
         */
        async function loadPasskeys() {
            if (!checkPasskeySupport()) return;
            
            try {
                const res = await fetch('/api/passkeys', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to load passkeys');
                }
                
                const data = await res.json();
                displayPasskeys(data.passkeys || []);
                
            } catch (e) {
                console.error('Failed to load passkeys:', e);
            }
        }
        
        /**
         * Display passkeys list
         */
        function displayPasskeys(passkeys) {
            const container = document.getElementById('passkeys-list-container');
            
            if (passkeys.length === 0) {
                container.innerHTML = '<p style="color: var(--muted-color); font-style: italic;">No passkeys registered</p>';
                return;
            }
            
            container.innerHTML = passkeys.map(pk => `
                <div style="padding: 1rem; background: var(--code-background-color); border-radius: 8px; margin-bottom: 0.5rem; display: flex; justify-content: between; align-items: center;">
                    <div style="flex: 1;">
                        <strong>${escapeHtml(pk.name || 'Unnamed Passkey')}</strong><br>
                        <small style="color: var(--muted-color);">
                            Created: ${new Date(pk.created).toLocaleDateString()} | 
                            Last used: ${pk.lastUsed ? new Date(pk.lastUsed).toLocaleDateString() : 'Never'}
                        </small>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="renamePasskey('${pk.id}')" class="outline" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Rename</button>
                        <button onclick="deletePasskey('${pk.id}')" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Delete</button>
                    </div>
                </div>
            `).join('');
        }
        
        /**
         * Login with passkey
         */
        async function loginWithPasskey() {
            if (!checkPasskeySupport()) {
                showError('login-error', 'Passkeys not supported in this browser');
                return;
            }

            const passkeyConfig = await checkPasskeyServerConfig();
            if (passkeyConfig?.ready === false) {
                const passkeyEnv = getPasskeyEnvSuggestion();
                showError('login-error', `Passkeys are not configured for this deployment yet. Set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare, then redeploy.`);
                return;
            }
            
            hideError('login-error');
            
            try {
                // Step 1: Get authentication challenge
                const challengePack = await fetchJsonWithRetry('/api/passkeys/auth/challenge', {
                    cache: 'no-store'
                }, {
                    retries: 2,
                    baseDelayMs: 1000,
                    onRetry: (attempt, total, kind) => {
                        showStatus('login-error', `Temporary ${kind} issue during passkey challenge. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });

                if (!challengePack.res.ok) {
                    throw new Error('Failed to get authentication challenge');
                }

                const challengeData = challengePack.data;
                const allowCredentials = (challengeData.allowCredentials || []).map(cred => ({
                    id: base64urlToBuffer(cred.id),
                    type: 'public-key',
                    transports: cred.transports
                }));
                
                // Step 2: Get assertion from authenticator
                const credential = await navigator.credentials.get({
                    publicKey: {
                        challenge: base64urlToBuffer(challengeData.challenge),
                        timeout: challengeData.timeout || 60000,
                        rpId: challengeData.rpId || window.location.hostname,
                        userVerification: challengeData.userVerification || 'preferred',
                        ...(allowCredentials.length > 0 ? { allowCredentials } : {})
                    }
                });
                
                if (!credential) {
                    throw new Error('No credential returned');
                }
                
                // Step 3: Verify assertion
                const verifyPack = await fetchJsonWithRetry('/api/passkeys/auth/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        assertionResponse: {
                            id: bufferToBase64url(credential.rawId),
                            response: {
                                authenticatorData: bufferToBase64url(credential.response.authenticatorData),
                                clientDataJSON: bufferToBase64url(credential.response.clientDataJSON),
                                signature: bufferToBase64url(credential.response.signature),
                                userHandle: credential.response.userHandle ? 
                                    bufferToBase64url(credential.response.userHandle) : undefined
                            }
                        },
                        challengeToken: challengeData.challengeToken
                    })
                }, {
                    retries: 2,
                    baseDelayMs: 1000,
                    onRetry: (attempt, total, kind) => {
                        showStatus('login-error', `Temporary ${kind} issue during passkey verification. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });

                const verifyData = verifyPack.data;

                if (!verifyPack.res.ok) {
                    throw new Error(verifyData.error || 'Authentication failed');
                }
                
                // Step 4: Save session
                SESSION = {
                    token: verifyData.token,
                    username: verifyData.username,
                    role: verifyData.role,
                    expiresAt: Date.now() + (verifyData.expiresIn * 1000)
                };
                
                const remember = document.getElementById('remember-me').checked;
                if (remember) {
                    localStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                } else {
                    sessionStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                }
                
                showApp();
                
            } catch (e) {
                console.error('Passkey login failed:', e);
                showError('login-error', mapLoginError(e.message || 'Passkey login failed'));
            }
        }
        
        /**
         * Register new passkey
         */
        async function registerPasskey() {
            if (!checkPasskeySupport()) {
                showStatus('passkey-status', 'Passkeys not supported in this browser', 'error');
                return;
            }

            const passkeyConfig = await checkPasskeyServerConfig();
            if (passkeyConfig?.ready === false) {
                const passkeyEnv = getPasskeyEnvSuggestion();
                showStatus('passkey-status', `Passkeys are optional and not configured yet. Set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare, then redeploy to enable registration.`, 'error');
                return;
            }
            
            showStatus('passkey-status', 'Starting passkey registration...', 'info');
            
            try {
                // Step 1: Get registration challenge
                const challengeRes = await fetch('/api/passkeys/register/challenge', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                if (!challengeRes.ok) {
                    if (challengeRes.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to get registration challenge');
                }
                
                const challengeData = await challengeRes.json();
                
                // Step 2: Create credential
                showStatus('passkey-status', 'Please follow your device\'s instructions...', 'info');
                
                const credential = await navigator.credentials.create({
                    publicKey: {
                        challenge: base64urlToBuffer(challengeData.challenge),
                        rp: {
                            name: challengeData.rpName || 'LOON CMS',
                            id: challengeData.rpId || window.location.hostname
                        },
                        user: {
                            id: base64urlToBuffer(challengeData.userId),
                            name: challengeData.username,
                            displayName: challengeData.username
                        },
                        pubKeyCredParams: challengeData.pubKeyCredParams || [
                            { alg: -7, type: 'public-key' }  // ES256
                        ],
                        timeout: challengeData.timeout || 60000,
                        attestation: challengeData.attestation || 'direct',
                        authenticatorSelection: challengeData.authenticatorSelection || {
                            authenticatorAttachment: 'platform',
                            userVerification: 'preferred',
                            residentKey: 'discouraged'
                        }
                    }
                });
                
                if (!credential) {
                    throw new Error('No credential created');
                }
                
                // Step 3: Verify registration
                showStatus('passkey-status', 'Verifying passkey...', 'info');
                
                const verifyRes = await fetch('/api/passkeys/register/verify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        attestationResponse: {
                            id: bufferToBase64url(credential.rawId),
                            response: {
                                attestationObject: bufferToBase64url(credential.response.attestationObject),
                                clientDataJSON: bufferToBase64url(credential.response.clientDataJSON)
                            },
                            transports: credential.response.getTransports ? 
                                credential.response.getTransports() : ['internal']
                        },
                        challengeToken: challengeData.challengeToken
                    })
                });
                
                const verifyData = await verifyRes.json();
                
                if (!verifyRes.ok) {
                    if (verifyRes.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error(verifyData.error || 'Registration verification failed');
                }
                
                // Step 4: Show recovery codes
                if (verifyData.recoveryCodes && verifyData.recoveryCodes.length > 0) {
                    showRecoveryCodes(verifyData.recoveryCodes);
                }
                
                showStatus('passkey-status', 'Passkey registered successfully!', 'success');
                
                // Reload passkeys list
                await loadPasskeys();
                
            } catch (e) {
                console.error('Passkey registration failed:', e);
                showStatus('passkey-status', e.message || 'Passkey registration failed', 'error');
            }
        }
        
        /**
         * Rename passkey
         */
        async function renamePasskey(credentialId) {
            const newName = prompt('Enter new name for this passkey:');
            
            if (!newName || !newName.trim()) {
                return;
            }
            
            try {
                const res = await fetch(`/api/passkeys/${credentialId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ name: newName.trim() })
                });
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to rename passkey');
                }
                
                showStatus('passkey-status', 'Passkey renamed successfully', 'success');
                await loadPasskeys();
                
            } catch (e) {
                console.error('Failed to rename passkey:', e);
                showStatus('passkey-status', e.message, 'error');
            }
        }
        
        /**
         * Delete passkey
         */
        async function deletePasskey(credentialId) {
            if (!confirm('Are you sure you want to delete this passkey?')) {
                return;
            }
            
            try {
                const res = await fetch(`/api/passkeys/${credentialId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to delete passkey');
                }
                
                showStatus('passkey-status', 'Passkey deleted successfully', 'success');
                await loadPasskeys();
                
            } catch (e) {
                console.error('Failed to delete passkey:', e);
                showStatus('passkey-status', e.message, 'error');
            }
        }
        
        /**
         * Show recovery codes modal
         */
        function showRecoveryCodes(codes) {
            const display = document.getElementById('recovery-codes-display');
            display.innerHTML = codes.map((code, i) => 
                `${i + 1}. <strong>${code}</strong>`
            ).join('<br>');
            
            document.getElementById('recovery-codes-modal').classList.remove('hidden');
            
            // Store codes temporarily for download/copy
            window.tempRecoveryCodes = codes;
        }
        
        /**
         * Close recovery codes modal
         */
        function closeRecoveryCodesModal() {
            document.getElementById('recovery-codes-modal').classList.add('hidden');
            window.tempRecoveryCodes = null;
        }
        
        /**
         * Download recovery codes
         */
        function downloadRecoveryCodes() {
            if (!window.tempRecoveryCodes) return;
            
            const content = window.tempRecoveryCodes.map((code, i) => 
                `${i + 1}. ${code}`
            ).join('\n');
            
            const blob = new Blob([
                `LOON Recovery Codes\n`,
                `Username: ${SESSION.username}\n`,
                `Generated: ${new Date().toISOString()}\n\n`,
                `Save these codes securely. Each can only be used once.\n\n`,
                content
            ], { type: 'text/plain' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `loon-recovery-codes-${SESSION.username}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        /**
         * Copy recovery codes to clipboard
         */
        async function copyRecoveryCodes() {
            if (!window.tempRecoveryCodes) return;
            
            const content = window.tempRecoveryCodes.map((code, i) => 
                `${i + 1}. ${code}`
            ).join('\n');
            
            try {
                await navigator.clipboard.writeText(content);
                alert('Recovery codes copied to clipboard');
            } catch (e) {
                console.error('Failed to copy:', e);
                alert('Failed to copy to clipboard');
            }
        }
        
        /**
         * Base64url to ArrayBuffer
         */
        function base64urlToBuffer(base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const padLen = (4 - (base64.length % 4)) % 4;
            const padded = base64 + '='.repeat(padLen);
            const binary = atob(padded);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        /**
         * ArrayBuffer to base64url
         */
        function bufferToBase64url(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        // =================================================================
        // CONTENT EDITOR
        // =================================================================
        async function loadEditor() {
            const pageId = document.getElementById('pageId').value.trim().toLowerCase();
            
            if (!pageId) {
                showStatus('editor-status', 'Please enter a Page ID', 'error');
                return;
            }

            // Save last used page
            localStorage.setItem(STORAGE_KEYS.LAST_PAGE, pageId);
            CURRENT_PAGE_ID = pageId;

            showStatus('editor-status', 'Loading...', 'info');
            document.getElementById('editor-container').classList.add('hidden');

            try {
                // Fetch schema
                const schemaRes = await fetch(`/data/${pageId}/schema.json`);
                if (!schemaRes.ok) {
                    throw new Error(`Page "${pageId}" not found. Check the Page ID or create the schema.`);
                }
                CURRENT_SCHEMA = await schemaRes.json();

                // Fetch content
                const contentRes = await fetch(`/data/${pageId}/content.json`);
                CURRENT_CONTENT = contentRes.ok ? await contentRes.json() : {};

                // If batch mode has staged content for this page, prefer staged state
                const queued = getQueuedChangeForPage(pageId);
                if (queued && queued.content) {
                    CURRENT_CONTENT = { ...queued.content };
                }

                // Build form
                buildForm();
                markEditorDirty(false);
                maybeRestoreAutosave(pageId);
                refreshLinkPageList();
                loadRevisionHistory();
                hydrateWorkflowPanelFromContent();
                loadWatchActivity();
                loadReusableBlocks();

                // Show editor
                document.getElementById('editor-container').classList.remove('hidden');
                document.getElementById('editor-title').textContent = CURRENT_SCHEMA.title || `Editing: ${pageId}`;
                
                // Show metadata if exists
                if (CURRENT_CONTENT._meta) {
                    const meta = CURRENT_CONTENT._meta;
                    let metaHtml = '';
                    if (meta.createdBy) metaHtml += `Created by: ${escapeHtml(meta.createdBy)}`;
                    if (meta.created) metaHtml += ` on ${new Date(meta.created).toLocaleDateString()}`;
                    if (meta.modifiedBy) metaHtml += ` | Last modified by: ${escapeHtml(meta.modifiedBy)}`;
                    if (meta.lastModified) metaHtml += ` on ${new Date(meta.lastModified).toLocaleString()}`;
                    
                    const metaEl = document.getElementById('content-meta');
                    metaEl.innerHTML = metaHtml;
                    metaEl.classList.remove('hidden');
                }
                
                // Show delete button for admin/editor only
                const deleteBtn = document.getElementById('delete-btn');
                if (SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor')) {
                    deleteBtn.style.display = 'inline-block';
                } else {
                    deleteBtn.style.display = 'none';
                }

                // Show draft/publish buttons based on role
                const saveBtn = document.getElementById('save-btn');
                const draftBtn = document.getElementById('draft-btn');
                const publishBtn = document.getElementById('publish-btn');

                if (SESSION && SESSION.role === 'contributor') {
                    // Contributors can only save drafts
                    saveBtn.style.display = 'none';
                    draftBtn.style.display = 'inline-block';
                } else {
                    saveBtn.style.display = 'inline-block';
                    draftBtn.style.display = 'inline-block';
                }

                if (SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor')) {
                    // Only admins and editors can publish
                    publishBtn.style.display = 'inline-block';
                } else {
                    publishBtn.style.display = 'none';
                }

                // Show content status if available
                if (CURRENT_CONTENT._meta && CURRENT_CONTENT._meta.status) {
                    updateContentStatus(CURRENT_CONTENT._meta.status, CURRENT_CONTENT._meta.modifiedBy);
                } else {
                    document.getElementById('content-status').style.display = 'none';
                }

                if (queued) {
                    document.getElementById('last-saved').textContent = `Loaded staged ${getStagedLabel(queued.saveAs)} change from this browser session`;
                    showStatus('editor-status', `Loaded staged change for "${pageId}". Push all changes when ready.`, 'info');
                    markEditorDirty(false);
                } else {
                    document.getElementById('last-saved').textContent = '';
                }
                updateBatchUi();
                if (!queued) hideStatus('editor-status');
                updateAutosaveIndicator();

            } catch (e) {
                showStatus('editor-status', e.message, 'error');
                document.getElementById('editor-container').classList.add('hidden');
            }
        }

        /**
         * Load and display available pages
         */
        async function loadPageList() {
            const browser = document.getElementById('page-browser');
            const list = document.getElementById('page-list');
            const filter = document.getElementById('page-browser-filter');
            
            browser.classList.remove('hidden');
            list.innerHTML = '<p>Loading pages...</p>';
            if (filter) filter.value = '';
            
            try {
                const headers = { };
                if (SESSION && SESSION.token) {
                    headers['Authorization'] = `Bearer ${SESSION.token}`;
                }
                
                const res = await fetch('/api/pages', { headers });
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to load pages');
                }
                
                if (data.pages.length === 0) {
                    list.innerHTML = '<p style="color: var(--muted-color);">No pages found. Create a page by adding a folder to /data/ with schema.json</p>';
                    PAGE_BROWSER_ITEMS = [];
                    return;
                }

                PAGE_BROWSER_ITEMS = [...data.pages].sort((a, b) => {
                    const left = String(a.title || a.pageId || '').toLowerCase();
                    const right = String(b.title || b.pageId || '').toLowerCase();
                    return left.localeCompare(right);
                });
                PAGE_BROWSER_CAN_EDIT_ALL = !!data.canEditAll;
                renderPageBrowserList(PAGE_BROWSER_ITEMS);

                const pageVerb = PAGE_BROWSER_CAN_EDIT_ALL ? 'edit' : 'view';
                showStatus('page-browser-status', `Showing ${PAGE_BROWSER_ITEMS.length} page(s) you can ${pageVerb}`, 'info');
                
            } catch (e) {
                list.innerHTML = `<p style="color: var(--error);">${escapeHtml(e.message)}</p>`;
            }
        }

        function renderPageBrowserList(items) {
            const list = document.getElementById('page-list');
            if (!list) return;
            if (!items.length) {
                list.innerHTML = '<p style="color: var(--muted-color);">No pages match your filter.</p>';
                return;
            }

            const actionLabel = PAGE_BROWSER_CAN_EDIT_ALL ? 'Edit' : 'Open';
            list.innerHTML = items.map(page => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: var(--muted-border-color); border-radius: 4px;">
                    <div>
                        <strong>${escapeHtml(page.title)}</strong>
                        <span style="color: var(--muted-color); font-size: 0.85rem; margin-left: 0.5rem;">${escapeHtml(page.pageId)}</span>
                        ${page.createdBy ? `<br><small style="color: var(--muted-color);">By ${escapeHtml(page.createdBy)}</small>` : ''}
                    </div>
                    <button onclick="selectPage('${escapeHtml(page.pageId)}')" class="outline" style="padding: 0.25rem 0.75rem;">${actionLabel}</button>
                </div>
            `).join('');
        }

        function filterPageBrowserList() {
            const filter = document.getElementById('page-browser-filter');
            const query = String(filter?.value || '').trim().toLowerCase();
            if (!query) {
                renderPageBrowserList(PAGE_BROWSER_ITEMS);
                return;
            }

            const filtered = PAGE_BROWSER_ITEMS.filter(page => {
                const title = String(page.title || '').toLowerCase();
                const id = String(page.pageId || '').toLowerCase();
                return title.includes(query) || id.includes(query);
            });
            renderPageBrowserList(filtered);
        }
        
        function selectPage(pageId) {
            document.getElementById('pageId').value = pageId;
            document.getElementById('page-browser').classList.add('hidden');
            loadEditor();
        }
        
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // =================================================================
        // NEW PAGE CREATION
        // =================================================================
        function showNewPageDialog() {
            document.getElementById('new-page-dialog').classList.remove('hidden');
            document.getElementById('page-browser').classList.add('hidden');
            document.getElementById('new-page-id').focus();
        }
        
        function cancelNewPage() {
            document.getElementById('new-page-dialog').classList.add('hidden');
            document.getElementById('new-page-id').value = '';
            document.getElementById('new-page-title').value = '';
            document.getElementById('new-page-template').value = '';
            document.getElementById('new-page-status').innerHTML = '';
        }
        
        async function createNewPage() {
            const pageId = document.getElementById('new-page-id').value.trim().toLowerCase();
            const title = document.getElementById('new-page-title').value.trim() || pageId;
            const template = document.getElementById('new-page-template').value.trim() || null;
            const statusDiv = document.getElementById('new-page-status');
            
            // Validation
            if (!pageId) {
                statusDiv.innerHTML = '<p style="color: var(--error);">Page ID is required</p>';
                return;
            }
            
            if (!/^[a-z0-9-]+$/.test(pageId)) {
                statusDiv.innerHTML = '<p style="color: var(--error);">Page ID must contain only lowercase letters, numbers, and hyphens</p>';
                return;
            }
            
            statusDiv.innerHTML = '<p>Creating page...</p>';
            
            try {
                const response = await fetch('/api/pages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: pageId,
                        title: title,
                        template: template
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to create page');
                }
                
                // Success! Load the new page
                statusDiv.innerHTML = '<p style="color: var(--success);">Page created! Loading editor...</p>';
                
                setTimeout(() => {
                    document.getElementById('pageId').value = pageId;
                    cancelNewPage();
                    loadEditor();
                }, 1000);
                
            } catch (e) {
                statusDiv.innerHTML = `<p style="color: var(--error);">Error: ${escapeHtml(e.message)}</p>`;
            }
        }

        // =================================================================
        // SESSIONS MANAGEMENT (Admin only)
        // =================================================================
        async function loadSessions() {
            const list = document.getElementById('session-list');
            list.innerHTML = '<tr><td colspan="5">Loading...</td></tr>';
            
            try {
                const res = await fetch('/api/sessions', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to load sessions');
                }
                
                if (data.sessions.length === 0) {
                    list.innerHTML = '<tr><td colspan="5">No active sessions</td></tr>';
                    return;
                }
                
                list.innerHTML = data.sessions.map(s => `
                    <tr>
                        <td>
                            ${escapeHtml(s.username)}
                            ${s.isCurrent ? ' <small style="color: var(--primary);">(you)</small>' : ''}
                        </td>
                        <td><span class="role-badge role-${s.role}">${s.role}</span></td>
                        <td>${s.created ? new Date(s.created).toLocaleString() : 'Unknown'}</td>
                        <td><code style="font-size: 0.8rem;">${escapeHtml(s.ip)}</code></td>
                        <td class="actions">
                            ${s.isCurrent ? '<span style="color: var(--muted-color);">Current</span>' : 
                              '<span style="color: var(--muted-color);">Use Revoke All</span>'}
                        </td>
                    </tr>
                `).join('');
                
                showStatus('sessions-status', `${data.total} active session(s)`, 'info');
                
            } catch (e) {
                list.innerHTML = `<tr><td colspan="5" style="color: var(--error);">${escapeHtml(e.message)}</td></tr>`;
            }
        }
        
        async function forceLogoutUser() {
            const username = document.getElementById('force-logout-username').value.trim().toLowerCase();
            
            if (!username) {
                showStatus('sessions-status', 'Enter a username', 'error');
                return;
            }
            
            if (username === SESSION.username) {
                showStatus('sessions-status', 'Cannot revoke your own sessions', 'error');
                return;
            }
            
            if (!confirm(`Revoke ALL sessions for user "${username}"? They will be logged out immediately.`)) {
                return;
            }
            
            try {
                const res = await fetch('/api/sessions', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username: username, all: true })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to revoke sessions');
                }
                
                document.getElementById('force-logout-username').value = '';
                showStatus('sessions-status', data.message, 'success');
                loadSessions(); // Refresh list
                
            } catch (e) {
                showStatus('sessions-status', e.message, 'error');
            }
        }

        /**
         * Delete current page content
         */
        async function deleteContent() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }
            
            if (!confirm(`Delete all content for "${CURRENT_PAGE_ID}"?\n\nThis cannot be undone. The page structure will remain but all content will be removed.`)) {
                return;
            }
            
            showStatus('editor-status', 'Deleting...', 'info');
            
            try {
                const res = await fetch('/api/content', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ pageId: CURRENT_PAGE_ID })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error(data.error || 'Unauthorized'))) {
                        return;
                    }
                    throw new Error(data.error || 'Delete failed');
                }
                
                // Clear editor
                CURRENT_CONTENT = {};
                document.getElementById('editor-form').innerHTML = '';
                document.getElementById('editor-container').classList.add('hidden');
                document.getElementById('content-meta').classList.add('hidden');
                clearAutosaveForPage(CURRENT_PAGE_ID);
                markEditorDirty(false);
                
                showStatus('editor-status', `Content deleted. Commit: ${data.commit.substring(0, 7)}`, 'success');
                
                // Refresh page list if visible
                const browser = document.getElementById('page-browser');
                if (!browser.classList.contains('hidden')) {
                    loadPageList();
                }
                
            } catch (e) {
                showStatus('editor-status', e.message, 'error');
            }
        }

        function buildForm() {
            const container = document.getElementById('editor-form');
            container.innerHTML = '';

            if (!CURRENT_SCHEMA || !CURRENT_SCHEMA.fields) {
                container.innerHTML = '<p>Invalid schema: no fields defined</p>';
                return;
            }

            CURRENT_SCHEMA.fields.forEach(field => {
                const wrapper = document.createElement('div');
                wrapper.className = 'form-field';

                // Label
                const label = document.createElement('label');
                label.setAttribute('for', `field_${field.key}`);
                label.textContent = field.label || field.key;
                if (field.required) {
                    label.innerHTML += ' <span style="color: var(--error);">*</span>';
                }
                wrapper.appendChild(label);

                // Input
                let input;
                const value = CURRENT_CONTENT[field.key] ?? field.default ?? '';

                switch (field.type) {
                    case 'textarea':
                        input = document.createElement('textarea');
                        input.value = value;
                        if (field.rows) input.rows = field.rows;
                        break;

                    case 'select':
                        input = document.createElement('select');
                        (field.options || []).forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt;
                            option.textContent = opt;
                            if (opt === value) option.selected = true;
                            input.appendChild(option);
                        });
                        break;

                    case 'checkbox':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = Boolean(value);
                        input.role = 'switch';
                        break;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = value;
                        if (field.min !== undefined) input.min = field.min;
                        if (field.max !== undefined) input.max = field.max;
                        break;

                    case 'image':
                        input = document.createElement('div');
                        input.style.cssText = 'display: flex; gap: 0.5rem; align-items: flex-start; flex-wrap: wrap;';
                        
                        if (value) {
                            const img = document.createElement('img');
                            img.src = value;
                            img.style.cssText = 'max-width: 200px; max-height: 150px; border-radius: 8px; object-fit: cover;';
                            input.appendChild(img);
                        }
                        
                        const uploadBtn = document.createElement('button');
                        uploadBtn.type = 'button';
                        uploadBtn.textContent = value ? 'Change Image' : 'Upload Image';
                        uploadBtn.onclick = () => uploadImageForField(`field_${field.key}`);
                        input.appendChild(uploadBtn);
                        break;

                    default:
                        input = document.createElement('input');
                        input.type = field.type || 'text';
                        input.value = value;
                        if (field.maxlength) input.maxLength = field.maxlength;
                        if (field.pattern) input.pattern = field.pattern;
                        break;
                }

                input.id = `field_${field.key}`;
                input.name = field.key;
                if (field.placeholder) input.placeholder = field.placeholder;
                if (field.required) input.required = true;

                if (field.type !== 'image') {
                    const changeEvent = field.type === 'checkbox' || field.type === 'select' ? 'change' : 'input';
                    input.addEventListener(changeEvent, () => {
                        markEditorDirty(true);
                        scheduleAutoStage();
                        scheduleAutosave();
                    });
                    if (field.type === 'textarea' || field.type === 'text' || field.type === 'url') {
                        input.addEventListener('focus', () => {
                            LAST_FOCUSED_FIELD_ID = input.id;
                        });
                    }
                }

                wrapper.appendChild(input);

                // Description
                if (field.description) {
                    const desc = document.createElement('small');
                    desc.textContent = field.description;
                    wrapper.appendChild(desc);
                }

                container.appendChild(wrapper);
            });
        }

        function collectCurrentFormContent() {
            const content = {};
            CURRENT_SCHEMA.fields.forEach(field => {
                const input = document.getElementById(`field_${field.key}`);
                if (!input) return;

                if (field.type === 'checkbox') {
                    content[field.key] = input.checked;
                } else if (field.type === 'number') {
                    content[field.key] = input.value ? Number(input.value) : null;
                } else if (field.type === 'image') {
                    content[field.key] = CURRENT_CONTENT[field.key] || '';
                } else {
                    content[field.key] = input.value;
                }
            });

            if (CURRENT_CONTENT && CURRENT_CONTENT._meta) {
                content._meta = { ...CURRENT_CONTENT._meta };
            }

            return content;
        }

        async function sendSaveRequest(pageId, content, saveAs = null) {
            const payload = { pageId, content };
            if (saveAs === 'draft') payload.saveAs = 'draft';

            const res = await fetch('/api/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SESSION.token}`
                },
                body: JSON.stringify(payload)
            });

            const data = await res.json();
            if (res.status === 401) throw new Error(data.error || 'Session expired');
            if (!res.ok) throw new Error(data.error || 'Save failed');
            clearAutosaveForPage(pageId);
            return data;
        }

        async function saveContent() {
            if (!CURRENT_SCHEMA || !CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }

            if (BATCH_MODE_ENABLED) {
                stageCurrentContentChange();
                return;
            }
            if (EDITOR_BUSY) return;

            setEditorBusy(true);
            const content = collectCurrentFormContent();
            showStatus('editor-status', 'Saving...', 'info');

            try {
                await sendSaveRequest(CURRENT_PAGE_ID, content);
                CURRENT_CONTENT = content;
                document.getElementById('last-saved').textContent = 'Saved just now';
                markEditorDirty(false);
                showStatus('editor-status', 'Changes saved successfully', 'success');
                setTimeout(() => hideStatus('editor-status'), 3000);
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Save failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        async function saveContentAsDraft() {
            if (!CURRENT_SCHEMA || !CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }

            if (BATCH_MODE_ENABLED) {
                stageCurrentContentChange('draft');
                updateContentStatus('draft');
                return;
            }
            if (EDITOR_BUSY) return;

            setEditorBusy(true);
            const content = collectCurrentFormContent();
            showStatus('editor-status', 'Saving as draft...', 'info');

            try {
                const data = await sendSaveRequest(CURRENT_PAGE_ID, content, 'draft');
                CURRENT_CONTENT = content;
                document.getElementById('last-saved').textContent = 'Saved as draft just now';
                markEditorDirty(false);
                showStatus('editor-status', 'Saved as draft (not yet published)', 'success');
                updateContentStatus('draft', data.modifiedBy);
                setTimeout(() => hideStatus('editor-status'), 3000);
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Draft save failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        async function publishContent() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }

            // Only allow admin and editor roles to publish
            if (SESSION.role !== 'admin' && SESSION.role !== 'editor') {
                showStatus('editor-status', 'Only admins and editors can publish content', 'error');
                return;
            }

            if (hasQueuedChangeForCurrentPage()) {
                showStatus('editor-status', 'Push staged changes for this page before publishing.', 'error');
                return;
            }
            if (EDITOR_BUSY) return;
            setEditorBusy(true);

            showStatus('editor-status', 'Publishing...', 'info');
            
            try {
                const res = await fetch('/api/publish', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: CURRENT_PAGE_ID,
                        action: 'publish'
                    })
                });

                const data = await res.json();

                if (res.status === 401) {
                    throw new Error(data.error || 'Session expired');
                }
                
                if (!res.ok) {
                    throw new Error(data.error || 'Publish failed');
                }

                showStatus('editor-status', 'Content published successfully!', 'success');
                updateContentStatus('published', data.publishedBy);

                setTimeout(() => hideStatus('editor-status'), 3000);

            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Publish failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        function updateContentStatus(status, user) {
            const statusDiv = document.getElementById('content-status');
            const statusText = document.getElementById('status-text');
            
            statusDiv.style.display = 'block';
            if (status === 'draft') {
                statusDiv.style.background = '#fff3cd';
                statusDiv.style.borderLeftColor = '#ffc107';
                statusText.innerHTML = `<span style="color: #856404;">[DRAFT] This is a draft (not yet published)</span>`;
            } else if (status === 'published') {
                statusDiv.style.background = '#d4edda';
                statusDiv.style.borderLeftColor = '#28a745';
                statusText.innerHTML = `<span style="color: #155724;">[PUBLISHED] This content is published and live</span>`;
            }
        }

        function triggerImportFileDialog() {
            if (!CURRENT_SCHEMA || !CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page before importing content.', 'error');
                return;
            }
            const input = document.getElementById('import-file-input');
            input.value = '';
            input.click();
        }

        async function handleImportFileChosen(event) {
            const file = event?.target?.files?.[0];
            if (!file) return;

            try {
                const text = await file.text();
                const imported = parseImportedFile(file.name, text);
                const mapped = mapImportedDataToSchema(imported);
                const keys = Object.keys(mapped);

                if (!keys.length) {
                    showStatus('editor-status', 'Import succeeded, but no matching schema fields were found.', 'info');
                    return;
                }

                CURRENT_CONTENT = {
                    ...(CURRENT_CONTENT || {}),
                    ...mapped
                };
                buildForm();
                markEditorDirty(true);
                showStatus('editor-status', `Imported ${keys.length} field(s) from ${file.name}. Review and save.`, 'success');
                scheduleAutoStage();
            } catch (e) {
                showStatus('editor-status', `Import failed: ${e.message}`, 'error');
            }
        }

        function parseImportedFile(fileName, text) {
            const lower = String(fileName || '').toLowerCase();
            if (lower.endsWith('.json')) {
                const parsed = JSON.parse(text);
                if (parsed && typeof parsed === 'object' && parsed.content && typeof parsed.content === 'object') {
                    return parsed.content;
                }
                if (parsed && typeof parsed === 'object') return parsed;
                throw new Error('JSON import must be an object.');
            }

            if (lower.endsWith('.tid')) {
                return parseTidFile(text);
            }

            if (lower.endsWith('.md') || lower.endsWith('.markdown')) {
                return { content: text, body: text, markdown: text };
            }

            if (lower.endsWith('.html') || lower.endsWith('.htm')) {
                return { content: text, body: text, html: text };
            }

            return { content: text, body: text, text };
        }

        function parseTidFile(text) {
            const lines = text.split(/\r?\n/);
            const headers = {};
            let index = 0;

            while (index < lines.length) {
                const line = lines[index];
                if (!line.trim()) {
                    index += 1;
                    break;
                }

                const separator = line.indexOf(':');
                if (separator > 0) {
                    const key = line.slice(0, separator).trim();
                    const value = line.slice(separator + 1).trim();
                    headers[key] = value;
                }
                index += 1;
            }

            const body = lines.slice(index).join('\n').trim();
            if (body && !headers.text) headers.text = body;

            if (headers.tags) {
                headers.tags = headers.tags
                    .split(/\s+/)
                    .map(tag => tag.trim())
                    .filter(Boolean)
                    .join(', ');
            }

            return headers;
        }

        function mapImportedDataToSchema(imported) {
            const source = imported && typeof imported === 'object' ? imported : {};
            const lowerMap = {};
            Object.entries(source).forEach(([key, value]) => {
                lowerMap[key.toLowerCase()] = value;
            });

            const aliases = {
                title: ['title', 'name', 'headline'],
                body: ['body', 'text', 'content', 'markdown', 'html', 'description'],
                content: ['content', 'body', 'text', 'markdown', 'html', 'description'],
                text: ['text', 'body', 'content', 'markdown', 'description'],
                description: ['description', 'summary', 'body', 'content', 'text'],
                tags: ['tags', 'categories', 'keywords']
            };

            const mapped = {};
            for (const field of (CURRENT_SCHEMA?.fields || [])) {
                const direct = source[field.key];
                const lowerDirect = lowerMap[field.key.toLowerCase()];
                let value = direct !== undefined ? direct : lowerDirect;

                if (value === undefined) {
                    const keys = aliases[field.key.toLowerCase()] || [field.key.toLowerCase()];
                    for (const alias of keys) {
                        if (lowerMap[alias] !== undefined) {
                            value = lowerMap[alias];
                            break;
                        }
                    }
                }

                if (value === undefined || value === null) continue;

                if (field.type === 'checkbox') {
                    mapped[field.key] = value === true || String(value).toLowerCase() === 'true';
                } else if (field.type === 'number') {
                    const numeric = Number(value);
                    if (!Number.isNaN(numeric)) mapped[field.key] = numeric;
                } else {
                    mapped[field.key] = String(value);
                }
            }

            return mapped;
        }

        async function uploadImageForField(fieldId) {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            
            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file size (10MB max)
                if (file.size > 10 * 1024 * 1024) {
                    showStatus('editor-status', 'Image too large. Maximum 10MB.', 'error');
                    return;
                }

                showStatus('editor-status', `Uploading ${file.name}...`, 'info');

                try {
                    const formData = new FormData();
                    formData.append('file', file);

                    const res = await fetch('/api/upload', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${SESSION.token}`
                        },
                        body: formData
                    });

                    const data = await res.json();

                    if (res.status === 401) {
                        throw new Error(data.error || 'Session expired');
                    }
                    
                    if (!res.ok) {
                        throw new Error(data.error || 'Upload failed');
                    }

                    // Find the input field for this image and update it
                    const field = document.getElementById(fieldId);
                    if (field && field.parentElement) {
                        // Find the image element or create display
                        let img = field.querySelector('img');
                        if (!img) {
                            img = document.createElement('img');
                            img.style.cssText = 'max-width: 200px; max-height: 150px; border-radius: 8px; object-fit: cover;';
                            field.insertBefore(img, field.firstChild);
                        }
                        img.src = data.url;
                        
                        // Update the hidden value
                        CURRENT_CONTENT[fieldId.replace('field_', '')] = data.url;
                        markEditorDirty(true);
                        scheduleAutoStage();
                    }

                    showStatus('editor-status', `Image uploaded: ${data.id}`, 'success');
                    setTimeout(() => hideStatus('editor-status'), 3000);

                } catch (e) {
                    if (!handleSessionError(e)) {
                        showStatus('editor-status', `Upload failed: ${e.message}`, 'error');
                    }
                }
            };

            fileInput.click();
        }

        // =================================================================
        // USER MANAGEMENT
        // =================================================================
        async function loadUsers() {
            const tbody = document.getElementById('user-list');
            tbody.innerHTML = '<tr><td colspan="4">Loading...</td></tr>';

            try {
                const res = await fetch('/api/users', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });

                if (res.status === 401 || res.status === 403) {
                    const data = await res.json();
                    throw new Error(data.error || 'Session expired');
                }
                
                if (!res.ok) {
                    throw new Error('Failed to load users');
                }

                const data = await res.json();
                const users = data.users || data;

                if (users.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4">No users found</td></tr>';
                    return;
                }

                tbody.innerHTML = users.map(user => `
                    <tr>
                        <td><strong>${escapeHtml(user.username)}</strong></td>
                        <td>
                            <select onchange="changeUserRole('${escapeHtml(user.username)}', this.value)" ${user.username === SESSION.username ? 'disabled' : ''} style="font-size: 0.95rem; padding: 0.25rem;">
                                <option value="contributor" ${user.role === 'contributor' ? 'selected' : ''}>Contributor</option>
                                <option value="editor" ${user.role === 'editor' ? 'selected' : ''}>Editor</option>
                                <option value="admin" ${user.role === 'admin' ? 'selected' : ''}>Admin</option>
                            </select>
                        </td>
                        <td>${user.created ? new Date(user.created).toLocaleDateString() : '-'}</td>
                        <td class="actions">
                            ${user.username !== SESSION.username ? `
                                <button class="secondary" onclick="resetPassword('${escapeHtml(user.username)}')" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Reset Password</button>
                                <button class="contrast" onclick="deleteUser('${escapeHtml(user.username)}')" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Delete</button>
                            ` : '<em>Current user</em>'}
                        </td>
                    </tr>
                `).join('');

            } catch (e) {
                if (!handleSessionError(e)) {
                    tbody.innerHTML = `<tr><td colspan="4" style="color: var(--error);">${e.message}</td></tr>`;
                }
            }
        }

        async function createUser() {
            const username = document.getElementById('new-username').value.trim().toLowerCase();
            const password = document.getElementById('new-password').value;
            const role = document.getElementById('new-role').value;

            if (!username) {
                showStatus('users-status', 'Username required', 'error');
                return;
            }

            try {
                const res = await fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username, password: password || undefined, role })
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error || 'Failed to create user');
                }

                // Show result with password
                const resultEl = document.getElementById('create-user-result');
                resultEl.className = 'status-message status-success';
                resultEl.innerHTML = `
                    <strong>User created:</strong> ${escapeHtml(data.username)}<br>
                    <strong>Password:</strong> <code>${escapeHtml(data.password)}</code><br>
                    <small>Share this password securely with the user.</small>
                `;
                resultEl.classList.remove('hidden');

                // Clear form
                document.getElementById('new-username').value = '';
                document.getElementById('new-password').value = '';

                // Reload list
                loadUsers();

            } catch (e) {
                showStatus('users-status', e.message, 'error');
            }
        }

        async function resetPassword(username) {
            if (!confirm(`Reset password for ${username}?`)) return;

            try {
                const res = await fetch('/api/users', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username, resetPassword: true })
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error || 'Failed to reset password');
                }

                alert(`New password for ${username}:\n\n${data.newPassword}\n\nShare this securely with the user.`);

            } catch (e) {
                showStatus('users-status', e.message, 'error');
            }
        }

        async function deleteUser(username) {
            if (!confirm(`Delete user ${username}? This cannot be undone.`)) return;

            try {
                const res = await fetch('/api/users', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username })
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error || 'Failed to delete user');
                }

                showStatus('users-status', `User ${username} deleted`, 'success');
                loadUsers();

            } catch (e) {
                showStatus('users-status', e.message, 'error');
            }
        }

        async function changeUserRole(username, newRole) {
            if (!confirm(`Change ${username}'s role to "${newRole}"?`)) {
                loadUsers();  // Reload to reset dropdown
                return;
            }
            
            try {
                const res = await fetch('/api/users', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username, role: newRole })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to update role');
                }
                
                showStatus('users-status', `${username} role changed to ${newRole}`, 'success');
                loadUsers();
                
            } catch (e) {
                showStatus('users-status', e.message, 'error');
                loadUsers();  // Reload to reset dropdown
            }
        }

        async function loadAuditLog() {
            const list = document.getElementById('audit-list');
            const loading = document.getElementById('audit-loading');
            const limit = document.getElementById('audit-limit').value || 100;
            
            loading.classList.remove('hidden');
            list.innerHTML = '';
            
            try {
                const res = await fetch(`/api/audit?limit=${limit}`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to load audit log');
                }
                
                if (data.logs.length === 0) {
                    list.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--muted-color);">No audit records</td></tr>';
                    loading.classList.add('hidden');
                    return;
                }
                
                list.innerHTML = data.logs.map(log => `
                    <tr>
                        <td><small>${new Date(log.timestamp).toLocaleString()}</small></td>
                        <td><strong>${escapeHtml(log.username)}</strong></td>
                        <td><code style="font-size: 0.8rem;">${escapeHtml(log.action)}</code></td>
                        <td><small>${escapeHtml(JSON.stringify(log.details || {}))}</small></td>
                    </tr>
                `).join('');
                
                showStatus('audit-status', `${data.logs.length} records`, 'info');
                
            } catch (e) {
                list.innerHTML = `<tr><td colspan="4" style="color: var(--error);">Error: ${escapeHtml(e.message)}</td></tr>`;
            } finally {
                loading.classList.add('hidden');
            }
        }
        
        async function downloadAuditLog() {
            const limit = document.getElementById('audit-limit').value || 1000;
            
            try {
                const res = await fetch(`/api/audit?limit=${limit}`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                const data = await res.json();
                
                if (!res.ok) throw new Error(data.error || 'Failed to download');
                
                // Convert to CSV
                const csv = [
                    ['Timestamp', 'User', 'Action', 'Details'],
                    ...data.logs.map(log => [
                        new Date(log.timestamp).toISOString(),
                        log.username,
                        log.action,
                        JSON.stringify(log.details || {})
                    ])
                ].map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
                
                // Download
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `audit-log-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
            } catch (e) {
                showStatus('audit-status', e.message, 'error');
            }
        }

        // =================================================================
        // UTILITIES
        // =================================================================
        function mapSetupError(message) {
            const msg = String(message || '');
            const lower = msg.toLowerCase();

            if (lower.includes('invalid setup token')) {
                return [
                    'Invalid setup token.',
                    'Confirm SETUP_TOKEN in Cloudflare Pages -> Settings -> Environment variables (Production), then paste that exact value here.'
                ].join('\n');
            }
            if (lower.includes('setup token') && lower.includes('not configured')) {
                return [
                    'SETUP_TOKEN is not configured.',
                    'Add SETUP_TOKEN as a Secret in Cloudflare Pages, redeploy, then refresh this page.'
                ].join('\n');
            }
            if (lower.includes('kv') && lower.includes('not configured')) {
                return [
                    'KV binding is missing.',
                    'In Cloudflare Pages -> Settings -> Functions, bind LOON_DB (preferred) or KV, then redeploy.'
                ].join('\n');
            }
            if (lower.includes('setup already completed')) {
                return [
                    'Initial setup is already complete.',
                    'Use the normal login form. If you need access, reset admin credentials from an existing admin account.'
                ].join('\n');
            }
            if (lower.includes('too many setup attempts')) {
                return 'Too many setup attempts. Wait about 1 minute, then retry.';
            }
            return msg || 'Initial setup failed.';
        }

        function mapLoginError(message) {
            const msg = String(message || '');
            const lower = msg.toLowerCase();

            if (lower.includes('invalid credentials')) {
                return 'Login failed. Check username/password and try again.';
            }
            if (lower.includes('too many') && lower.includes('login')) {
                return 'Too many login attempts. Wait about 1 minute and try again.';
            }
            if (lower.includes('kv') && lower.includes('not configured')) {
                return [
                    'Login is blocked because KV is not configured.',
                    'Set LOON_DB (preferred) or KV binding in Cloudflare Pages Functions, then redeploy.'
                ].join('\n');
            }
            return msg || 'Login failed.';
        }

        function dismissPostSetupBanner() {
            sessionStorage.removeItem(STORAGE_KEYS.POST_SETUP_NOTICE);
            document.getElementById('post-setup-banner').classList.add('hidden');
        }

        function maybeShowFirstPageWizard() {
            if (!SESSION || SESSION.role !== 'admin') return;
            const dismissed = localStorage.getItem(STORAGE_KEYS.FIRST_PAGE_WIZARD_DISMISSED) === '1';
            if (dismissed) return;
            document.getElementById('first-page-wizard').classList.remove('hidden');
        }

        function dismissFirstPageWizard() {
            localStorage.setItem(STORAGE_KEYS.FIRST_PAGE_WIZARD_DISMISSED, '1');
            document.getElementById('first-page-wizard').classList.add('hidden');
        }

        function startFirstPageWizard() {
            switchTab('editor');
            showNewPageDialog();

            const idEl = document.getElementById('new-page-id');
            const titleEl = document.getElementById('new-page-title');
            const templateEl = document.getElementById('new-page-template');

            if (idEl && !idEl.value.trim()) {
                idEl.value = 'welcome';
            }
            if (titleEl && !titleEl.value.trim()) {
                titleEl.value = 'Welcome';
            }
            if (templateEl && !templateEl.value) {
                templateEl.value = 'blog-post';
            }

            const statusEl = document.getElementById('new-page-status');
            if (statusEl) {
                statusEl.className = 'status-message status-info';
                statusEl.textContent = 'Step 1: Confirm Page ID/Title, then click Create Page. Step 2: Add content and click Save Changes.';
                statusEl.classList.remove('hidden');
            }
        }

        async function copySetupTokenRotationReminder() {
            const reminder = [
                'LOON security follow-up:',
                'Rotate or remove SETUP_TOKEN in Cloudflare Pages -> Settings -> Environment variables (Production).',
                'Then redeploy so the change takes effect.'
            ].join(' ');
            try {
                await navigator.clipboard.writeText(reminder);
                alert('Copied setup-token rotation reminder.');
            } catch (err) {
                alert(reminder);
            }
        }

        function showStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.className = `status-message status-${type}`;
            el.textContent = message;
            el.classList.remove('hidden');
        }

        function hideStatus(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function showError(elementId, message) {
            const el = document.getElementById(elementId);
            el.className = 'status-message status-error';
            el.textContent = message;
            el.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function togglePassword() {
            const input = document.getElementById('password');
            const btn = document.querySelector('.password-toggle');
            if (input.type === 'password') {
                input.type = 'text';
                btn.textContent = 'Hide';
            } else {
                input.type = 'password';
                btn.textContent = 'Show';
            }
        }
    </script>
</body>
</html>
