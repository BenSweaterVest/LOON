<!DOCTYPE html>
<!--
================================================================================
LOON Admin Panel (admin.html)
================================================================================

Content editor interface for LOON CMS.
Users authenticate with Username + Password, receiving a session token.
Role-based access control (RBAC) determines what users can edit.

FEATURES:
- Username/password login (stored in Cloudflare KV)
- Session tokens (24-hour expiry)
- Role-based access control
- User management UI (admin only)
- Content metadata tracking (createdBy, modifiedBy)
- Session expiry detection
- Dark mode support

ROLES:
- Admin: Edit any content, manage users
- Editor: Edit any content
- Contributor: Create new content, edit only own content

AUTHENTICATION:
- Users stored in Cloudflare KV (LOON_DB)
- Login via /api/auth returns session token
- Token included in Authorization header for all requests
- Logout via DELETE /api/auth

API ENDPOINTS USED:
- POST /api/auth   - Login
- DELETE /api/auth - Logout
- POST /api/save   - Save content (with RBAC)
- /api/users       - User management (admin only)

PREREQUISITES:
- Cloudflare KV namespace "LOON_DB" configured
- Initial setup token configured for first-run admin creation (SETUP_TOKEN)
================================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOON Team Admin</title>
    <meta name="description" content="LOON Admin Panel">
    <meta name="robots" content="noindex, nofollow">
    <link rel="icon" type="image/png" href="/favicon.png" sizes="32x32">
    <link rel="apple-touch-icon" href="/favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #1e4d8f;
            --primary-hover: #173f76;
            --success: #17803d;
            --error: #c33232;
            --warning: #b7791f;
            --panel-background: rgba(255, 255, 255, 0.92);
            --panel-border: rgba(148, 163, 184, 0.35);
            --panel-shadow: 0 12px 28px rgba(15, 23, 42, 0.1);
            --surface-muted: rgba(203, 213, 225, 0.25);
        }

        [data-theme="forest"] {
            --primary: #1f6b5c;
            --primary-hover: #185349;
        }

        [data-theme="sunset"] {
            --primary: #b45309;
            --primary-hover: #92400e;
        }

        body {
            padding-top: 1rem;
            background:
                radial-gradient(circle at 20% 10%, rgba(30, 77, 143, 0.12), transparent 35%),
                radial-gradient(circle at 80% 0%, rgba(14, 116, 144, 0.1), transparent 32%),
                linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
            min-height: 100vh;
            font-family: "IBM Plex Sans", "Segoe UI", Tahoma, sans-serif;
        }

        main.container {
            max-width: 1200px;
        }
        
        .hidden { display: none !important; }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--muted-border-color);
            gap: 1rem;
        }
        
        .header h1 { margin: 0; font-size: 1.5rem; }
        .header .user-info { font-size: 0.9rem; color: var(--muted-color); }
        .header .role-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 0.5rem;
        }
        .role-admin { background: var(--primary); color: white; }
        .role-editor { background: var(--success); color: white; }
        .role-contributor { background: var(--warning); color: black; }
        
        .tab-nav {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--muted-border-color);
        }
        .tab-nav button {
            background: none;
            border: none;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            color: var(--muted-color);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }
        .tab-nav button:hover { color: var(--primary); }
        .tab-nav button.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        .tab-nav .logout-btn {
            margin-left: auto;
            color: var(--error);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-controls label {
            margin-bottom: 0;
            font-size: 0.85rem;
            color: var(--muted-color);
        }

        .header-controls select {
            margin-bottom: 0;
            min-width: 150px;
        }
        
        .login-container {
            max-width: 400px;
            margin: 4rem auto;
            padding: 2rem;
            border: 1px solid var(--muted-border-color);
            border-radius: 8px;
            background: var(--panel-background);
            box-shadow: var(--panel-shadow);
        }
        .login-container h2 { text-align: center; margin-bottom: 1.5rem; }
        
        .form-field { margin-bottom: 1rem; }
        .form-field label { display: block; margin-bottom: 0.25rem; font-weight: 500; }
        .form-field small { display: block; color: var(--muted-color); margin-top: 0.25rem; }
        
        .status-message {
            padding: 0.75rem 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            white-space: pre-line;
        }
        .status-success { background: #dcfce7; color: #166534; }
        .status-error { background: #fee2e2; color: #991b1b; }
        .status-info { background: #dbeafe; color: #1e40af; }
        .local-mode-banner {
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid #fed7aa;
            border-left: 4px solid #fb923c;
            background: #fff7ed;
            color: #9a3412;
            margin-bottom: 1rem;
        }
        .local-mode-banner small {
            display: block;
            color: #b45309;
        }
        .onboarding-card {
            max-width: 640px;
            margin: 1rem auto 2rem auto;
            padding: 1.25rem;
            border: 1px solid var(--muted-border-color);
            border-radius: 8px;
            background: var(--card-background-color);
            box-shadow: var(--panel-shadow);
        }
        .onboarding-card h3 {
            margin: 0 0 0.75rem 0;
            font-size: 1.1rem;
        }
        .onboarding-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
            margin: 0.75rem 0 1rem 0;
        }
        .onboarding-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.6rem;
            border: 1px solid var(--muted-border-color);
            border-radius: 6px;
            background: var(--background-color);
        }
        .onboarding-item small {
            display: block;
            color: var(--muted-color);
        }
        .check-chip {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 999px;
            padding: 0.25rem 0.55rem;
            letter-spacing: 0.02em;
            white-space: nowrap;
        }
        .check-pass { background: #dcfce7; color: #166534; }
        .check-warn { background: #fef3c7; color: #92400e; }
        .check-fail { background: #fee2e2; color: #991b1b; }
        .check-pending { background: #dbeafe; color: #1e40af; }
        .onboarding-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .onboarding-help {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border: 1px dashed var(--muted-border-color);
            border-radius: 6px;
            background: var(--background-color);
        }
        .onboarding-help .grid {
            margin-bottom: 0.5rem;
        }
        .setup-check-shell {
            max-width: 760px;
            margin: 2rem auto;
            padding: 1rem;
        }
        .setup-check-shell h1 {
            margin-bottom: 0.5rem;
        }
        .step-list {
            margin: 0.25rem 0 0.25rem 1rem;
        }
        
        .user-table { width: 100%; }
        .user-table th { text-align: left; }
        .user-table td { vertical-align: middle; }
        .user-table .actions { text-align: right; }
        .user-table .actions button {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            margin-left: 0.25rem;
        }
        
        .add-user-form {
            background: var(--card-background-color);
            padding: 1.5rem;
            border-radius: 8px;
            margin-top: 2rem;
            border: 1px solid var(--panel-border);
        }
        .add-user-form h4 { margin-top: 0; }
        
        .page-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .page-selector input { flex: 1; }

        .editor-guide {
            margin: 0 0 1rem 0;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            background: var(--surface-muted);
            padding: 0.8rem 0.9rem;
        }

        .editor-guide summary {
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .editor-guide ol {
            margin: 0.35rem 0 0.25rem 1.25rem;
        }
        
        .editor-container {
            background: var(--card-background-color);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            box-shadow: var(--panel-shadow);
        }
        .editor-container h3 { margin-top: 0; }

        .editor-shell-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 0.75rem;
            margin-bottom: 0.8rem;
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 0.55rem;
        }

        .editor-shell-header h3 {
            margin: 0;
            font-size: 1.25rem;
        }

        .editor-shell-header small {
            color: var(--muted-color);
        }

        .editor-two-column-layout {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 320px;
            gap: 1rem;
            align-items: start;
        }

        .editor-main-column {
            min-width: 0;
        }

        .editor-content-panel {
            padding-top: 0.9rem;
        }

        .editor-content-panel h4 {
            margin: 0 0 0.7rem 0;
            font-size: 1rem;
        }

        .editor-main-column #editor-form {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.85rem;
            background: var(--panel-background);
        }

        .editor-top-fields {
            display: grid;
            gap: 0.75rem;
            margin-bottom: 0.9rem;
        }

        .editor-field-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.75rem;
        }

        .editor-field-card {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.65rem;
            background: var(--panel-background);
        }

        .editor-field-card.invalid {
            border-color: var(--error);
            background: rgba(255, 0, 0, 0.05);
        }

        .editor-field-card.invalid input,
        .editor-field-card.invalid textarea,
        .editor-field-card.invalid select {
            border-color: var(--error) !important;
        }

        .field-error-message {
            color: var(--error);
            font-size: 0.8rem;
            margin-top: 0.35rem;
            display: block;
        }

        .validation-summary {
            padding: 1rem;
            background: rgba(255, 0, 0, 0.08);
            border: 1px solid var(--error);
            border-radius: 4px;
            margin-bottom: 1rem;
            color: var(--error);
        }

        .validation-summary h4 {
            margin: 0 0 0.5rem 0;
            color: var(--error);
        }

        .validation-summary ul {
            margin: 0;
            padding-left: 1.5rem;
        }

        .validation-summary li {
            margin-bottom: 0.25rem;
        }

        .import-preview-panel {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border: 1px dashed var(--panel-border);
            border-radius: 6px;
            background: var(--surface-muted);
        }

        .import-preview-panel h5 {
            margin: 0 0 0.5rem 0;
            font-size: 0.95rem;
        }

        .import-preview-panel ul {
            margin: 0.35rem 0 0.5rem 1.1rem;
        }

        .import-preview-panel code {
            font-size: 0.85rem;
        }

        .editor-body-shell {
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            background: var(--panel-background);
            padding: 0.85rem;
            margin-bottom: 0.9rem;
        }

        .editor-body-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            border-bottom: 1px solid var(--panel-border);
            padding-bottom: 0.6rem;
            margin-bottom: 0.6rem;
        }

        .editor-body-title h5 {
            margin: 0;
            font-size: 1rem;
        }

        .editor-body-title small {
            color: var(--muted-color);
        }

        .editor-body-tabs {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
        }

        .editor-body-tabs button {
            margin: 0;
            padding: 0.35rem 0.75rem;
        }

        .editor-body-tabs .tab-active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .editor-body-actions {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .editor-body-actions button {
            margin: 0;
            padding: 0.35rem 0.75rem;
        }

        .command-palette {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.45);
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding: 8vh 1rem 1rem;
            z-index: 9998;
        }

        .command-palette.open {
            display: flex;
        }

        .command-palette-panel {
            width: min(720px, 92vw);
            background: var(--background-color);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(15, 23, 42, 0.25);
            overflow: hidden;
        }

        .command-palette-input {
            width: 100%;
            padding: 0.75rem 0.9rem;
            border: none;
            border-bottom: 1px solid var(--panel-border);
            border-radius: 12px 12px 0 0;
            font-size: 1rem;
            background: transparent;
        }

        .command-palette-input:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
        }

        .command-palette-list {
            max-height: 340px;
            overflow: auto;
        }

        .command-palette-item {
            padding: 0.6rem 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .command-palette-item small {
            color: var(--muted-color);
        }

        .command-palette-item.active {
            background: var(--muted-border-color);
        }

        .command-palette-empty {
            padding: 0.9rem;
            color: var(--muted-color);
        }

        .outline-list {
            display: grid;
            gap: 0.4rem;
            margin-top: 0.5rem;
        }

        .outline-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.4rem;
            border-radius: 6px;
            cursor: pointer;
        }

        .outline-item:hover {
            background: var(--muted-border-color);
        }

        .outline-level-2 { margin-left: 0.75rem; }
        .outline-level-3 { margin-left: 1.5rem; }

        .undo-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.4rem;
            background: var(--surface-muted);
            border-radius: 6px;
        }

        .editor-body-panels {
            display: grid;
            gap: 0.75rem;
        }

        #primary-editor-slot textarea {
            min-height: 340px;
            font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
            line-height: 1.6;
        }

        #primary-preview {
            min-height: 340px;
            padding: 0.75rem;
            background: var(--surface-muted);
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            overflow: auto;
        }

        #primary-preview h1,
        #primary-preview h2,
        #primary-preview h3 {
            margin-top: 0.8rem;
        }

        #primary-preview code {
            background: rgba(148, 163, 184, 0.2);
            padding: 0.1rem 0.25rem;
            border-radius: 4px;
        }

        .editor-fields-collapsible summary {
            cursor: pointer;
            font-weight: 600;
        }

        .editor-main-column .form-field textarea {
            min-height: 220px;
            font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
            line-height: 1.5;
        }

        .editor-format-toolbar {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            background: var(--panel-background);
            padding: 0.65rem 0.75rem;
            margin-bottom: 0.8rem;
        }

        .editor-format-toolbar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.45rem;
        }

        .editor-format-toolbar-title {
            font-weight: 600;
            font-size: 0.92rem;
        }

        .editor-format-toolbar-note {
            font-size: 0.78rem;
            color: var(--muted-color);
        }

        .editor-format-toolbar-actions {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .editor-format-toolbar-actions button {
            margin: 0;
        }

        .editor-sidebar-column {
            display: grid;
            gap: 0.75rem;
            position: sticky;
            top: 0.75rem;
        }

        .editor-side-panel {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            background: var(--panel-background);
            padding: 0.75rem 0.85rem;
        }

        .editor-side-panel h4 {
            margin: 0 0 0.55rem 0;
            font-size: 0.95rem;
        }

        .editor-meta-stack {
            display: grid;
            gap: 0.6rem;
        }

        .editor-meta-stack .meta-info {
            margin-top: 0;
        }

        @media (max-width: 1080px) {
            .editor-two-column-layout {
                grid-template-columns: 1fr;
            }

            .editor-sidebar-column {
                position: static;
            }
        }

        @media (max-width: 900px) {
            .editor-field-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .save-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--muted-border-color);
            gap: 1rem;
            flex-wrap: wrap;
        }
        .save-bar .last-saved { font-size: 0.85rem; color: var(--muted-color); }
        .edit-dirty-chip {
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 999px;
            padding: 0.2rem 0.55rem;
            background: var(--surface-muted);
            color: var(--muted-color);
        }
        .edit-dirty-chip.dirty {
            background: rgba(245, 158, 11, 0.2);
            color: #92400e;
        }

        .batch-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0;
            font-size: 0.85rem;
            color: var(--muted-color);
        }

        .batch-toggle input {
            margin: 0;
        }

        .queue-summary {
            margin-top: 0.65rem;
            font-size: 0.8rem;
            color: var(--muted-color);
        }

        .workflow-assistant {
            margin: 0.75rem 0 1rem 0;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.7rem 0.8rem;
            background: var(--panel-background);
        }

        .workflow-assistant strong {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.92rem;
        }

        .workflow-assistant small {
            color: var(--muted-color);
            display: block;
            margin-bottom: 0.35rem;
        }

        .editor-tools {
            margin-top: 0.9rem;
            display: grid;
            gap: 0.75rem;
        }

        .editor-tools details {
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            background: var(--panel-background);
        }

        .editor-tools summary {
            font-weight: 600;
            cursor: pointer;
        }

        .autosave-indicator {
            margin-top: 0.35rem;
            font-size: 0.8rem;
            color: var(--muted-color);
        }

        .diff-view {
            max-height: 380px;
            overflow: auto;
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 0.6rem;
            background: var(--panel-background);
            font-family: "IBM Plex Mono", "Consolas", monospace;
            font-size: 0.82rem;
            white-space: pre-wrap;
        }
        .diff-line {
            margin: 0;
            padding: 0.08rem 0.2rem;
            border-radius: 4px;
        }
        .diff-add {
            background: rgba(22, 163, 74, 0.12);
            color: #166534;
        }
        .diff-remove {
            background: rgba(220, 38, 38, 0.12);
            color: #991b1b;
        }
        .diff-same {
            color: var(--muted-color);
        }

        code {
            font-family: "IBM Plex Mono", "Consolas", monospace;
        }
        
        .meta-info {
            font-size: 0.8rem;
            color: var(--muted-color);
            margin-top: 1rem;
            padding: 0.5rem;
            background: var(--muted-border-color);
            border-radius: 4px;
        }
        
        /* Dark mode */
        @media (prefers-color-scheme: dark) {
            .status-success { background: #166534; color: #dcfce7; }
            .status-error { background: #991b1b; color: #fee2e2; }
            .status-info { background: #1e40af; color: #dbeafe; }
            body {
                background:
                    radial-gradient(circle at 20% 10%, rgba(56, 189, 248, 0.18), transparent 38%),
                    radial-gradient(circle at 80% 0%, rgba(16, 185, 129, 0.14), transparent 34%),
                    linear-gradient(180deg, #0b1220 0%, #111827 100%);
            }
        }
        
        /* Password field with toggle */
        .password-wrapper {
            position: relative;
        }
        .password-wrapper input { padding-right: 3rem; }
        .password-toggle {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            color: var(--muted-color);
        }
    </style>
</head>
<body>
    <main class="container">
        <div id="onboarding-guide" class="onboarding-card hidden">
            <h3>Guided Setup Assistant</h3>
            <p style="margin: 0.25rem 0 0.5rem 0; color: var(--muted-color);">
                Complete setup entirely in your browser using Cloudflare, GitHub, and this LOON page.
            </p>
            <div id="onboarding-summary" class="status-message status-info" style="margin-top: 0.5rem;">Checking system status...</div>
            <small id="onboarding-last-verified" style="display:block; color: var(--muted-color); margin-top: -0.35rem;"></small>
            <div class="onboarding-grid" id="onboarding-checks"></div>
            <div id="onboarding-next" class="status-message status-info hidden"></div>
            <h4 style="margin: 0.75rem 0 0.4rem 0;">Next Steps</h4>
            <ol id="onboarding-steps" class="step-list"></ol>
            <div class="onboarding-actions">
                <button type="button" onclick="refreshOnboardingStatus()">Refresh Checks</button>
                <button type="button" class="contrast" onclick="runFullReadinessCheck()">Run Full Readiness Check</button>
                <button type="button" class="secondary" onclick="openCloudflareSetupHelp()">Cloudflare Setup Help</button>
                <button type="button" class="secondary" onclick="openSetupCheckView()">Open Diagnostics View</button>
            </div>
            <div id="full-readiness-result" class="status-message status-info hidden"></div>

            <div class="onboarding-help">
                <h4 style="margin: 0 0 0.4rem 0;">Quick Helpers</h4>
                <div class="grid">
                    <div>
                        <label for="repo-owner-input">GitHub Owner (suggested)</label>
                        <input id="repo-owner-input" type="text" placeholder="your-org-or-username">
                    </div>
                    <div>
                        <label for="repo-name-input">Repository Name (suggested)</label>
                        <input id="repo-name-input" type="text" placeholder="your-loon-repo">
                    </div>
                </div>
                <div class="onboarding-actions" style="margin-bottom: 0.5rem;">
                    <button type="button" onclick="copyGithubRepoSuggestion()">Copy GITHUB_REPO Suggestion</button>
                    <button type="button" onclick="generateAndCopySetupToken()">Generate SETUP_TOKEN</button>
                    <button type="button" onclick="copyEnvTemplate()">Copy Env Template</button>
                </div>
                <small style="color: var(--muted-color);">
                    For production setup, add KV binding <code>LOON_DB</code> in Cloudflare Pages dashboard and redeploy.
                </small>
            </div>
        </div>

        <div id="setup-check-view" class="setup-check-shell hidden">
            <h1>LOON Setup Diagnostics</h1>
            <p style="color: var(--muted-color); margin-top: 0;">
                Browser-only diagnostics view. Use this page to confirm readiness before opening the full admin app.
            </p>
            <div class="onboarding-actions">
                <a href="/admin.html" role="button">Open Admin Login</a>
                <button type="button" class="secondary" onclick="refreshOnboardingStatus()">Refresh Checks</button>
            </div>
        </div>

        <!-- Login Section -->
        <div id="login-section">
            <div class="login-container">
                <h2>LOON Admin</h2>
                
                <div class="form-field">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Enter username" autocomplete="username">
                </div>
                
                <div class="form-field">
                    <label for="password">Password</label>
                    <div class="password-wrapper">
                        <input type="password" id="password" placeholder="Enter password" autocomplete="current-password">
                        <button type="button" class="password-toggle" onclick="togglePassword()">Show</button>
                    </div>
                </div>
                
                <div class="form-field">
                    <label>
                        <input type="checkbox" id="remember-me">
                        Remember me
                    </label>
                </div>
                
                <button onclick="login()" style="width: 100%;">Login</button>
                
                <div style="text-align: center; margin: 1rem 0; color: var(--muted-color);">or</div>
                
                <button onclick="loginWithPasskey()" style="width: 100%;" class="secondary">
                    Login with Passkey
                </button>
                
                <div id="login-error" class="status-message status-error hidden"></div>
            </div>
        </div>

        <!-- Initial Setup Section (shown only when no admin exists) -->
        <div id="setup-section" class="hidden">
            <div class="login-container">
                <h2>LOON Initial Setup</h2>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">
                    Create the first admin account to finish setup.
                </p>

                <div class="form-field">
                    <label for="setup-token">Setup Token</label>
                    <input type="password" id="setup-token" placeholder="Enter SETUP_TOKEN from Cloudflare secret">
                    <small>
                        One-time setup gate only. After first admin is created, rotate/remove this value in Cloudflare.
                    </small>
                </div>

                <div class="form-field">
                    <label for="setup-username">Admin Username</label>
                    <input type="text" id="setup-username" value="admin" autocomplete="username">
                    <small>This becomes your real LOON login username.</small>
                </div>

                <div class="form-field">
                    <label for="setup-password">Admin Password</label>
                    <input type="password" id="setup-password" placeholder="Minimum 8 characters" autocomplete="new-password">
                    <small>This becomes your real LOON login password.</small>
                </div>

                <div class="form-field">
                    <label for="setup-password-confirm">Confirm Password</label>
                    <input type="password" id="setup-password-confirm" placeholder="Re-enter password" autocomplete="new-password">
                </div>

                <button onclick="completeInitialSetup()" style="width: 100%;">Create Admin & Continue</button>

                <div id="setup-error" class="status-message status-error hidden"></div>
            </div>
        </div>

        <!-- App Section (shown after login) -->
        <div id="app-section" class="hidden">
            <header class="header">
                <div>
                    <h1>LOON Admin</h1>
                    <span class="user-info">
                        Logged in as <strong id="display-username"></strong>
                        <span id="display-role" class="role-badge"></span>
                    </span>
                </div>
                <div class="header-controls">
                    <label for="theme-select">Theme</label>
                    <select id="theme-select" onchange="setTheme(this.value)">
                        <option value="default">Slate</option>
                        <option value="forest">Forest</option>
                        <option value="sunset">Sunset</option>
                    </select>
                </div>
            </header>
            <div id="local-mode-banner" class="local-mode-banner hidden">
                <strong>Local mode is active.</strong>
                Changes are saved to the local <code>data/</code> folder on this machine.
                <small>No GitHub publishing happens in local mode.</small>
                <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.5rem;">
                    <button type="button" class="secondary" onclick="dismissLocalModeBanner()">Dismiss</button>
                </div>
            </div>

            <nav class="tab-nav">
                <button onclick="switchTab('editor')" id="tab-editor" class="active">Content Editor</button>
                <button onclick="switchTab('users')" id="tab-users" class="hidden">Manage Users</button>
                <button onclick="switchTab('sessions')" id="tab-sessions" class="hidden">Sessions</button>
                <button onclick="switchTab('audit')" id="tab-audit" class="hidden">Audit Log</button>
                <button onclick="switchTab('health')" id="tab-health" class="hidden">Content Health</button>
                <button onclick="switchTab('account')" id="tab-account">My Account</button>
                <button onclick="logout()" class="logout-btn">Logout</button>
            </nav>
            <div id="post-setup-banner" class="status-message status-info hidden">
                Initial setup is complete.
                Security recommendation: rotate or remove SETUP_TOKEN in Cloudflare Pages environment variables.
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.6rem;">
                    <button type="button" onclick="copySetupTokenRotationReminder()">Copy Rotation Reminder</button>
                    <button type="button" class="secondary" onclick="dismissPostSetupBanner()">Dismiss</button>
                </div>
            </div>
            <div id="first-page-wizard" class="status-message status-info hidden">
                First-time setup helper: create and save your first page now to verify the full GitHub write path.
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.6rem;">
                    <button type="button" onclick="startFirstPageWizard()">Start First Page Wizard</button>
                    <button type="button" class="secondary" onclick="dismissFirstPageWizard()">Dismiss</button>
                </div>
            </div>

            <!-- Editor Tab -->
            <div id="view-editor">
                <details class="editor-guide">
                    <summary>Editor Quick Guide</summary>
                    <ol>
                        <li>Load a page, edit fields, then save directly or stage changes with Batch Session Mode.</li>
                        <li>Use <code>Ctrl/Cmd+S</code> to save/stage quickly. Use <code>Ctrl/Cmd+Shift+S</code> to save as draft.</li>
                        <li>Import existing content from <code>.json</code>, <code>.tid</code>, markdown, text, or HTML.</li>
                        <li>Publish only after staged changes are pushed and reviewed.</li>
                    </ol>
                </details>
                <div class="page-selector">
                    <input type="text" id="pageId" placeholder="Enter Page ID (e.g., welcome, blog-post)">
                    <button onclick="loadEditor()" class="secondary" title="Open this page in the editor">Open Page</button>
                    <button onclick="loadPageList()" class="outline" style="margin-left: 0.5rem;" title="Browse pages you can access">Browse Pages</button>
                    <button onclick="showNewPageDialog()" class="contrast" style="margin-left: 0.5rem;" title="Create a new page with optional template">+ Create Page</button>
                    <button id="duplicate-page-btn" onclick="showDuplicatePageDialog()" class="secondary" style="margin-left: 0.5rem; display: none;" title="Duplicate this page with all content and schema">Duplicate Page</button>
                </div>
                
                <!-- New Page Dialog -->
                <div id="new-page-dialog" class="hidden" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--muted-border-color); border-radius: 4px;">
                    <h4>Create New Page</h4>
                    <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-field">
                            <label for="new-page-id">Page ID *</label>
                            <input type="text" id="new-page-id" placeholder="e.g., my-page (lowercase, hyphens or underscores ok)" pattern="^[a-z0-9_-]+$">
                            <small style="color: var(--muted-color);">lowercase letters, numbers, hyphens, underscores</small>
                        </div>
                        <div class="form-field">
                            <label for="new-page-title">Page Title</label>
                            <input type="text" id="new-page-title" placeholder="e.g., My Page">
                        </div>
                    </div>
                    <div class="form-field">
                        <label for="new-page-template">Template (optional)</label>
                        <select id="new-page-template" onchange="updateTemplateHelp()">
                            <option value="">Blank Page</option>
                            <option value="landing-page">Landing Page</option>
                            <option value="announcement">Announcement</option>
                            <option value="blog-post">Blog Post</option>
                            <option value="business-hours">Business Hours</option>
                            <option value="class-workshop">Class or Workshop</option>
                            <option value="contact-page">Contact Page</option>
                            <option value="directory-entry">Directory Entry</option>
                            <option value="documentation-page">Documentation Page</option>
                            <option value="event">Event</option>
                            <option value="faq">FAQ</option>
                            <option value="food-truck">Food Truck</option>
                            <option value="job-posting">Job Posting</option>
                            <option value="menu-page">Menu Page</option>
                            <option value="menu-pricing">Menu and Pricing</option>
                            <option value="portfolio">Portfolio</option>
                            <option value="product-service">Product or Service</option>
                            <option value="property-listing">Property Listing</option>
                            <option value="service-status">Service Status</option>
                            <option value="team-profile">Team Profile</option>
                            <option value="testimonial">Testimonial</option>
                            <option value="todo-page">Task List</option>
                        </select>
                        <small id="new-page-template-help" style="color: var(--muted-color);">Choose a template to prefill a schema suited to the page type.</small>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="createNewPage()" class="contrast">Create Page</button>
                        <button onclick="cancelNewPage()" class="outline">Cancel</button>
                    </div>
                    <div id="new-page-status"></div>
                </div>
                
                <!-- Duplicate Page Dialog -->
                <div id="duplicate-page-dialog" class="hidden" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--muted-border-color); border-radius: 4px;">
                    <h4>Duplicate Page</h4>
                    <p style="color: var(--muted-color); font-size: 0.9rem;">Create a copy of the current page with all content and schema. The new page will be a draft.</p>
                    <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-field">
                            <label for="dup-page-id">New Page ID *</label>
                            <input type="text" id="dup-page-id" placeholder="e.g., my-copy (lowercase, hyphens or underscores ok)" pattern="^[a-z0-9_-]+$">
                            <small style="color: var(--muted-color);">lowercase letters, numbers, hyphens, underscores</small>
                        </div>
                        <div class="form-field">
                            <label for="dup-page-title">New Page Title</label>
                            <input type="text" id="dup-page-title" placeholder="e.g., Copy of My Page">
                        </div>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="duplicatePage()" class="contrast">Create Duplicate</button>
                        <button onclick="cancelDuplicatePage()" class="outline">Cancel</button>
                    </div>
                    <div id="duplicate-page-status"></div>
                </div>
                
                <!-- Page Browser -->
                <div id="page-browser" class="hidden" style="margin-bottom: 1.5rem;">
                    <h4>Available Pages</h4>
                    <input type="text" id="page-browser-filter" placeholder="Filter pages by title or id..." style="margin-bottom: 0.65rem;" oninput="filterPageBrowserList()">

                    <details id="page-browser-advanced" style="margin-bottom: 0.75rem;">
                        <summary style="cursor: pointer; font-weight: 500;">Advanced Filters</summary>
                        <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.75rem; margin-top: 0.75rem; padding: 0.75rem; background: var(--muted-border-color); border-radius: 4px;">
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-query" style="font-size: 0.9rem;">Text Query</label>
                                <input type="text" id="page-advanced-query" placeholder="title, id, or content" style="font-size: 0.9rem;">
                            </div>
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-status" style="font-size: 0.9rem;">Status</label>
                                <select id="page-advanced-status" style="font-size: 0.9rem;">
                                    <option value="">Any status</option>
                                    <option value="draft">Draft</option>
                                    <option value="in_review">In Review</option>
                                    <option value="approved">Approved</option>
                                    <option value="scheduled">Scheduled</option>
                                    <option value="published">Published</option>
                                </select>
                            </div>
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-author" style="font-size: 0.9rem;">Author</label>
                                <input type="text" id="page-advanced-author" placeholder="creator or editor" style="font-size: 0.9rem;">
                            </div>
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-updated-from" style="font-size: 0.9rem;">Updated From</label>
                                <input type="date" id="page-advanced-updated-from" style="font-size: 0.9rem;">
                            </div>
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-updated-to" style="font-size: 0.9rem;">Updated To</label>
                                <input type="date" id="page-advanced-updated-to" style="font-size: 0.9rem;">
                            </div>
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-content" style="font-size: 0.9rem;">Content Search</label>
                                <label style="font-size: 0.85rem; color: var(--muted-color);">
                                    <input type="checkbox" id="page-advanced-content"> Include body content
                                </label>
                            </div>
                            <div class="form-field" style="margin-bottom: 0;">
                                <label for="page-advanced-limit" style="font-size: 0.9rem;">Result Limit</label>
                                <input type="number" id="page-advanced-limit" value="60" min="1" max="500" style="font-size: 0.9rem;">
                            </div>
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                            <button type="button" class="secondary" onclick="applyAdvancedPageSearch()">Search</button>
                            <button type="button" class="outline" onclick="resetAdvancedPageSearch()">Reset</button>
                        </div>
                    </details>
                    
                    <!-- Bulk Actions Panel -->
                    <div id="bulk-actions-panel" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: var(--muted-border-color); border-radius: 4px;">
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-bottom: 0.5rem;">
                            <span style="font-size: 0.9rem; color: var(--muted-color);">
                                <strong id="bulk-selected-count">0</strong> page(s) selected
                            </span>
                            <button type="button" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;" onclick="bulkSelectAll()">Select All</button>
                            <button type="button" class="outline" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;" onclick="bulkClearSelection()">Clear</button>
                            <label id="bulk-dry-run-wrap" style="font-size: 0.85rem; color: var(--muted-color); display: none;">
                                <input type="checkbox" id="bulk-dry-run">
                                Dry run
                            </label>
                        </div>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button type="button" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;" onclick="bulkPublishPages()">Publish Selected</button>
                            <button type="button" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;" onclick="bulkUnpublishPages()">Unpublish Selected</button>
                            <select id="bulk-workflow-status" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">
                                <option value="">Set Workflow Status...</option>
                                <option value="draft">Draft</option>
                                <option value="in_review">In Review</option>
                                <option value="approved">Approved</option>
                            </select>
                            <button type="button" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;" onclick="bulkSetWorkflowStatus()">Update Status</button>
                        </div>
                    </div>
                    
                    <div id="page-list" style="display: grid; gap: 0.5rem; max-height: 400px; overflow-y: auto;"></div>
                    <div id="page-browser-status"></div>
                </div>
                
                <div id="editor-container" class="editor-container hidden">
                    <div class="editor-shell-header">
                        <h3 id="editor-title">Page Editor</h3>
                        <small>Two-column layout: write in the left column, and manage publish/workflow actions on the right.</small>
                    </div>
                    <div class="editor-two-column-layout">
                        <section class="editor-main-column">
                            <div class="editor-side-panel editor-content-panel">
                                <h4>Content</h4>
                                <div id="content-status" style="margin: 0 0 0.8rem 0; padding: 0.75rem; background: #e7f3ff; border-left: 4px solid #2196F3; display: none;">
                                    <strong id="status-text"></strong>
                                </div>
                                <div id="editor-top-fields" class="editor-top-fields hidden"></div>
                                <div id="editor-body-shell" class="editor-body-shell hidden">
                                    <div class="editor-body-header">
                                        <div class="editor-body-title">
                                            <h5 id="primary-field-label">Main Content</h5>
                                            <small id="primary-field-hint">Supports markdown formatting.</small>
                                            <div id="content-stats" style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--muted-color); display: none;">
                                                <span id="word-count">Words: 0</span>  <span id="reading-time">Reading time: 0 min</span>
                                            </div>
                                        </div>
                                        <div class="editor-body-tabs">
                                            <button type="button" id="preview-tab-write" class="secondary tab-active" onclick="setPreviewMode('write')">Write</button>
                                            <button type="button" id="preview-tab-preview" class="secondary" onclick="setPreviewMode('preview')">Preview</button>
                                            <button type="button" id="preview-as-reader-btn" class="outline" onclick="previewAsReader()" title="Open this page as a reader would see it">Reader View</button>
                                        </div>
                                        <div class="editor-body-actions">
                                            <button type="button" id="undo-btn" class="outline" onclick="undoLastChange()" title="Undo (Ctrl/Cmd+Z)">Undo</button>
                                            <button type="button" id="redo-btn" class="outline" onclick="redoLastChange()" title="Redo (Ctrl/Cmd+Shift+Z)">Redo</button>
                                            <button type="button" id="palette-btn" class="outline" onclick="openCommandPalette()" title="Command Palette (Ctrl/Cmd+K)">Command Palette</button>
                                        </div>
                                    </div>
                                    <div class="editor-format-toolbar">
                                        <div class="editor-format-toolbar-header">
                                            <span class="editor-format-toolbar-title">Formatting + Media</span>
                                            <span class="editor-format-toolbar-note">Focus a text field before using these tools</span>
                                        </div>
                                        <div class="editor-format-toolbar-actions">
                                            <button type="button" class="secondary" onclick="insertBoldText()">Bold</button>
                                            <button type="button" class="secondary" onclick="insertItalicText()">Italic</button>
                                            <button type="button" class="secondary" onclick="insertHeadingText()">Heading</button>
                                            <button type="button" class="secondary" onclick="insertBulletList()">Bullet List</button>
                                            <button type="button" class="secondary" onclick="insertNumberedList()">Numbered List</button>
                                            <button type="button" class="secondary" onclick="insertLinkMarkdown()">Link</button>
                                            <button type="button" class="secondary" onclick="insertImageMarkdownFromUrl()">Image URL</button>
                                            <button type="button" class="contrast" onclick="uploadAndInsertImageMarkdown()">Upload + Insert Image</button>
                                        </div>
                                    </div>
                                    <div class="editor-body-panels">
                                        <div id="primary-editor-slot"></div>
                                        <div id="primary-preview" class="hidden"></div>
                                    </div>
                                </div>
                                <details class="editor-fields-collapsible" open>
                                    <summary>Page Fields</summary>
                                    <div id="editor-form" class="editor-field-grid"></div>
                                </details>
                            </div>
                            <div class="editor-tools">
                                <details open>
                                    <summary>Editor Tips</summary>
                                    <div style="margin-top:0.6rem;">
                                        <small style="display:block; color:var(--muted-color); margin-bottom:0.45rem;">
                                            Use schema image fields for primary/hero images. Use <strong>Upload + Insert Image</strong> for inline images in long text fields.
                                        </small>
                                        <small style="display:block; color:var(--muted-color);">
                                            Save stages: draft first, then publish from the right sidebar when ready.
                                        </small>
                                    </div>
                                </details>
                                <details>
                                    <summary>Internal Link Tools</summary>
                                    <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                        <select id="link-page-select" style="min-width:220px;">
                                            <option value="">Select a page link...</option>
                                        </select>
                                        <button type="button" class="secondary" onclick="insertSelectedPageLink()">Insert [[page-id]]</button>
                                        <button type="button" class="outline" onclick="refreshLinkPageList()">Refresh Pages</button>
                                        <button type="button" class="outline" onclick="findBacklinks()">Find Backlinks</button>
                                    </div>
                                    <div id="backlinks-status" style="margin-top:0.5rem;"></div>
                                    <div id="backlinks-list" style="margin-top:0.5rem;"></div>
                                </details>
                                <details>
                                    <summary>Document Outline</summary>
                                    <div id="outline-status" style="margin-top:0.5rem; color: var(--muted-color);"></div>
                                    <div id="outline-list" class="outline-list"></div>
                                </details>
                                <details>
                                    <summary>Edit History</summary>
                                    <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                        <button type="button" class="secondary" onclick="undoLastChange()">Undo</button>
                                        <button type="button" class="secondary" onclick="redoLastChange()">Redo</button>
                                        <button type="button" class="outline" onclick="clearUndoHistory()">Clear History</button>
                                    </div>
                                    <div id="undo-history-list" style="margin-top:0.6rem; display:grid; gap:0.4rem;"></div>
                                </details>
                                <details>
                                    <summary>Revision History</summary>
                                    <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                        <button type="button" class="secondary" onclick="loadRevisionHistory()">Load Revisions</button>
                                        <button type="button" class="outline" onclick="openDiffForLatestTwo()">Diff Latest Two</button>
                                    </div>
                                    <div id="revision-status" style="margin-top:0.5rem;"></div>
                                    <div id="revision-list" style="margin-top:0.5rem;"></div>
                                    <div id="revision-diff" class="diff-view" style="margin-top:0.6rem; display:none;"></div>
                                </details>
                                <details>
                                    <summary>Reusable Blocks</summary>
                                    <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                        <select id="block-select" style="min-width:220px;">
                                            <option value="">Select a reusable block...</option>
                                        </select>
                                        <button type="button" class="secondary" onclick="insertSelectedBlock()">Insert Block</button>
                                        <button type="button" class="outline" onclick="loadReusableBlocks()">Refresh Blocks</button>
                                    </div>
                                    <div id="blocks-status" style="margin-top:0.5rem;"></div>
                                </details>
                            </div>
                        </section>
                        <aside class="editor-sidebar-column">
                            <div class="editor-side-panel">
                                <h4>Publish</h4>
                                <div class="save-bar" style="margin-top:0; padding-top:0; border-top:none;">
                                    <span class="last-saved" id="last-saved"></span>
                                    <span id="edit-dirty-chip" class="edit-dirty-chip">No local edits</span>
                                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                        <label class="batch-toggle" for="batch-mode-toggle" title="Stage edits during this session, then push all at once">
                                            <input type="checkbox" id="batch-mode-toggle" onchange="setBatchModeEnabled(this.checked)">
                                            Batch Session Mode
                                        </label>
                                        <button onclick="triggerImportFileDialog()" id="import-btn" class="outline" title="Import JSON, .tid, markdown, HTML, or text into this form">
                                            Import File
                                        </button>
                                        <button onclick="pushAllChanges()" id="push-all-btn" class="secondary hidden">
                                            Push All Changes (0)
                                        </button>
                                        <button onclick="saveContentAsDraft()" id="draft-btn" style="display: none;">Save as Draft</button>
                                        <button onclick="saveContent()" id="save-btn">Save Changes</button>
                                        <button onclick="publishContent()" id="publish-btn" class="contrast" style="display: none;">Publish</button>
                                        <button onclick="deleteContent()" id="delete-btn" class="outline" style="color: var(--error); display: none;">Delete</button>
                                    </div>
                                </div>
                                <div id="import-preview-panel" class="import-preview-panel hidden"></div>
                                <div id="queue-summary" class="queue-summary"></div>
                                <div id="autosave-indicator" class="autosave-indicator"></div>
                                <details style="margin-top: 1rem;">
                                    <summary style="cursor: pointer; font-weight: 500;">Autosave Snapshots</summary>
                                    <div id="autosave-snapshots-list" style="margin-top: 0.75rem; max-height: 250px; overflow-y: auto;"></div>
                                </details>
                            </div>
                            <div class="editor-side-panel">
                                <h4>Workflow + Watchlist</h4>
                                <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                    <select id="workflow-status-select" style="min-width:180px;">
                                        <option value="draft">Draft</option>
                                        <option value="in_review">In Review</option>
                                        <option value="approved">Approved</option>
                                        <option value="scheduled">Scheduled</option>
                                        <option value="published">Published</option>
                                    </select>
                                    <input type="datetime-local" id="workflow-scheduled-for">
                                    <button type="button" class="secondary" onclick="updateWorkflowStatus()">Update Workflow</button>
                                    <button type="button" class="outline" onclick="runScheduledPublishNow()">Run Scheduled Publish</button>
                                </div>
                                <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.6rem;">
                                    <button type="button" class="outline" id="watch-toggle-btn" onclick="toggleWatchPage()">Watch Page</button>
                                    <button type="button" class="outline" onclick="loadWatchActivity()">Refresh Watch Activity</button>
                                </div>
                                <div id="workflow-status-panel" style="margin-top:0.5rem;"></div>
                                <div id="watch-activity-list" style="margin-top:0.5rem;"></div>
                            </div>
                            <div class="editor-side-panel editor-meta-stack">
                                <div id="workflow-assistant" class="workflow-assistant" style="margin:0;">
                                    <strong>Workflow Assistant</strong>
                                    <small>Load a page to see recommended next actions.</small>
                                    <div id="workflow-assistant-body"></div>
                                </div>
                                <div id="content-meta" class="meta-info hidden"></div>
                            </div>
                        </aside>
                    </div>
                    <input type="file" id="import-file-input" class="hidden" accept=".json,.tid,.md,.markdown,.txt,.html,.htm,.docx,.pdf,.rtf,.odt,.csv" onchange="handleImportFileChosen(event)">
                </div>
                
                <div id="editor-status"></div>
            </div>

            <!-- Users Tab (Admin only) -->
            <div id="view-users" class="hidden">
                <h3>Team Members</h3>
                
                <table class="user-table" role="grid">
                    <thead>
                        <tr>
                            <th>Username</th>
                            <th>Role</th>
                            <th>Created</th>
                            <th class="actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="user-list"></tbody>
                </table>
                
                <div id="users-status"></div>
                
                <div class="add-user-form">
                    <h4>Add New User</h4>
                    <div class="grid">
                        <div class="form-field">
                            <label for="new-username">Username</label>
                            <input type="text" id="new-username" placeholder="lowercase, no spaces">
                        </div>
                        <div class="form-field">
                            <label for="new-password">Password (optional)</label>
                            <input type="text" id="new-password" placeholder="Leave blank to auto-generate">
                        </div>
                        <div class="form-field">
                            <label for="new-role">Role</label>
                            <select id="new-role">
                                <option value="contributor">Contributor</option>
                                <option value="editor">Editor</option>
                                <option value="admin">Admin</option>
                            </select>
                        </div>
                    </div>
                    <button onclick="createUser()">Create User</button>
                    
                    <div id="create-user-result" class="hidden"></div>
                </div>
            </div>

            <!-- Sessions Tab (Admin only) -->
            <div id="view-sessions" class="hidden">
                <h3>Active Sessions</h3>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">Monitor and manage user sessions for security.</p>
                
                <table class="user-table" role="grid">
                    <thead>
                        <tr>
                            <th>User</th>
                            <th>Role</th>
                            <th>Login Time</th>
                            <th>IP Address</th>
                            <th class="actions">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="session-list"></tbody>
                </table>
                
                <div id="sessions-status"></div>
                
                <div style="margin-top: 1.5rem; padding: 1rem; background: var(--muted-border-color); border-radius: 8px;">
                    <h4>Force Logout User</h4>
                    <p style="color: var(--muted-color); font-size: 0.9rem; margin-bottom: 1rem;">Revoke all sessions for a user (useful if account is compromised).</p>
                    <div style="display: flex; gap: 0.5rem;">
                        <input type="text" id="force-logout-username" placeholder="Username" style="flex: 1;">
                        <button onclick="forceLogoutUser()" class="secondary">Revoke All Sessions</button>
                    </div>
                </div>
            </div>

            <!-- Account Tab -->
            <div id="view-account" class="hidden">
                <h3>My Account</h3>
                
                <div class="account-info" style="margin-bottom: 2rem; padding: 1rem; background: var(--muted-border-color); border-radius: 8px;">
                    <p><strong>Username:</strong> <span id="account-username"></span></p>
                    <p><strong>Role:</strong> <span id="account-role"></span></p>
                </div>
                
                <div class="change-password-form" style="max-width: 400px;">
                    <h4>Change Password</h4>
                    
                    <div class="form-field">
                        <label for="current-password">Current Password</label>
                        <input type="password" id="current-password" autocomplete="current-password">
                    </div>
                    
                    <div class="form-field">
                        <label for="new-password-self">New Password</label>
                        <input type="password" id="new-password-self" autocomplete="new-password">
                        <small style="color: var(--muted-color);">Minimum 8 characters</small>
                    </div>
                    
                    <div class="form-field">
                        <label for="confirm-password">Confirm New Password</label>
                        <input type="password" id="confirm-password" autocomplete="new-password">
                    </div>
                    
                    <button onclick="changePassword()">Change Password</button>
                    
                    <div id="password-change-status"></div>
                </div>
                
                <!-- Passkeys Section -->
                <div class="passkeys-section" style="margin-top: 3rem;">
                    <h4>Passkeys</h4>
                    <p style="color: var(--muted-color); margin-bottom: 1rem;">
                        Passkeys are more secure than passwords and protect against phishing. 
                        <a href="/docs/PASSKEYS_GUIDE.md" target="_blank">Learn more</a>
                    </p>
                    
                    <div id="passkey-browser-check" class="hidden" style="padding: 1rem; background: var(--warning); color: black; border-radius: 8px; margin-bottom: 1rem;">
                        <strong>Passkeys not supported</strong> - Your browser doesn't support WebAuthn. Please use Chrome, Edge, Safari, or Firefox.
                    </div>
                    
                    <div id="passkeys-list" style="margin-bottom: 1.5rem;">
                        <h5 style="margin-bottom: 0.5rem;">Your Passkeys</h5>
                        <div id="passkeys-list-container"></div>
                    </div>
                    
                    <button id="register-passkey-btn" onclick="registerPasskey()" class="secondary">+ Register New Passkey</button>
                    
                    <div id="passkey-status" style="margin-top: 1rem;"></div>
                    
                    <!-- Recovery Codes Modal -->
                    <div id="recovery-codes-modal" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 9999;">
                        <div style="background: var(--background-color); padding: 2rem; border-radius: 8px; max-width: 500px; width: 90%;">
                            <h4>Save Your Recovery Codes</h4>
                            <p style="color: var(--muted-color);">
                                If you lose access to all your passkeys, these codes can help you recover your account. 
                                <strong>Store them securely</strong> - each code can only be used once.
                            </p>
                            <div id="recovery-codes-display" style="background: var(--code-background-color); padding: 1rem; border-radius: 4px; font-family: monospace; margin: 1rem 0; line-height: 1.8;"></div>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="downloadRecoveryCodes()" class="secondary">Download</button>
                                <button onclick="copyRecoveryCodes()" class="outline">Copy</button>
                                <button onclick="closeRecoveryCodesModal()" style="margin-left: auto;">I've Saved Them</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Audit Log Tab (Admin only) -->
            <div id="view-audit" class="hidden">
                <h3>Audit Log</h3>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">Track admin actions and content changes.</p>
                
                <!-- Filters -->
                <details style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 500;">Filters</summary>
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.75rem; margin-top: 1rem; padding: 1rem; background: var(--muted-border-color); border-radius: 4px;">
                        <div class="form-field" style="margin-bottom: 0;">
                            <label for="audit-filter-user" style="font-size: 0.9rem;">Filter by User</label>
                            <input type="text" id="audit-filter-user" placeholder="username (optional)" style="font-size: 0.9rem;">
                        </div>
                        <div class="form-field" style="margin-bottom: 0;">
                            <label for="audit-filter-action" style="font-size: 0.9rem;">Filter by Action</label>
                            <select id="audit-filter-action" style="font-size: 0.9rem;">
                                <option value="">All Actions</option>
                                <option value="content_save">Content Save</option>
                                <option value="content_delete">Content Delete</option>
                                <option value="page_create">Page Create</option>
                                <option value="login">Login</option>
                                <option value="logout">Logout</option>
                                <option value="user_create">User Create</option>
                                <option value="user_delete">User Delete</option>
                                <option value="password_change">Password Change</option>
                                <option value="content_workflow_update">Workflow Update</option>
                                <option value="content_scheduled_publish">Scheduled Publish</option>
                            </select>
                        </div>
                        <div class="form-field" style="margin-bottom: 0;">
                            <label for="audit-filter-date-from" style="font-size: 0.9rem;">From Date</label>
                            <input type="date" id="audit-filter-date-from" style="font-size: 0.9rem;">
                        </div>
                        <div class="form-field" style="margin-bottom: 0;">
                            <label for="audit-filter-date-to" style="font-size: 0.9rem;">To Date</label>
                            <input type="date" id="audit-filter-date-to" style="font-size: 0.9rem;">
                        </div>
                    </div>
                </details>
                
                <div style="margin-bottom: 1.5rem; display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                    <input type="number" id="audit-limit" value="100" style="width: 80px;" placeholder="Limit">
                    <button onclick="loadAuditLog()" class="secondary">Load Logs</button>
                    <button onclick="applyAuditFilters()" class="secondary" title="Apply the filters above">Apply Filters</button>
                    <button onclick="downloadAuditLog()" class="outline">Download CSV</button>
                </div>
                
                <div id="audit-loading" class="hidden" style="text-align: center; padding: 2rem; color: var(--muted-color);">Loading...</div>
                <div id="audit-filter-status" style="margin-bottom: 0.75rem; color: var(--muted-color); font-size: 0.9rem;"></div>
                
                <table class="user-table" role="grid" id="audit-table" style="font-size: 0.9rem;">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>User</th>
                            <th>Action</th>
                            <th>Details</th>
                        </tr>
                    </thead>
                    <tbody id="audit-list"></tbody>
                </table>
                
                <div id="audit-status"></div>
            </div>

            <!-- Content Health Dashboard (Admin only) -->
            <div id="view-health" class="hidden">
                <h3>Content Health Dashboard</h3>
                <p style="color: var(--muted-color); margin-bottom: 1rem;">Monitor content quality, draft status, and completeness across all pages.</p>
                
                <div style="margin-bottom: 1.5rem;">
                    <button onclick="scanContentHealth()" class="secondary">Scan Health</button>
                    <span id="health-scan-status" style="margin-left: 1rem; color: var(--muted-color);"></span>
                </div>

                <div id="health-summary" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem; display: none;">
                    <div style="padding: 1rem; border: 1px solid var(--muted-border-color); border-radius: 4px;">
                        <div style="color: var(--muted-color); font-size: 0.9rem;">Total Pages</div>
                        <div style="font-size: 2rem; font-weight: bold;" id="health-total">0</div>
                    </div>
                    <div style="padding: 1rem; border: 1px solid var(--muted-border-color); border-radius: 4px;">
                        <div style="color: var(--muted-color); font-size: 0.9rem;">Critical Issues</div>
                        <div style="font-size: 2rem; font-weight: bold; color: #d32f2f;" id="health-critical">0</div>
                    </div>
                    <div style="padding: 1rem; border: 1px solid var(--muted-border-color); border-radius: 4px;">
                        <div style="color: var(--muted-color); font-size: 0.9rem;">Warnings</div>
                        <div style="font-size: 2rem; font-weight: bold; color: #f57c00;" id="health-warnings">0</div>
                    </div>
                    <div style="padding: 1rem; border: 1px solid var(--muted-border-color); border-radius: 4px;">
                        <div style="color: var(--muted-color); font-size: 0.9rem;">Health Score</div>
                        <div style="font-size: 2rem; font-weight: bold; color: #2e7d32;" id="health-score">0%</div>
                    </div>
                </div>

                <div id="health-issues" style="display: none;">
                    <h4 style="margin-bottom: 1rem;">Issues Found</h4>
                    <div id="health-issues-list" style="display: flex; flex-direction: column; gap: 1rem;"></div>
                </div>

                <div id="health-no-issues" style="text-align: center; padding: 2rem; color: var(--muted-color); display: none;">
                    <p style="font-size: 1.2rem;">All content looks healthy.</p>
                </div>

                <div id="health-loading" class="hidden" style="text-align: center; padding: 2rem; color: var(--muted-color);">Scanning content...</div>
            </div>
        </div>
    </main>

    <div id="command-palette" class="command-palette" aria-hidden="true" role="dialog" aria-modal="true">
        <div class="command-palette-panel">
            <input id="command-palette-input" class="command-palette-input" type="text" placeholder="Type a command or search..." autocomplete="off">
            <div id="command-palette-list" class="command-palette-list"></div>
        </div>
    </div>

    <footer class="container" style="text-align: center; margin-top: 3rem; color: var(--muted-color);">
        <small>LOON Admin Panel</small>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mammoth/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/build/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@zip.js/zip.js@2.7.48/dist/zip.min.js"></script>
    <script>
        // =================================================================
        // STATE
        // =================================================================
        let SESSION = null;
        let CURRENT_SCHEMA = null;
        let CURRENT_CONTENT = null;
        let CURRENT_PAGE_ID = null;
        let BATCH_MODE_ENABLED = false;
        let PENDING_CHANGES = [];
        let AUTO_STAGE_TIMER = null;
        let AUTOSAVE_TIMER = null;
        let LAST_FOCUSED_FIELD_ID = null;
        let PAGE_CACHE = [];
        let WATCHED_PAGES = [];
        let BLOCK_CACHE = [];
        let REVISION_CACHE = [];
        let PAGE_BROWSER_ITEMS = [];
        let PAGE_BROWSER_CAN_EDIT_ALL = false;
        let BULK_SELECTED_PAGES = new Set();
        let AUDIT_LOG_DATA = [];
        let HAS_LOCAL_CHANGES = false;
        let EDITOR_BUSY = false;
        let PASSKEY_ENV_READY = null;
        let LOCAL_MODE = false;
        let PRIMARY_FIELD_KEY = null;
        let PREVIEW_MODE = 'write';
        let UNDO_STACK = [];
        let REDO_STACK = [];
        let UNDO_TIMER = null;
        let UNDO_SUSPENDED = false;
        let OUTLINE_TIMER = null;
        let OUTLINE_ENTRIES = [];
        let PAGE_CONTENT_CACHE = new Map();
        let COMMAND_PALETTE_OPEN = false;
        let COMMAND_PALETTE_INDEX = 0;
        let COMMAND_PALETTE_RESULTS = [];
        let PENDING_IMPORT = null;
        const MAX_UNDO_STACK = 50;
        const UNDO_DEBOUNCE_MS = 650;
        let LAST_PAGE_QUERY = '';

        const STORAGE_KEYS = {
            SESSION: 'loon_session',
            LAST_PAGE: 'loon_last_page',
            POST_SETUP_NOTICE: 'loon_post_setup_notice',
            LAST_READINESS: 'loon_last_readiness',
            FIRST_PAGE_WIZARD_DISMISSED: 'loon_first_page_wizard_dismissed',
            LOCAL_BANNER_DISMISSED: 'loon_local_banner_dismissed',
            THEME: 'loon_theme',
            BATCH_MODE: 'loon_batch_mode',
            PENDING_CHANGES: 'loon_pending_changes',
            AUTOSAVE_PREFIX: 'loon_autosave_'
        };
        let ONBOARDING_TIMER = null;
        const VIEW_MODE = new URLSearchParams(window.location.search).get('view') || 'default';

        if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/build/pdf.worker.min.js';
        }

        // =================================================================
        // INITIALIZATION
        // =================================================================
        document.addEventListener('DOMContentLoaded', () => {
            initTheme();
            initBatchMode();
            prefillRepoSuggestion();
            hydrateLastReadinessStamp();
            updateLocalModeBanner();

            if (VIEW_MODE === 'setup-check') {
                startOnboardingMonitor();
                showSetupCheckView();
                return;
            }

            // Check for saved session (localStorage or sessionStorage)
            const saved = localStorage.getItem(STORAGE_KEYS.SESSION) || sessionStorage.getItem(STORAGE_KEYS.SESSION);
            if (saved) {
                try {
                    SESSION = JSON.parse(saved);
                    
                    // Check if session expired client-side
                    if (SESSION.expiresAt && Date.now() > SESSION.expiresAt) {
                        localStorage.removeItem(STORAGE_KEYS.SESSION);
                        sessionStorage.removeItem(STORAGE_KEYS.SESSION);
                        SESSION = null;
                    } else {
                        showApp();
                        // Verify session is still valid server-side
                        verifySession();
                    }
                } catch (e) {
                    localStorage.removeItem(STORAGE_KEYS.SESSION);
                    sessionStorage.removeItem(STORAGE_KEYS.SESSION);
                    SESSION = null;
                }
            }

            if (!SESSION) {
                startOnboardingMonitor();
                checkInitialSetupStatus();
            }

            // Restore last page ID
            const lastPage = localStorage.getItem(STORAGE_KEYS.LAST_PAGE);
            if (lastPage) {
                document.getElementById('pageId').value = lastPage;
            }

            // Enter key handlers
            document.getElementById('username').addEventListener('keypress', e => {
                if (e.key === 'Enter') document.getElementById('password').focus();
            });
            document.getElementById('password').addEventListener('keypress', e => {
                if (e.key === 'Enter') login();
            });
            document.getElementById('setup-password-confirm').addEventListener('keypress', e => {
                if (e.key === 'Enter') completeInitialSetup();
            });
            document.getElementById('pageId').addEventListener('keypress', e => {
                if (e.key === 'Enter') loadEditor();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', e => {
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    if (CURRENT_SCHEMA) handlePrimarySaveAction();
                }
                if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === 'S' || e.key === 's')) {
                    e.preventDefault();
                    if (CURRENT_SCHEMA && SESSION && SESSION.role !== 'contributor') {
                        saveContentAsDraft();
                    }
                }
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                    if (COMMAND_PALETTE_OPEN) return;
                    e.preventDefault();
                    undoLastChange();
                }
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y' || (e.shiftKey && (e.key === 'z' || e.key === 'Z')))) {
                    if (COMMAND_PALETTE_OPEN) return;
                    e.preventDefault();
                    redoLastChange();
                }
                if ((e.ctrlKey || e.metaKey) && (e.key === 'k' || e.key === 'K')) {
                    e.preventDefault();
                    openCommandPalette();
                }
                if (COMMAND_PALETTE_OPEN) {
                    handleCommandPaletteKeydown(e);
                }
            });

            initCommandPalette();
        });

        function initTheme() {
            const savedTheme = localStorage.getItem(STORAGE_KEYS.THEME) || 'default';
            setTheme(savedTheme, false);
        }

        function setTheme(theme, persist = true) {
            const normalized = ['default', 'forest', 'sunset'].includes(theme) ? theme : 'default';
            if (normalized === 'default') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', normalized);
            }

            const select = document.getElementById('theme-select');
            if (select) select.value = normalized;
            if (persist) localStorage.setItem(STORAGE_KEYS.THEME, normalized);
        }

        function updateLocalModeBanner() {
            fetch('/api/health', { cache: 'no-store' })
                .then(res => res.json())
                .then(data => {
                    LOCAL_MODE = !!data?.localMode;
                    const banner = document.getElementById('local-mode-banner');
                    const dismissed = localStorage.getItem(STORAGE_KEYS.LOCAL_BANNER_DISMISSED) === '1';
                    if (banner) {
                        if (LOCAL_MODE && !dismissed) {
                            banner.classList.remove('hidden');
                        } else {
                            banner.classList.add('hidden');
                        }
                    }
                    updateBulkDryRunVisibility();
                })
                .catch(() => {
                    LOCAL_MODE = false;
                    updateBulkDryRunVisibility();
                });
        }

        function dismissLocalModeBanner() {
            localStorage.setItem(STORAGE_KEYS.LOCAL_BANNER_DISMISSED, '1');
            const banner = document.getElementById('local-mode-banner');
            if (banner) banner.classList.add('hidden');
        }

        function updateBulkDryRunVisibility() {
            const wrap = document.getElementById('bulk-dry-run-wrap');
            if (!wrap) return;
            wrap.style.display = LOCAL_MODE ? 'inline-flex' : 'none';
        }

        function initBatchMode() {
            BATCH_MODE_ENABLED = localStorage.getItem(STORAGE_KEYS.BATCH_MODE) === '1';
            const rawQueue = localStorage.getItem(STORAGE_KEYS.PENDING_CHANGES);
            if (rawQueue) {
                try {
                    const parsed = JSON.parse(rawQueue);
                    if (Array.isArray(parsed)) {
                        PENDING_CHANGES = parsed;
                    }
                } catch {
                    PENDING_CHANGES = [];
                }
            }

            const toggle = document.getElementById('batch-mode-toggle');
            if (toggle) {
                toggle.checked = BATCH_MODE_ENABLED;
            }
            updateBatchUi();
        }

        window.addEventListener('beforeunload', (event) => {
            if (PENDING_CHANGES.length > 0 || HAS_LOCAL_CHANGES) {
                event.preventDefault();
                event.returnValue = '';
            }
        });

        function setEditorBusy(busy) {
            EDITOR_BUSY = !!busy;
            const ids = ['save-btn', 'draft-btn', 'publish-btn', 'push-all-btn', 'delete-btn', 'import-btn'];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                el.disabled = EDITOR_BUSY;
            });
        }

        function markEditorDirty(isDirty) {
            HAS_LOCAL_CHANGES = !!isDirty;
            const chip = document.getElementById('edit-dirty-chip');
            if (!chip) return;
            if (HAS_LOCAL_CHANGES) {
                chip.textContent = 'Unsaved local edits';
                chip.classList.add('dirty');
            } else {
                chip.textContent = 'No local edits';
                chip.classList.remove('dirty');
            }
        }

        function setBatchModeEnabled(enabled) {
            BATCH_MODE_ENABLED = !!enabled;
            localStorage.setItem(STORAGE_KEYS.BATCH_MODE, BATCH_MODE_ENABLED ? '1' : '0');
            if (!BATCH_MODE_ENABLED && AUTO_STAGE_TIMER) {
                clearTimeout(AUTO_STAGE_TIMER);
                AUTO_STAGE_TIMER = null;
            }
            updateBatchUi();
            if (BATCH_MODE_ENABLED) {
                showStatus('editor-status', 'Batch Session Mode enabled. Changes are staged in your browser until you click Push All Changes.', 'info');
            } else {
                showStatus('editor-status', 'Batch Session Mode disabled. Save actions now commit immediately to GitHub.', 'info');
            }
        }

        function persistPendingChanges() {
            localStorage.setItem(STORAGE_KEYS.PENDING_CHANGES, JSON.stringify(PENDING_CHANGES));
        }

        function updateBatchUi() {
            const pushBtn = document.getElementById('push-all-btn');
            const toggle = document.getElementById('batch-mode-toggle');
            const summary = document.getElementById('queue-summary');
            const saveBtn = document.getElementById('save-btn');
            const draftBtn = document.getElementById('draft-btn');
            if (toggle) toggle.checked = BATCH_MODE_ENABLED;

            if (!pushBtn) return;
            pushBtn.textContent = `Push All Changes (${PENDING_CHANGES.length})`;

            if (BATCH_MODE_ENABLED) {
                pushBtn.classList.remove('hidden');
            } else {
                pushBtn.classList.add('hidden');
            }

            if (summary) {
                if (!PENDING_CHANGES.length) {
                    summary.textContent = BATCH_MODE_ENABLED
                        ? 'No staged changes yet. Edit content to stage updates for this session.'
                        : '';
                } else {
                    const pageCount = new Set(PENDING_CHANGES.map(item => item.pageId)).size;
                    summary.textContent = `${PENDING_CHANGES.length} staged change(s) across ${pageCount} page(s). Push all before publishing.`;
                }
            }

            if (saveBtn) {
                saveBtn.textContent = BATCH_MODE_ENABLED ? 'Stage Change' : 'Save Changes';
                saveBtn.title = BATCH_MODE_ENABLED
                    ? 'Stage this page change in your browser queue'
                    : 'Save and commit this change immediately';
            }

            if (draftBtn) {
                draftBtn.textContent = BATCH_MODE_ENABLED ? 'Stage Draft' : 'Save as Draft';
                draftBtn.title = BATCH_MODE_ENABLED
                    ? 'Stage this draft change in your browser queue'
                    : 'Save draft immediately';
            }

            renderWorkflowAssistant();
        }

        function getStagedLabel(saveAs) {
            return saveAs === 'draft' ? 'draft' : 'live';
        }

        function getCurrentPageSaveMode() {
            if (SESSION && SESSION.role === 'contributor') return 'draft';
            return 'live';
        }

        function getQueueKey(pageId, mode) {
            return `${pageId}::${mode}`;
        }

        function getQueuedChangeForPage(pageId, preferredMode = null) {
            const mode = preferredMode || getCurrentPageSaveMode();
            const key = getQueueKey(pageId, mode);
            return PENDING_CHANGES.find(item => item.key === key) || null;
        }

        function hasQueuedChangeForCurrentPage() {
            if (!CURRENT_PAGE_ID) return false;
            return !!getQueuedChangeForPage(CURRENT_PAGE_ID);
        }

        function scheduleAutoStage() {
            if (!BATCH_MODE_ENABLED || !CURRENT_PAGE_ID || !CURRENT_SCHEMA) return;
            if (AUTO_STAGE_TIMER) clearTimeout(AUTO_STAGE_TIMER);
            AUTO_STAGE_TIMER = setTimeout(() => {
                const mode = getCurrentPageSaveMode();
                stageCurrentContentChange(mode === 'draft' ? 'draft' : null, { silent: true });
            }, 450);
        }

        function stageCurrentContentChange(saveAs = null, options = {}) {
            const content = collectCurrentFormContent();
            const mode = saveAs === 'draft' ? 'draft' : 'live';
            const key = getQueueKey(CURRENT_PAGE_ID, mode);
            const entry = {
                key,
                pageId: CURRENT_PAGE_ID,
                saveAs: saveAs === 'draft' ? 'draft' : null,
                content,
                queuedAt: Date.now()
            };

            PENDING_CHANGES = PENDING_CHANGES.filter(item => item.key !== key);
            PENDING_CHANGES.push(entry);
            persistPendingChanges();
            updateBatchUi();

            CURRENT_CONTENT = content;
            document.getElementById('last-saved').textContent = `Staged ${getStagedLabel(saveAs)} change at ${new Date().toLocaleTimeString()}`;
            markEditorDirty(false);
            if (!options.silent) {
                showStatus('editor-status', `Change staged for ${CURRENT_PAGE_ID}. Click "Push All Changes" when ready.`, 'success');
                setTimeout(() => hideStatus('editor-status'), 2500);
            }
        }

        async function pushAllChanges() {
            if (!PENDING_CHANGES.length) {
                showStatus('editor-status', 'No staged changes to push.', 'info');
                return;
            }
            if (EDITOR_BUSY) return;

            setEditorBusy(true);
            const queue = [...PENDING_CHANGES];
            const total = queue.length;

            try {
                for (let i = 0; i < queue.length; i++) {
                    const item = queue[i];
                    showStatus('editor-status', `Pushing staged change ${i + 1}/${total} for "${item.pageId}"...`, 'info');
                    await sendSaveRequest(item.pageId, item.content, item.saveAs);
                    PENDING_CHANGES = PENDING_CHANGES.filter(change => change.key !== item.key);
                    persistPendingChanges();
                    updateBatchUi();
                }

                document.getElementById('last-saved').textContent = `Pushed ${total} staged change(s)`;
                markEditorDirty(false);
                showStatus('editor-status', `Pushed ${total} staged change(s) successfully.`, 'success');
                setTimeout(() => hideStatus('editor-status'), 3000);
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Push failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        function handlePrimarySaveAction() {
            if (SESSION && SESSION.role === 'contributor') {
                return saveContentAsDraft();
            }
            return saveContent();
        }

        function renderWorkflowAssistant() {
            const body = document.getElementById('workflow-assistant-body');
            if (!body) return;

            const pageLoaded = !!CURRENT_PAGE_ID;
            const queuedForPage = hasQueuedChangeForCurrentPage();
            const totalQueued = PENDING_CHANGES.length;
            const canPublish = SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor');

            if (!SESSION) {
                body.innerHTML = '<small>Log in to start editing.</small>';
                return;
            }

            if (!pageLoaded) {
                body.innerHTML = '<small>Next: Load a page or create a new page.</small>';
                return;
            }

            const actions = [];
            actions.push(`Role: <code>${escapeHtml(SESSION.role)}</code>`);
            actions.push(`Mode: <code>${BATCH_MODE_ENABLED ? 'batch staging' : 'immediate commits'}</code>`);
            actions.push(`Queued changes: <code>${totalQueued}</code>`);

            if (BATCH_MODE_ENABLED && totalQueued > 0) {
                actions.push('Recommended: Click <strong>Push All Changes</strong> before ending session.');
            }

            if (queuedForPage && canPublish) {
                actions.push('Publish is blocked until staged changes for this page are pushed.');
            } else if (!queuedForPage && canPublish) {
                actions.push('This page is ready to publish after review.');
            }

            if (SESSION.role === 'contributor') {
                actions.push('Contributors can stage/save drafts but cannot publish.');
            }

            body.innerHTML = `<small>${actions.join(' | ')}</small>`;
        }

        function getAutosaveKey(pageId) {
            return `${STORAGE_KEYS.AUTOSAVE_PREFIX}${pageId}`;
        }

        function clearAutosaveForPage(pageId) {
            if (!pageId) return;
            const key = getAutosaveKey(pageId);
            localStorage.removeItem(key);
            localStorage.removeItem(`${key}_history`);
            updateAutosaveIndicator();
            updateAutosaveSnapshotsList();
        }

        function updateAutosaveIndicator(message = '') {
            const indicator = document.getElementById('autosave-indicator');
            if (!indicator) return;
            if (message) {
                indicator.textContent = message;
                return;
            }
            if (!CURRENT_PAGE_ID) {
                indicator.textContent = '';
                return;
            }
            const raw = localStorage.getItem(getAutosaveKey(CURRENT_PAGE_ID));
            if (!raw) {
                indicator.textContent = '';
                return;
            }
            try {
                const parsed = JSON.parse(raw);
                if (parsed?.timestamp) {
                    indicator.textContent = `Autosave snapshot: ${new Date(parsed.timestamp).toLocaleTimeString()}`;
                } else {
                    indicator.textContent = 'Autosave snapshot available';
                }
            } catch {
                indicator.textContent = 'Autosave snapshot available';
            }
        }

        function writeAutosaveSnapshot() {
            if (!CURRENT_PAGE_ID || !CURRENT_SCHEMA) return;
            const content = collectCurrentFormContent();
            const key = getAutosaveKey(CURRENT_PAGE_ID);
            let snapshots = [];
            
            // Load existing snapshots
            try {
                const existing = localStorage.getItem(`${key}_history`);
                if (existing) snapshots = JSON.parse(existing) || [];
            } catch (e) {
                snapshots = [];
            }
            
            // Add new snapshot
            snapshots.unshift({
                timestamp: Date.now(),
                content
            });
            
            // Keep only last 5 snapshots to avoid storage bloat
            if (snapshots.length > 5) snapshots = snapshots.slice(0, 5);
            
            // Save history
            localStorage.setItem(`${key}_history`, JSON.stringify(snapshots));
            updateAutosaveIndicator(`Autosaved at ${new Date().toLocaleTimeString()}`);
            updateAutosaveSnapshotsList();
        }

        function scheduleAutosave() {
            if (!CURRENT_PAGE_ID || !CURRENT_SCHEMA) return;
            if (AUTOSAVE_TIMER) clearTimeout(AUTOSAVE_TIMER);
            AUTOSAVE_TIMER = setTimeout(() => {
                writeAutosaveSnapshot();
            }, 1500);
        }

        function maybeRestoreAutosave(pageId) {
            const key = getAutosaveKey(pageId);
            let snapshots = [];
            try {
                const existing = localStorage.getItem(`${key}_history`);
                if (existing) snapshots = JSON.parse(existing) || [];
            } catch (e) {
                snapshots = [];
            }
            
            if (snapshots.length === 0) return false;
            
            const latest = snapshots[0];
            if (!latest?.content || typeof latest.content !== 'object') return false;
            const incoming = JSON.stringify(latest.content || {});
            const current = JSON.stringify(CURRENT_CONTENT || {});
            if (incoming === current) return false;

            const when = latest.timestamp ? new Date(latest.timestamp).toLocaleString() : 'recently';
            if (confirm(`A local autosave snapshot from ${when} was found for this page. Restore it?`)) {
                CURRENT_CONTENT = { ...CURRENT_CONTENT, ...latest.content };
                buildForm();
                markEditorDirty(true);
                showStatus('editor-status', 'Restored local autosave snapshot. Review and save when ready.', 'info');
                updateAutosaveIndicator(`Restored autosave from ${when}`);
                return true;
            }
            return false;
        }

        /**
         * Update the snapshots list display in the autosave snapshots panel
         */
        function updateAutosaveSnapshotsList() {
            const list = document.getElementById('autosave-snapshots-list');
            if (!list || !CURRENT_PAGE_ID) {
                if (list) list.innerHTML = '';
                return;
            }
            
            const key = getAutosaveKey(CURRENT_PAGE_ID);
            let snapshots = [];
            try {
                const existing = localStorage.getItem(`${key}_history`);
                if (existing) snapshots = JSON.parse(existing) || [];
            } catch (e) {
                snapshots = [];
            }
            
            if (snapshots.length === 0) {
                list.innerHTML = '<small style="color: var(--muted-color);">No snapshots yet</small>';
                return;
            }
            
            list.innerHTML = snapshots.map((snap, idx) => {
                const time = new Date(snap.timestamp);
                const timeStr = time.toLocaleTimeString();
                const dateStr = time.toLocaleDateString();
                const isCurrent = idx === 0 ? ' (latest)' : '';
                return `
                    <div style="padding: 0.5rem; background: var(--code-background-color); border-radius: 4px; margin-bottom: 0.4rem; font-size: 0.85rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${dateStr} ${timeStr}${isCurrent}</span>
                            <button type="button" class="secondary" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;" onclick="restoreAutosaveSnapshot(${idx})">Restore</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        /**
         * Restore content from a specific snapshot
         */
        function restoreAutosaveSnapshot(snapshotIdx) {
            if (!CURRENT_PAGE_ID || snapshotIdx < 0) return;
            
            const key = getAutosaveKey(CURRENT_PAGE_ID);
            let snapshots = [];
            try {
                const existing = localStorage.getItem(`${key}_history`);
                if (existing) snapshots = JSON.parse(existing) || [];
            } catch (e) {
                snapshots = [];
            }
            
            if (snapshotIdx >= snapshots.length) {
                showStatus('editor-status', 'Snapshot not found', 'error');
                return;
            }
            
            const snap = snapshots[snapshotIdx];
            const time = new Date(snap.timestamp).toLocaleTimeString();
            
            if (!confirm(`Restore snapshot from ${time}? Your current edits will be replaced.`)) {
                return;
            }
            
            CURRENT_CONTENT = { ...CURRENT_CONTENT, ...snap.content };
            buildForm();
            markEditorDirty(true);
            showStatus('editor-status', `Restored snapshot from ${time}`, 'success');
        }

        async function refreshLinkPageList() {
            const select = document.getElementById('link-page-select');
            if (!select) return;
            select.innerHTML = '<option value="">Loading pages...</option>';
            try {
                const res = await fetch('/api/pages?minimal=true&limit=200', {
                    headers: SESSION?.token ? { Authorization: `Bearer ${SESSION.token}` } : {}
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load pages');
                PAGE_CACHE = (data.pages || []).map(p => p.pageId).filter(Boolean);
                select.innerHTML = '<option value="">Select a page link...</option>' +
                    PAGE_CACHE.map(pageId => `<option value="${escapeHtml(pageId)}">${escapeHtml(pageId)}</option>`).join('');
            } catch (e) {
                select.innerHTML = '<option value="">Unable to load pages</option>';
            }
        }

        function getFocusedEditableField() {
            if (!LAST_FOCUSED_FIELD_ID) {
                showStatus('editor-status', 'Focus a text or textarea field first.', 'error');
                return null;
            }
            const input = document.getElementById(LAST_FOCUSED_FIELD_ID);
            if (!input || typeof input.value !== 'string') {
                showStatus('editor-status', 'Focused field does not support text insertion.', 'error');
                return null;
            }
            return input;
        }

        function insertSnippetAtCursor(input, snippet, cursorOffset = null) {
            const start = input.selectionStart ?? input.value.length;
            const end = input.selectionEnd ?? input.value.length;
            input.value = `${input.value.slice(0, start)}${snippet}${input.value.slice(end)}`;
            input.focus();
            const nextPos = start + (cursorOffset === null ? snippet.length : cursorOffset);
            input.setSelectionRange(nextPos, nextPos);
            markEditorDirty(true);
            scheduleAutosave();
            scheduleAutoStage();
            scheduleUndoSnapshot();
            if (input.id === `field_${PRIMARY_FIELD_KEY}`) {
                updatePrimaryPreview();
            }
        }

        function wrapSelection(prefix, suffix, placeholder) {
            const input = getFocusedEditableField();
            if (!input) return;
            const start = input.selectionStart ?? input.value.length;
            const end = input.selectionEnd ?? input.value.length;
            const selected = input.value.slice(start, end);
            const inner = selected || placeholder;
            const snippet = `${prefix}${inner}${suffix}`;
            insertSnippetAtCursor(input, snippet, prefix.length + inner.length);
        }

        function insertBoldText() {
            wrapSelection('**', '**', 'bold text');
            showStatus('editor-status', 'Inserted bold formatting.', 'success');
        }

        function insertItalicText() {
            wrapSelection('*', '*', 'italic text');
            showStatus('editor-status', 'Inserted italic formatting.', 'success');
        }

        function insertHeadingText() {
            const input = getFocusedEditableField();
            if (!input) return;
            insertSnippetAtCursor(input, '## Heading\n', 3);
            showStatus('editor-status', 'Inserted heading.', 'success');
        }

        function insertBulletList() {
            const input = getFocusedEditableField();
            if (!input) return;
            insertSnippetAtCursor(input, '- Item 1\n- Item 2\n- Item 3\n');
            showStatus('editor-status', 'Inserted bullet list.', 'success');
        }

        function insertNumberedList() {
            const input = getFocusedEditableField();
            if (!input) return;
            insertSnippetAtCursor(input, '1. Item 1\n2. Item 2\n3. Item 3\n');
            showStatus('editor-status', 'Inserted numbered list.', 'success');
        }

        function insertLinkMarkdown() {
            const url = prompt('Enter link URL (example: https://example.com)');
            if (!url) return;
            const label = prompt('Link text', 'Read more') || 'Read more';
            const input = getFocusedEditableField();
            if (!input) return;
            const token = `[${label}](${url})`;
            insertSnippetAtCursor(input, token);
            showStatus('editor-status', 'Inserted link.', 'success');
        }

        function insertImageMarkdownFromUrl() {
            const url = prompt('Enter image URL');
            if (!url) return;
            const alt = prompt('Alt text', 'Image') || 'Image';
            const input = getFocusedEditableField();
            if (!input) return;
            const token = `![${alt}](${url})`;
            insertSnippetAtCursor(input, token);
            showStatus('editor-status', 'Inserted image markdown.', 'success');
        }

        async function uploadAndInsertImageMarkdown() {
            const input = getFocusedEditableField();
            if (!input) return;
            const upload = await selectAndUploadImage();
            if (!upload) return;
            const alt = prompt('Alt text for image', upload.fileName.replace(/\.[^.]+$/, '') || 'Image') || 'Image';
            const token = `![${alt}](${upload.url})`;
            insertSnippetAtCursor(input, token);
            showStatus('editor-status', 'Uploaded image and inserted markdown.', 'success');
        }

        function insertSelectedPageLink() {
            const select = document.getElementById('link-page-select');
            if (!select || !select.value) {
                showStatus('editor-status', 'Select a page link first.', 'error');
                return;
            }
            const input = getFocusedEditableField();
            if (!input) return;
            const token = `[[${select.value}]]`;
            insertSnippetAtCursor(input, token);
            showStatus('editor-status', `Inserted link ${token}`, 'success');
        }

        function collectTextContentStrings(payload) {
            const results = [];
            function walk(node) {
                if (node === null || node === undefined) return;
                if (typeof node === 'string') {
                    results.push(node);
                    return;
                }
                if (Array.isArray(node)) {
                    node.forEach(walk);
                    return;
                }
                if (typeof node === 'object') {
                    Object.values(node).forEach(walk);
                }
            }
            walk(payload);
            return results;
        }

        async function findBacklinks() {
            const statusEl = document.getElementById('backlinks-status');
            const listEl = document.getElementById('backlinks-list');
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            statusEl.textContent = 'Scanning pages for backlinks...';
            listEl.innerHTML = '';

            try {
                if (!PAGE_CACHE.length) {
                    await refreshLinkPageList();
                }
                const candidates = PAGE_CACHE.filter(id => id !== CURRENT_PAGE_ID).slice(0, 120);
                const backlinks = [];
                const needleWiki = `[[${CURRENT_PAGE_ID}]]`;
                const needlePlain = CURRENT_PAGE_ID;

                for (const pageId of candidates) {
                    const res = await fetch(`/data/${pageId}/content.json`, { cache: 'no-store' });
                    if (!res.ok) continue;
                    const content = await res.json();
                    const strings = collectTextContentStrings(content);
                    const linked = strings.some(str => str.includes(needleWiki) || str.includes(needlePlain));
                    if (linked) backlinks.push(pageId);
                }

                statusEl.textContent = `Found ${backlinks.length} backlink(s).`;
                listEl.innerHTML = backlinks.length
                    ? backlinks.map(id => `<div><code>${escapeHtml(id)}</code></div>`).join('')
                    : '<small style="color: var(--muted-color);">No backlinks found.</small>';
            } catch (e) {
                statusEl.textContent = 'Backlink scan failed.';
                listEl.innerHTML = `<small style="color: var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        async function loadRevisionHistory() {
            const statusEl = document.getElementById('revision-status');
            const listEl = document.getElementById('revision-list');
            const diffEl = document.getElementById('revision-diff');
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            statusEl.textContent = 'Loading revision history...';
            listEl.innerHTML = '';
            REVISION_CACHE = [];
            if (diffEl) {
                diffEl.style.display = 'none';
                diffEl.innerHTML = '';
            }

            try {
                const res = await fetch(`/api/history?pageId=${encodeURIComponent(CURRENT_PAGE_ID)}&limit=25`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load history');
                const history = data.history || [];
                REVISION_CACHE = history;
                statusEl.textContent = `${history.length} revision(s) found.`;
                listEl.innerHTML = history.length
                    ? history.map(entry => `
                        <div style="border:1px solid var(--panel-border); border-radius:6px; padding:0.5rem; margin-bottom:0.4rem;">
                            <div><code>${escapeHtml(entry.sha.slice(0, 10))}</code> - ${escapeHtml(entry.message || '(no message)')}</div>
                            <small style="color:var(--muted-color);">${entry.author ? escapeHtml(entry.author) : 'unknown'} | ${entry.date ? new Date(entry.date).toLocaleString() : '-'}</small>
                            <div style="margin-top:0.35rem; display:flex; gap:0.35rem; flex-wrap:wrap;">
                                ${(SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor'))
                                    ? `<button type="button" class="outline" onclick="rollbackToRevision('${escapeHtml(entry.sha)}')">Rollback to This Revision</button>`
                                    : ''}
                                ${entry.url ? `<a href="${escapeHtml(entry.url)}" target="_blank" rel="noopener noreferrer" role="button" class="secondary">Open Commit</a>` : ''}
                            </div>
                        </div>
                    `).join('')
                    : '<small style="color: var(--muted-color);">No revision history available.</small>';
            } catch (e) {
                statusEl.textContent = 'Revision history failed to load.';
                listEl.innerHTML = `<small style="color: var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        async function loadRevisionDiff(fromSha, toSha) {
            const diffEl = document.getElementById('revision-diff');
            if (!diffEl) return;
            diffEl.style.display = 'block';
            diffEl.innerHTML = 'Loading diff...';

            try {
                const query = new URLSearchParams({
                    pageId: CURRENT_PAGE_ID,
                    from: fromSha,
                    to: toSha
                });
                const res = await fetch(`/api/revision-diff?${query.toString()}`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load diff');

                const summary = data.summary || {};
                const rows = Array.isArray(data.diff) ? data.diff : [];
                const html = rows.length
                    ? rows.map(row => {
                        const type = row.type === 'add' ? 'diff-add' : row.type === 'remove' ? 'diff-remove' : 'diff-same';
                        const prefix = row.type === 'add' ? '+' : row.type === 'remove' ? '-' : ' ';
                        return `<div class="diff-line ${type}">${escapeHtml(prefix)} ${escapeHtml(String(row.line ?? ''))}</div>`;
                    }).join('')
                    : '<small style="color: var(--muted-color);">No changes between selected revisions.</small>';

                diffEl.innerHTML = `
                    <div style="margin-bottom:0.5rem;">
                        <strong>Diff ${escapeHtml(fromSha.slice(0, 10))}..${escapeHtml(toSha.slice(0, 10))}</strong><br>
                        <small style="color:var(--muted-color);">
                            +${summary.added || 0} / -${summary.removed || 0} / =${summary.unchanged || 0}
                        </small>
                    </div>
                    ${html}
                `;
            } catch (e) {
                diffEl.innerHTML = `<small style="color: var(--error);">Diff failed: ${escapeHtml(e.message)}</small>`;
            }
        }

        async function openDiffForLatestTwo() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            if (!REVISION_CACHE.length) {
                await loadRevisionHistory();
            }
            if (REVISION_CACHE.length < 2) {
                showStatus('editor-status', 'Need at least 2 revisions to show a diff.', 'error');
                return;
            }
            const toSha = REVISION_CACHE[0].sha;
            const fromSha = REVISION_CACHE[1].sha;
            await loadRevisionDiff(fromSha, toSha);
        }

        async function rollbackToRevision(commitSha) {
            if (!CURRENT_PAGE_ID) return;
            if (!confirm(`Rollback "${CURRENT_PAGE_ID}" to revision ${commitSha.slice(0, 10)}?`)) return;

            showStatus('editor-status', `Rolling back to ${commitSha.slice(0, 10)}...`, 'info');
            try {
                const res = await fetch('/api/rollback', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ pageId: CURRENT_PAGE_ID, commitSha })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Rollback failed');
                clearAutosaveForPage(CURRENT_PAGE_ID);
                showStatus('editor-status', `Rollback complete. Commit: ${data.commit?.slice(0, 10) || 'unknown'}`, 'success');
                await loadEditor();
                await loadRevisionHistory();
            } catch (e) {
                showStatus('editor-status', `Rollback failed: ${e.message}`, 'error');
            }
        }

        async function runScheduledPublishNow() {
            showStatus('editor-status', 'Running scheduled publish...', 'info');
            try {
                const res = await fetch('/api/scheduled-publish', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Scheduled publish failed');

                const publishedCount = Array.isArray(data.published) ? data.published.length : 0;
                const skippedCount = Array.isArray(data.skipped) ? data.skipped.length : 0;
                showStatus('editor-status', `Scheduled publish complete: ${publishedCount} published, ${skippedCount} skipped.`, 'success');

                if (CURRENT_PAGE_ID) {
                    await loadEditor();
                }
            } catch (e) {
                showStatus('editor-status', `Scheduled publish failed: ${e.message}`, 'error');
            }
        }

        function hydrateWorkflowPanelFromContent() {
            const panel = document.getElementById('workflow-status-panel');
            const select = document.getElementById('workflow-status-select');
            const scheduleInput = document.getElementById('workflow-scheduled-for');
            if (!panel || !select) return;
            const meta = CURRENT_CONTENT?._meta || {};
            const status = meta.workflowStatus || meta.status || 'draft';
            select.value = ['draft', 'in_review', 'approved', 'scheduled', 'published'].includes(status) ? status : 'draft';
            if (scheduleInput) {
                if (meta.scheduledFor) {
                    const d = new Date(meta.scheduledFor);
                    if (!Number.isNaN(d.getTime())) {
                        scheduleInput.value = new Date(d.getTime() - d.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                    }
                } else {
                    scheduleInput.value = '';
                }
            }
            panel.innerHTML = `<small>Current workflow: <code>${escapeHtml(status)}</code>${meta.scheduledFor ? ` | Scheduled for ${escapeHtml(meta.scheduledFor)}` : ''}</small>`;
        }

        async function updateWorkflowStatus() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            const select = document.getElementById('workflow-status-select');
            const scheduleInput = document.getElementById('workflow-scheduled-for');
            const status = select?.value || 'draft';
            const scheduledFor = scheduleInput?.value ? new Date(scheduleInput.value).toISOString() : null;

            try {
                const res = await fetch('/api/workflow', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: CURRENT_PAGE_ID,
                        status,
                        scheduledFor: status === 'scheduled' ? scheduledFor : null
                    })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Workflow update failed');
                if (!CURRENT_CONTENT._meta) CURRENT_CONTENT._meta = {};
                CURRENT_CONTENT._meta.workflowStatus = status;
                CURRENT_CONTENT._meta.scheduledFor = status === 'scheduled' ? scheduledFor : undefined;
                hydrateWorkflowPanelFromContent();
                showStatus('editor-status', `Workflow updated to ${status}`, 'success');
                await loadRevisionHistory();
            } catch (e) {
                showStatus('editor-status', `Workflow update failed: ${e.message}`, 'error');
            }
        }

        async function loadWatchActivity() {
            const panel = document.getElementById('watch-activity-list');
            const toggleBtn = document.getElementById('watch-toggle-btn');
            if (!panel || !toggleBtn) return;
            try {
                const res = await fetch('/api/watch', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load watchlist');
                WATCHED_PAGES = data.watchedPages || [];
                const isWatching = CURRENT_PAGE_ID && WATCHED_PAGES.includes(CURRENT_PAGE_ID);
                toggleBtn.textContent = isWatching ? 'Unwatch Page' : 'Watch Page';

                const recent = data.recent || [];
                panel.innerHTML = recent.length
                    ? recent.slice(0, 10).map(item => `
                        <div><small><code>${escapeHtml(item.pageId || '-')}</code> ${escapeHtml(item.action || 'activity')} by ${escapeHtml(item.username || 'unknown')} at ${item.timestamp ? new Date(item.timestamp).toLocaleString() : '-'}</small></div>
                    `).join('')
                    : '<small style="color:var(--muted-color);">No recent watched-page activity.</small>';
            } catch (e) {
                panel.innerHTML = `<small style="color:var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        async function toggleWatchPage() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first.', 'error');
                return;
            }
            const watching = WATCHED_PAGES.includes(CURRENT_PAGE_ID);
            try {
                const res = await fetch('/api/watch', {
                    method: watching ? 'DELETE' : 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ pageId: CURRENT_PAGE_ID })
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Watch update failed');
                await loadWatchActivity();
                showStatus('editor-status', watching ? 'Page removed from watchlist' : 'Page added to watchlist', 'success');
            } catch (e) {
                showStatus('editor-status', `Watch update failed: ${e.message}`, 'error');
            }
        }

        async function loadReusableBlocks() {
            const select = document.getElementById('block-select');
            const status = document.getElementById('blocks-status');
            if (!select || !status) return;
            select.innerHTML = '<option value="">Loading blocks...</option>';
            try {
                const res = await fetch('/api/blocks', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to load blocks');
                BLOCK_CACHE = data.blocks || [];
                select.innerHTML = '<option value="">Select a reusable block...</option>' +
                    BLOCK_CACHE.map(item => `<option value="${escapeHtml(item.id)}">${escapeHtml(item.label)}</option>`).join('');
                status.innerHTML = `<small>Loaded ${BLOCK_CACHE.length} block(s) from ${escapeHtml(data.source || 'unknown source')}.</small>`;
            } catch (e) {
                select.innerHTML = '<option value="">Unable to load blocks</option>';
                status.innerHTML = `<small style="color:var(--error);">${escapeHtml(e.message)}</small>`;
            }
        }

        function insertSelectedBlock() {
            const select = document.getElementById('block-select');
            if (!select || !select.value) {
                showStatus('editor-status', 'Select a block first.', 'error');
                return;
            }
            const block = BLOCK_CACHE.find(item => item.id === select.value);
            if (!block) {
                showStatus('editor-status', 'Block not found in cache.', 'error');
                return;
            }
            const input = getFocusedEditableField();
            if (!input) return;
            const snippet = `\n${block.content}\n`;
            insertSnippetAtCursor(input, snippet);
            showStatus('editor-status', `Inserted block "${block.label}"`, 'success');
        }

        // =================================================================
        // AUTHENTICATION
        // =================================================================

        async function checkInitialSetupStatus() {
            try {
                const status = await refreshOnboardingStatus();
                const data = status.setupData;
                const resOk = status.setupOk;

                if (resOk && data.setupRequired) {
                    showSetup();

                    if (!data.setupTokenConfigured) {
                        showError('setup-error', [
                            'Initial setup is required, but SETUP_TOKEN is not configured.',
                            'Cloudflare Pages -> Settings -> Environment variables -> add SETUP_TOKEN as a Secret, then redeploy.'
                        ].join('\n'));
                    }
                } else {
                    showLogin();
                }
            } catch (e) {
                // Fall back to login mode if setup status check fails.
                showLogin();
            }
        }

        function showLogin() {
            document.getElementById('onboarding-guide').classList.remove('hidden');
            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('login-section').classList.remove('hidden');
        }

        function showSetup() {
            document.getElementById('onboarding-guide').classList.remove('hidden');
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('setup-section').classList.remove('hidden');
        }

        function showSetupCheckView() {
            document.getElementById('setup-check-view').classList.remove('hidden');
            document.getElementById('onboarding-guide').classList.remove('hidden');
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('app-section').classList.add('hidden');
        }

        function startOnboardingMonitor() {
            if (ONBOARDING_TIMER) clearInterval(ONBOARDING_TIMER);
            refreshOnboardingStatus();
            ONBOARDING_TIMER = setInterval(refreshOnboardingStatus, 30000);
        }

        function stopOnboardingMonitor() {
            if (ONBOARDING_TIMER) {
                clearInterval(ONBOARDING_TIMER);
                ONBOARDING_TIMER = null;
            }
        }

        function openSetupCheckView() {
            window.open('/admin.html?view=setup-check', '_blank', 'noopener,noreferrer');
        }

        function prefillRepoSuggestion() {
            const ownerInput = document.getElementById('repo-owner-input');
            const repoInput = document.getElementById('repo-name-input');
            if (!ownerInput || !repoInput) return;

            const host = window.location.hostname || '';
            const firstLabel = host.split('.')[0] || '';
            let repoGuess = firstLabel
                .replace(/-pages$/, '')
                .replace(/[^a-zA-Z0-9._-]/g, '');
            if (!repoGuess || repoGuess === 'www' || repoGuess === 'localhost') {
                repoGuess = 'your-loon-repo';
            }

            repoInput.value = repoGuess;
            if (!ownerInput.value) ownerInput.value = 'your-github-owner';
        }

        function getRepoSuggestion() {
            const owner = (document.getElementById('repo-owner-input')?.value || '').trim();
            const repo = (document.getElementById('repo-name-input')?.value || '').trim();
            if (!owner || !repo) return null;
            return `${owner}/${repo}`;
        }

        function getPasskeyEnvSuggestion() {
            const host = window.location.hostname || '';
            const isLocal = host === 'localhost' || host === '127.0.0.1';
            const protocol = isLocal ? 'http:' : (window.location.protocol || 'https:');
            const origin = `${protocol}//${host || 'localhost'}`;
            return {
                rpId: host || 'localhost',
                rpOrigin: origin
            };
        }

        async function checkPasskeyServerConfig() {
            try {
                const res = await fetch('/api/health', { cache: 'no-store' });
                const data = await res.json().catch(() => null);
                if (!data) {
                    PASSKEY_ENV_READY = null;
                    return null;
                }
                const checks = data?.checks || {};
                const ready = !!checks.passkeys_ready;
                PASSKEY_ENV_READY = ready;
                return {
                    ready,
                    hasRpId: !!checks.passkeys_rp_id,
                    hasRpOrigin: !!checks.passkeys_rp_origin,
                    healthStatus: data?.status || null,
                    httpStatus: res.status
                };
            } catch {
                PASSKEY_ENV_READY = null;
                return null;
            }
        }

        function showPasskeyOptionalStatus(config) {
            const passkeyEnv = getPasskeyEnvSuggestion();
            const registerBtn = document.getElementById('register-passkey-btn');
            if (registerBtn) {
                registerBtn.disabled = config?.ready === false;
            }

            if (config?.ready) {
                showStatus('passkey-status', 'Passkeys are configured and optional. You can keep using password login, or register a passkey anytime.', 'info');
                return;
            }

            if (config?.ready === false) {
                const msg = [
                    'Passkeys are optional and currently not configured for this deployment.',
                    `To enable later: set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare env vars, then redeploy.`,
                    'Password login continues to work normally.'
                ].join('\n');
                showStatus('passkey-status', msg, 'info');
            }
        }

        async function copyGithubRepoSuggestion() {
            const suggestion = getRepoSuggestion();
            if (!suggestion) {
                alert('Enter both GitHub owner and repository name first.');
                return;
            }
            try {
                await navigator.clipboard.writeText(suggestion);
                alert(`Copied: ${suggestion}`);
            } catch {
                alert(suggestion);
            }
        }

        function generateSecureToken(length = 48) {
            const bytes = new Uint8Array(length);
            crypto.getRandomValues(bytes);
            return Array.from(bytes, b => (b % 36).toString(36)).join('');
        }

        async function generateAndCopySetupToken() {
            const token = generateSecureToken(64);
            try {
                await navigator.clipboard.writeText(token);
                alert('Generated and copied SETUP_TOKEN.');
            } catch {
                alert(token);
            }
        }

        async function copyEnvTemplate() {
            const repo = getRepoSuggestion() || 'owner/repo';
            const setupToken = generateSecureToken(64);
            const passkeyEnv = getPasskeyEnvSuggestion();
            const template = [
                `GITHUB_REPO=${repo}`,
                'GITHUB_TOKEN=<set-as-secret>',
                `SETUP_TOKEN=${setupToken}`,
                `RP_ID=${passkeyEnv.rpId}`,
                `RP_ORIGIN=${passkeyEnv.rpOrigin}`,
                'ENVIRONMENT=production'
            ].join('\n');
            try {
                await navigator.clipboard.writeText(template);
                alert('Copied env template.');
            } catch {
                alert(template);
            }
        }

        function hydrateLastReadinessStamp() {
            const el = document.getElementById('onboarding-last-verified');
            if (!el) return;
            const raw = localStorage.getItem(STORAGE_KEYS.LAST_READINESS);
            if (!raw) return;
            try {
                const parsed = JSON.parse(raw);
                if (parsed?.timestamp && parsed?.status) {
                    el.textContent = `Last verified: ${new Date(parsed.timestamp).toLocaleString()} (${parsed.status})`;
                }
            } catch {
                // no-op
            }
        }

        function storeLastReadiness(statusLabel) {
            const payload = {
                timestamp: Date.now(),
                status: statusLabel
            };
            localStorage.setItem(STORAGE_KEYS.LAST_READINESS, JSON.stringify(payload));
            hydrateLastReadinessStamp();
        }

        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

        async function fetchJsonWithRetry(url, options = {}, config = {}) {
            const retries = typeof config.retries === 'number' ? config.retries : 2;
            const baseDelayMs = typeof config.baseDelayMs === 'number' ? config.baseDelayMs : 1200;
            const onRetry = typeof config.onRetry === 'function' ? config.onRetry : null;
            let lastError = null;

            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    const res = await fetch(url, options);
                    let data = {};
                    try {
                        data = await res.json();
                    } catch {
                        data = {};
                    }

                    const isTransient = !res.ok && res.status >= 500;
                    if (isTransient && attempt < retries) {
                        if (onRetry) onRetry(attempt + 1, retries + 1, 'server');
                        await sleep(baseDelayMs * (attempt + 1));
                        continue;
                    }

                    return { res, data };
                } catch (err) {
                    lastError = err;
                    if (attempt < retries) {
                        if (onRetry) onRetry(attempt + 1, retries + 1, 'network');
                        await sleep(baseDelayMs * (attempt + 1));
                        continue;
                    }
                }
            }

            throw lastError || new Error('Request failed');
        }

        function renderCheckItem(label, detail, state, fix = null) {
            const chipClass = state === 'pass'
                ? 'check-pass'
                : state === 'fail'
                    ? 'check-fail'
                    : state === 'warn'
                        ? 'check-warn'
                        : 'check-pending';

            const chipLabel = state === 'pass'
                ? 'Ready'
                : state === 'fail'
                    ? 'Required'
                    : state === 'warn'
                        ? 'Action'
                        : 'Checking';

            const fixHtml = fix && state !== 'pass'
                ? `<div style="margin-top:0.35rem;"><a href="${escapeHtml(fix.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(fix.label)}</a></div>`
                : '';

            return `
                <div class="onboarding-item">
                    <div>
                        <strong>${escapeHtml(label)}</strong>
                        <small>${escapeHtml(detail)}</small>
                        ${fixHtml}
                    </div>
                    <span class="check-chip ${chipClass}">${chipLabel}</span>
                </div>
            `;
        }

        function renderOnboarding(status) {
            const summaryEl = document.getElementById('onboarding-summary');
            const checksEl = document.getElementById('onboarding-checks');
            const nextEl = document.getElementById('onboarding-next');
            const stepsEl = document.getElementById('onboarding-steps');

            const checks = status.healthData?.checks || {};
            const setupRequired = !!status.setupData?.setupRequired;
            const setupTokenConfigured = !!status.setupData?.setupTokenConfigured;

            const rows = [
                renderCheckItem(
                    'KV Binding',
                    checks.kv_database ? 'KV binding is available to Functions.' : 'Add LOON_DB (preferred) or KV binding in Cloudflare Pages.',
                    checks.kv_database ? 'pass' : 'fail',
                    { label: 'Open Cloudflare Dashboard', url: 'https://dash.cloudflare.com/' }
                ),
                renderCheckItem(
                    'GitHub Repository',
                    checks.github_repo ? 'GITHUB_REPO is configured.' : 'Set GITHUB_REPO as owner/repo in Cloudflare Pages env vars.',
                    checks.github_repo ? 'pass' : 'fail',
                    { label: 'Open Cloudflare Env Vars', url: 'https://dash.cloudflare.com/' }
                ),
                renderCheckItem(
                    'GitHub Token',
                    checks.github_token ? 'GITHUB_TOKEN is configured.' : 'Set GITHUB_TOKEN Secret with Contents read/write permission.',
                    checks.github_token ? 'pass' : 'fail',
                    { label: 'Create GitHub Token', url: 'https://github.com/settings/personal-access-tokens/new' }
                ),
                renderCheckItem(
                    'Setup Token',
                    setupTokenConfigured ? 'SETUP_TOKEN is configured for first admin setup.' : 'Add SETUP_TOKEN as a Secret in Cloudflare Pages.',
                    setupTokenConfigured ? 'pass' : 'warn',
                    { label: 'Open Cloudflare Env Vars', url: 'https://dash.cloudflare.com/' }
                ),
                renderCheckItem(
                    'Passkeys (RP_ID / RP_ORIGIN)',
                    checks.passkeys_ready
                        ? `Passkeys are configured (${checks.passkeys_rp_id ? 'RP_ID' : ''}${checks.passkeys_rp_id && checks.passkeys_rp_origin ? ', ' : ''}${checks.passkeys_rp_origin ? 'RP_ORIGIN' : ''}).`
                        : 'Set RP_ID and RP_ORIGIN in Cloudflare env vars to enable passkeys in production.',
                    checks.passkeys_ready ? 'pass' : 'warn',
                    { label: 'Open Cloudflare Env Vars', url: 'https://dash.cloudflare.com/' }
                )
            ];
            checksEl.innerHTML = rows.join('');

            const allCoreReady = !!(checks.kv_database && checks.github_repo && checks.github_token);
            if (allCoreReady && (!setupRequired || setupTokenConfigured)) {
                summaryEl.className = 'status-message status-success';
                summaryEl.textContent = setupRequired
                    ? 'System is ready. Complete first admin setup below.'
                    : 'System is ready. You can log in normally.';
                nextEl.classList.add('hidden');
            } else {
                summaryEl.className = 'status-message status-info';
                summaryEl.textContent = 'Some required settings still need attention before setup/login succeeds.';
                nextEl.className = 'status-message status-info';
                if (!checks.kv_database) {
                    nextEl.textContent = 'KV binding is missing. Add LOON_DB in Cloudflare Pages -> Settings -> Bindings. If controls are grayed out, remove kv_namespaces from wrangler.toml, redeploy, then add binding in dashboard.';
                } else {
                    nextEl.textContent = 'Make updates in Cloudflare Pages Settings, then click "Refresh Checks".';
                }
                nextEl.classList.remove('hidden');
            }

            const steps = [];
            steps.push(`<li>${allCoreReady ? 'Step 1 complete: core Cloudflare + GitHub config is ready.' : 'Step 1: In Cloudflare Pages, configure KV binding and required env vars.'}</li>`);
            if (setupRequired) {
                steps.push(`<li>${setupTokenConfigured ? 'Step 2: Create first admin in the Initial Setup form on this page.' : 'Step 2: Add SETUP_TOKEN Secret in Cloudflare, redeploy, then return here.'}</li>`);
                steps.push('<li>Step 3: Log in as admin, save a test page, then rotate/remove SETUP_TOKEN.</li>');
                steps.push(`<li>${checks.passkeys_ready ? 'Step 4 complete: passkeys are ready for registration in Account tab.' : `Step 4 (recommended): set RP_ID=${escapeHtml(getPasskeyEnvSuggestion().rpId)} and RP_ORIGIN=${escapeHtml(getPasskeyEnvSuggestion().rpOrigin)} in Cloudflare, redeploy, then register a passkey in Account tab.`}</li>`);
            } else {
                steps.push('<li>Step 2 complete: initial admin already exists.</li>');
                steps.push('<li>Step 3: Log in and continue normal operations from LOON admin.</li>');
                steps.push(`<li>${checks.passkeys_ready ? 'Step 4 complete: passkeys are ready for registration in Account tab.' : `Step 4 (recommended): set RP_ID=${escapeHtml(getPasskeyEnvSuggestion().rpId)} and RP_ORIGIN=${escapeHtml(getPasskeyEnvSuggestion().rpOrigin)} in Cloudflare, redeploy, then register a passkey in Account tab.`}</li>`);
            }
            stepsEl.innerHTML = steps.join('');
        }

        async function refreshOnboardingStatus() {
            const result = {
                healthOk: false,
                setupOk: false,
                healthData: null,
                setupData: null
            };

            try {
                const [healthPack, setupPack] = await Promise.all([
                    fetchJsonWithRetry('/api/health', { cache: 'no-store' }, { retries: 1, baseDelayMs: 900 }),
                    fetchJsonWithRetry('/api/setup', { cache: 'no-store' }, { retries: 1, baseDelayMs: 900 })
                ]);

                result.healthOk = healthPack.res.ok;
                result.setupOk = setupPack.res.ok;
                result.healthData = healthPack.data;
                result.setupData = setupPack.data;
            } catch (err) {
                const summaryEl = document.getElementById('onboarding-summary');
                summaryEl.className = 'status-message status-error';
                summaryEl.textContent = 'Unable to reach setup/health endpoints. Verify the deployment URL and redeploy if needed.';
                storeLastReadiness('failed');
                return result;
            }

            renderOnboarding(result);
            const overall = result.healthData?.status === 'ok' ? 'healthy' : 'degraded';
            storeLastReadiness(overall);
            return result;
        }

        async function runFullReadinessCheck() {
            const resultEl = document.getElementById('full-readiness-result');
            resultEl.className = 'status-message status-info';
            resultEl.textContent = 'Running full readiness check...';
            resultEl.classList.remove('hidden');

            const lines = [];
            const base = await refreshOnboardingStatus();
            const checks = base.healthData?.checks || {};
            lines.push(`${checks.kv_database ? 'PASS' : 'FAIL'} KV binding`);
            lines.push(`${checks.github_repo ? 'PASS' : 'FAIL'} GITHUB_REPO configured`);
            lines.push(`${checks.github_token ? 'PASS' : 'FAIL'} GITHUB_TOKEN configured`);
            lines.push(`${base.setupData?.setupTokenConfigured ? 'PASS' : 'WARN'} SETUP_TOKEN configured`);
            lines.push(`${checks.passkeys_ready ? 'PASS' : 'WARN'} Passkeys RP_ID/RP_ORIGIN configured`);
            lines.push(`${base.setupData?.setupRequired ? 'ACTION' : 'PASS'} Initial setup ${base.setupData?.setupRequired ? 'required' : 'already complete'}`);

            if (SESSION?.token) {
                try {
                    const authPack = await fetchJsonWithRetry('/api/auth', {
                        headers: { Authorization: `Bearer ${SESSION.token}` },
                        cache: 'no-store'
                    }, { retries: 1, baseDelayMs: 800 });
                    lines.push(`${authPack.res.ok ? 'PASS' : 'FAIL'} Session validation`);
                } catch {
                    lines.push('FAIL Session validation');
                }

                try {
                    const pagesPack = await fetchJsonWithRetry('/api/pages?minimal=true&limit=1', {
                        headers: { Authorization: `Bearer ${SESSION.token}` },
                        cache: 'no-store'
                    }, { retries: 1, baseDelayMs: 800 });
                    lines.push(`${pagesPack.res.ok ? 'PASS' : 'FAIL'} GitHub content read path`);
                } catch {
                    lines.push('FAIL GitHub content read path');
                }
            } else {
                lines.push('INFO Log in as admin to include session/content-path checks.');
            }

            const failures = lines.filter(line => line.startsWith('FAIL')).length;
            if (failures > 0) {
                resultEl.className = 'status-message status-error';
            } else {
                resultEl.className = 'status-message status-success';
            }
            resultEl.textContent = lines.join('\n');
        }

        function openCloudflareSetupHelp() {
            const message = [
                'Cloudflare Pages setup path:',
                '1) Project -> Settings -> Bindings -> KV namespace bindings',
                '2) Project -> Settings -> Environment variables (Production)',
                '3) Deployments -> Retry deployment'
            ].join('\n');
            alert(message);
        }

        async function completeInitialSetup() {
            const setupToken = document.getElementById('setup-token').value;
            const username = document.getElementById('setup-username').value.trim();
            const password = document.getElementById('setup-password').value;
            const confirmPassword = document.getElementById('setup-password-confirm').value;

            if (!setupToken || !username || !password || !confirmPassword) {
                showError('setup-error', 'All setup fields are required');
                return;
            }

            if (password.length < 8) {
                showError('setup-error', 'Password must be at least 8 characters');
                return;
            }

            if (password !== confirmPassword) {
                showError('setup-error', 'Passwords do not match');
                return;
            }

            hideError('setup-error');

            try {
                const { res, data } = await fetchJsonWithRetry('/api/setup', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ setupToken, username, password })
                }, {
                    retries: 2,
                    baseDelayMs: 1200,
                    onRetry: (attempt, total, kind) => {
                        showStatus('setup-error', `Temporary ${kind} issue during setup. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });
                if (!res.ok) {
                    throw new Error(data.error || 'Initial setup failed');
                }

                SESSION = {
                    token: data.token,
                    username: data.username,
                    role: data.role,
                    expiresAt: Date.now() + (data.expiresIn * 1000)
                };

                sessionStorage.setItem(STORAGE_KEYS.POST_SETUP_NOTICE, '1');
                sessionStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                showApp();
            } catch (e) {
                showError('setup-error', mapSetupError(e.message));
            }
        }
        
        /**
         * Verify saved session is still valid server-side
         */
        async function verifySession() {
            if (!SESSION || !SESSION.token) return;
            
            try {
                // Use a lightweight check - try to list users (will fail for non-admins, but that's ok)
                // If we get 401, session is invalid
                const res = await fetch('/api/health');
                // Health check doesn't validate session, so we'll verify on first actual request
                // This is handled by handleSessionError
            } catch (e) {
                // Network error, don't logout - might be offline.
            }
        }
        
        /**
         * Handle session errors (401) - logout and redirect to login
         */
        function handleSessionError(error) {
            if (error.message.includes('session') || error.message.includes('expired') || error.message.includes('401')) {
                alert('Your session has expired. Please log in again.');
                logout();
                return true;
            }
            return false;
        }
        
        async function login() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const remember = document.getElementById('remember-me').checked;

            if (!username || !password) {
                showError('login-error', 'Username and password required');
                return;
            }

            hideError('login-error');

            try {
                const { res, data } = await fetchJsonWithRetry('/api/auth', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                }, {
                    retries: 2,
                    baseDelayMs: 1200,
                    onRetry: (attempt, total, kind) => {
                        showStatus('login-error', `Temporary ${kind} issue during login. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });

                if (!res.ok) {
                    throw new Error(data.error || 'Login failed');
                }

                SESSION = {
                    token: data.token,
                    username: data.username,
                    role: data.role,
                    expiresAt: Date.now() + (data.expiresIn * 1000)
                };

                if (remember) {
                    localStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                } else {
                    sessionStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                }

                showApp();

            } catch (e) {
                showError('login-error', mapLoginError(e.message));
            }
        }

        async function logout() {
            if (SESSION && SESSION.token) {
                try {
                    await fetch('/api/auth', {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${SESSION.token}` }
                    });
                } catch (e) {
                    // Ignore logout errors
                }
            }

            SESSION = null;
            CURRENT_SCHEMA = null;
            CURRENT_CONTENT = null;
            CURRENT_PAGE_ID = null;
            PENDING_CHANGES = [];
            markEditorDirty(false);
            if (AUTO_STAGE_TIMER) {
                clearTimeout(AUTO_STAGE_TIMER);
                AUTO_STAGE_TIMER = null;
            }
            if (AUTOSAVE_TIMER) {
                clearTimeout(AUTOSAVE_TIMER);
                AUTOSAVE_TIMER = null;
            }
            LAST_FOCUSED_FIELD_ID = null;

            localStorage.removeItem(STORAGE_KEYS.SESSION);
            localStorage.removeItem(STORAGE_KEYS.PENDING_CHANGES);
            sessionStorage.removeItem(STORAGE_KEYS.SESSION);

            location.reload();
        }

        function showApp() {
            stopOnboardingMonitor();
            document.getElementById('onboarding-guide').classList.add('hidden');
            document.getElementById('login-section').classList.add('hidden');
            document.getElementById('setup-section').classList.add('hidden');
            document.getElementById('app-section').classList.remove('hidden');

            document.getElementById('display-username').textContent = SESSION.username;
            
            const roleBadge = document.getElementById('display-role');
            roleBadge.textContent = SESSION.role;
            roleBadge.className = `role-badge role-${SESSION.role}`;

            // Show admin tabs if admin
            if (SESSION.role === 'admin') {
                document.getElementById('tab-users').classList.remove('hidden');
                document.getElementById('tab-sessions').classList.remove('hidden');
                document.getElementById('tab-audit').classList.remove('hidden');
                document.getElementById('tab-health').classList.remove('hidden');
            }

            // Apply role-based UI tailoring
            applyRoleBasedUI();

            if (sessionStorage.getItem(STORAGE_KEYS.POST_SETUP_NOTICE) === '1') {
                document.getElementById('post-setup-banner').classList.remove('hidden');
            }

            updateBatchUi();
            maybeShowFirstPageWizard();
            updateLocalModeBanner();
        }

        // =================================================================
        // TAB NAVIGATION
        // =================================================================
        function switchTab(tab) {
            // Hide all views
            document.querySelectorAll('[id^="view-"]').forEach(el => el.classList.add('hidden'));
            
            // Deactivate all tabs
            document.querySelectorAll('.tab-nav button').forEach(btn => btn.classList.remove('active'));
            
            // Show selected view and activate tab
            document.getElementById(`view-${tab}`).classList.remove('hidden');
            document.getElementById(`tab-${tab}`).classList.add('active');

            // Load data for tab
            if (tab === 'users') {
                loadUsers();
            } else if (tab === 'sessions') {
                loadSessions();
            } else if (tab === 'account') {
                loadAccountInfo();
            }
        }

        /**
         * Apply role-based UI tailoring
         * Hides/shows features based on user role
         */
        function applyRoleBasedUI() {
            const role = SESSION?.role || 'contributor';
            const isAdmin = role === 'admin';
            const isEditor = role === 'editor';
            const isContributor = role === 'contributor';

            // Contributors can't use bulk actions (only editors and admins)
            const bulkActionsPanel = document.getElementById('bulk-actions-panel');
            if (bulkActionsPanel) {
                bulkActionsPanel.style.display = (isAdmin || isEditor) ? 'block' : 'none';
            }

            // Contributors can't see/select bulk page checkboxes
            const pageCheckboxes = document.querySelectorAll('input[type="checkbox"][onchange*="togglePageSelection"]');
            pageCheckboxes.forEach(cb => {
                cb.style.display = (isAdmin || isEditor) ? 'inline-block' : 'none';
            });

            // Disable workflow status for contributors
            const workflowStatus = document.getElementById('workflow-status-select');
            if (workflowStatus && isContributor) {
                workflowStatus.disabled = true;
                workflowStatus.style.opacity = '0.6';
                workflowStatus.style.cursor = 'not-allowed';
                workflowStatus.title = 'Admin or Editor only';
            }

            // Hide advanced publishing options for contributors
            if (isContributor) {
                // Hide schedule publish button if it exists
                const scheduleBtn = document.querySelector('[onclick*="schedulePublish"], [id*="schedule"]');
                if (scheduleBtn) scheduleBtn.style.display = 'none';

                // Mark editor as simplified for assistive tech
                const editor = document.getElementById('editor-container');
                if (editor) editor.setAttribute('data-role', 'contributor');
            }
        }

        // =================================================================
        // ACCOUNT MANAGEMENT
        // =================================================================
        async function changePassword() {
            const currentPassword = document.getElementById('current-password').value;
            const newPassword = document.getElementById('new-password-self').value;
            const confirmPassword = document.getElementById('confirm-password').value;

            // Validation
            if (!currentPassword || !newPassword || !confirmPassword) {
                showStatus('password-change-status', 'All fields are required', 'error');
                return;
            }

            if (newPassword.length < 8) {
                showStatus('password-change-status', 'New password must be at least 8 characters', 'error');
                return;
            }

            if (newPassword !== confirmPassword) {
                showStatus('password-change-status', 'New passwords do not match', 'error');
                return;
            }

            showStatus('password-change-status', 'Changing password...', 'info');

            try {
                const res = await fetch('/api/auth', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        currentPassword: currentPassword,
                        newPassword: newPassword
                    })
                });

                const data = await res.json();

                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error(data.error || 'Unauthorized'))) {
                        return;
                    }
                    throw new Error(data.error || 'Password change failed');
                }

                // Clear form
                document.getElementById('current-password').value = '';
                document.getElementById('new-password-self').value = '';
                document.getElementById('confirm-password').value = '';

                showStatus('password-change-status', 'Password changed successfully', 'success');

            } catch (e) {
                showStatus('password-change-status', e.message, 'error');
            }
        }

        // =================================================================
        // PASSKEY MANAGEMENT
        // =================================================================
        
        /**
         * Check if browser supports WebAuthn
         */
        function checkPasskeySupport() {
            const supported = window.PublicKeyCredential !== undefined && 
                             navigator.credentials !== undefined;
            
            if (!supported) {
                document.getElementById('passkey-browser-check').classList.remove('hidden');
            }
            
            return supported;
        }
        
        /**
         * Load account info and passkeys
         */
        async function loadAccountInfo() {
            if (SESSION) {
                document.getElementById('account-username').textContent = SESSION.username;
                document.getElementById('account-role').textContent = SESSION.role;
                
                // Check passkey support
                checkPasskeySupport();

                const passkeyConfig = await checkPasskeyServerConfig();
                showPasskeyOptionalStatus(passkeyConfig);
                
                // Load passkeys
                await loadPasskeys();
            }
        }
        
        /**
         * Load user's passkeys
         */
        async function loadPasskeys() {
            if (!checkPasskeySupport()) return;
            
            try {
                const res = await fetch('/api/passkeys', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to load passkeys');
                }
                
                const data = await res.json();
                displayPasskeys(data.passkeys || []);
                
            } catch (e) {
                console.error('Failed to load passkeys:', e);
            }
        }
        
        /**
         * Display passkeys list
         */
        function displayPasskeys(passkeys) {
            const container = document.getElementById('passkeys-list-container');
            
            if (passkeys.length === 0) {
                container.innerHTML = '<p style="color: var(--muted-color); font-style: italic;">No passkeys registered</p>';
                return;
            }
            
            container.innerHTML = passkeys.map(pk => `
                <div style="padding: 1rem; background: var(--code-background-color); border-radius: 8px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 1;">
                        <strong>${escapeHtml(pk.name || 'Unnamed Passkey')}</strong><br>
                        <small style="color: var(--muted-color);">
                            Created: ${new Date(pk.created).toLocaleDateString()} | 
                            Last used: ${pk.lastUsed ? new Date(pk.lastUsed).toLocaleDateString() : 'Never'}
                        </small>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="renamePasskey('${pk.id}')" class="outline" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Rename</button>
                        <button onclick="deletePasskey('${pk.id}')" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Delete</button>
                    </div>
                </div>
            `).join('');
        }
        
        /**
         * Login with passkey
         */
        async function loginWithPasskey() {
            if (!checkPasskeySupport()) {
                showError('login-error', 'Passkeys not supported in this browser');
                return;
            }

            const passkeyConfig = await checkPasskeyServerConfig();
            if (passkeyConfig?.ready === false) {
                const passkeyEnv = getPasskeyEnvSuggestion();
                showError('login-error', `Passkeys are not configured for this deployment yet. Set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare, then redeploy.`);
                return;
            }
            
            hideError('login-error');
            
            try {
                // Step 1: Get authentication challenge
                const challengePack = await fetchJsonWithRetry('/api/passkeys/auth/challenge', {
                    cache: 'no-store'
                }, {
                    retries: 2,
                    baseDelayMs: 1000,
                    onRetry: (attempt, total, kind) => {
                        showStatus('login-error', `Temporary ${kind} issue during passkey challenge. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });

                if (!challengePack.res.ok) {
                    throw new Error('Failed to get authentication challenge');
                }

                const challengeData = challengePack.data;
                const allowCredentials = (challengeData.allowCredentials || []).map(cred => ({
                    id: base64urlToBuffer(cred.id),
                    type: 'public-key',
                    transports: cred.transports
                }));
                
                // Step 2: Get assertion from authenticator
                const credential = await navigator.credentials.get({
                    publicKey: {
                        challenge: base64urlToBuffer(challengeData.challenge),
                        timeout: challengeData.timeout || 60000,
                        rpId: challengeData.rpId || window.location.hostname,
                        userVerification: challengeData.userVerification || 'preferred',
                        ...(allowCredentials.length > 0 ? { allowCredentials } : {})
                    }
                });
                
                if (!credential) {
                    throw new Error('No credential returned');
                }
                
                // Step 3: Verify assertion
                const verifyPack = await fetchJsonWithRetry('/api/passkeys/auth/verify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        assertionResponse: {
                            id: bufferToBase64url(credential.rawId),
                            response: {
                                authenticatorData: bufferToBase64url(credential.response.authenticatorData),
                                clientDataJSON: bufferToBase64url(credential.response.clientDataJSON),
                                signature: bufferToBase64url(credential.response.signature),
                                userHandle: credential.response.userHandle ? 
                                    bufferToBase64url(credential.response.userHandle) : undefined
                            }
                        },
                        challengeToken: challengeData.challengeToken
                    })
                }, {
                    retries: 2,
                    baseDelayMs: 1000,
                    onRetry: (attempt, total, kind) => {
                        showStatus('login-error', `Temporary ${kind} issue during passkey verification. Retrying (${attempt}/${total - 1})...`, 'info');
                    }
                });

                const verifyData = verifyPack.data;

                if (!verifyPack.res.ok) {
                    throw new Error(verifyData.error || 'Authentication failed');
                }
                
                // Step 4: Save session
                SESSION = {
                    token: verifyData.token,
                    username: verifyData.username,
                    role: verifyData.role,
                    expiresAt: Date.now() + (verifyData.expiresIn * 1000)
                };
                
                const remember = document.getElementById('remember-me').checked;
                if (remember) {
                    localStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                } else {
                    sessionStorage.setItem(STORAGE_KEYS.SESSION, JSON.stringify(SESSION));
                }
                
                showApp();
                
            } catch (e) {
                console.error('Passkey login failed:', e);
                showError('login-error', mapLoginError(e.message || 'Passkey login failed'));
            }
        }
        
        /**
         * Register new passkey
         */
        async function registerPasskey() {
            if (!checkPasskeySupport()) {
                showStatus('passkey-status', 'Passkeys not supported in this browser', 'error');
                return;
            }

            const passkeyConfig = await checkPasskeyServerConfig();
            if (passkeyConfig?.ready === false) {
                const passkeyEnv = getPasskeyEnvSuggestion();
                showStatus('passkey-status', `Passkeys are optional and not configured yet. Set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare, then redeploy to enable registration.`, 'error');
                return;
            }
            
            showStatus('passkey-status', 'Starting passkey registration...', 'info');
            
            try {
                // Step 1: Get registration challenge
                const challengePack = await fetchJsonWithRetry('/api/passkeys/register/challenge', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const challengeRes = challengePack.res;
                const challengeData = challengePack.data || {};

                if (!challengeRes.ok) {
                    if (challengeRes.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    const passkeyEnv = getPasskeyEnvSuggestion();
                    const serverMsg = challengeData.error || `Failed to get registration challenge (HTTP ${challengeRes.status})`;
                    if (challengeRes.status === 503) {
                        throw new Error(`${serverMsg} Set RP_ID=${passkeyEnv.rpId} and RP_ORIGIN=${passkeyEnv.rpOrigin} in Cloudflare, then redeploy.`);
                    }
                    throw new Error(serverMsg);
                }

                // Step 2: Create credential
                showStatus('passkey-status', 'Please follow your device\'s instructions...', 'info');
                
                const credential = await navigator.credentials.create({
                    publicKey: {
                        challenge: base64urlToBuffer(challengeData.challenge),
                        rp: {
                            name: challengeData.rpName || 'LOON CMS',
                            id: challengeData.rpId || window.location.hostname
                        },
                        user: {
                            id: base64urlToBuffer(challengeData.userId),
                            name: challengeData.username,
                            displayName: challengeData.username
                        },
                        pubKeyCredParams: challengeData.pubKeyCredParams || [
                            { alg: -7, type: 'public-key' }  // ES256
                        ],
                        timeout: challengeData.timeout || 60000,
                        attestation: challengeData.attestation || 'direct',
                        authenticatorSelection: challengeData.authenticatorSelection || {
                            authenticatorAttachment: 'platform',
                            userVerification: 'preferred',
                            residentKey: 'discouraged'
                        }
                    }
                });
                
                if (!credential) {
                    throw new Error('No credential created');
                }
                
                // Step 3: Verify registration
                showStatus('passkey-status', 'Verifying passkey...', 'info');
                
                const verifyRes = await fetch('/api/passkeys/register/verify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        attestationResponse: {
                            id: bufferToBase64url(credential.rawId),
                            response: {
                                attestationObject: bufferToBase64url(credential.response.attestationObject),
                                clientDataJSON: bufferToBase64url(credential.response.clientDataJSON)
                            },
                            transports: credential.response.getTransports ? 
                                credential.response.getTransports() : ['internal']
                        },
                        challengeToken: challengeData.challengeToken
                    })
                });
                
                const verifyData = await verifyRes.json();
                
                if (!verifyRes.ok) {
                    if (verifyRes.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error(verifyData.error || 'Registration verification failed');
                }
                
                // Step 4: Show recovery codes
                if (verifyData.recoveryCodes && verifyData.recoveryCodes.length > 0) {
                    showRecoveryCodes(verifyData.recoveryCodes);
                }
                
                showStatus('passkey-status', 'Passkey registered successfully!', 'success');
                
                // Reload passkeys list
                await loadPasskeys();
                
            } catch (e) {
                console.error('Passkey registration failed:', e);
                showStatus('passkey-status', e.message || 'Passkey registration failed', 'error');
            }
        }
        
        /**
         * Rename passkey
         */
        async function renamePasskey(credentialId) {
            const newName = prompt('Enter new name for this passkey:');
            
            if (!newName || !newName.trim()) {
                return;
            }
            
            try {
                const res = await fetch(`/api/passkeys/${credentialId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ name: newName.trim() })
                });
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to rename passkey');
                }
                
                showStatus('passkey-status', 'Passkey renamed successfully', 'success');
                await loadPasskeys();
                
            } catch (e) {
                console.error('Failed to rename passkey:', e);
                showStatus('passkey-status', e.message, 'error');
            }
        }
        
        /**
         * Delete passkey
         */
        async function deletePasskey(credentialId) {
            if (!confirm('Are you sure you want to delete this passkey?')) {
                return;
            }
            
            try {
                const res = await fetch(`/api/passkeys/${credentialId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error('Unauthorized'))) {
                        return;
                    }
                    throw new Error('Failed to delete passkey');
                }
                
                showStatus('passkey-status', 'Passkey deleted successfully', 'success');
                await loadPasskeys();
                
            } catch (e) {
                console.error('Failed to delete passkey:', e);
                showStatus('passkey-status', e.message, 'error');
            }
        }
        
        /**
         * Show recovery codes modal
         */
        function showRecoveryCodes(codes) {
            const display = document.getElementById('recovery-codes-display');
            display.innerHTML = codes.map((code, i) => 
                `${i + 1}. <strong>${code}</strong>`
            ).join('<br>');
            
            document.getElementById('recovery-codes-modal').classList.remove('hidden');
            
            // Store codes temporarily for download/copy
            window.tempRecoveryCodes = codes;
        }
        
        /**
         * Close recovery codes modal
         */
        function closeRecoveryCodesModal() {
            document.getElementById('recovery-codes-modal').classList.add('hidden');
            window.tempRecoveryCodes = null;
        }
        
        /**
         * Download recovery codes
         */
        function downloadRecoveryCodes() {
            if (!window.tempRecoveryCodes) return;
            
            const content = window.tempRecoveryCodes.map((code, i) => 
                `${i + 1}. ${code}`
            ).join('\n');
            
            const blob = new Blob([
                `LOON Recovery Codes\n`,
                `Username: ${SESSION.username}\n`,
                `Generated: ${new Date().toISOString()}\n\n`,
                `Save these codes securely. Each can only be used once.\n\n`,
                content
            ], { type: 'text/plain' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `loon-recovery-codes-${SESSION.username}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        /**
         * Copy recovery codes to clipboard
         */
        async function copyRecoveryCodes() {
            if (!window.tempRecoveryCodes) return;
            
            const content = window.tempRecoveryCodes.map((code, i) => 
                `${i + 1}. ${code}`
            ).join('\n');
            
            try {
                await navigator.clipboard.writeText(content);
                alert('Recovery codes copied to clipboard');
            } catch (e) {
                console.error('Failed to copy:', e);
                alert('Failed to copy to clipboard');
            }
        }
        
        /**
         * Base64url to ArrayBuffer
         */
        function base64urlToBuffer(base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const padLen = (4 - (base64.length % 4)) % 4;
            const padded = base64 + '='.repeat(padLen);
            const binary = atob(padded);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        /**
         * ArrayBuffer to base64url
         */
        function bufferToBase64url(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        // =================================================================
        // CONTENT EDITOR
        // =================================================================
        const PRIMARY_FIELD_PRIORITIES = ['body', 'content', 'text', 'markdown', 'html', 'description'];
        const TOP_FIELD_KEYS = ['title', 'headline', 'name'];

        function determinePrimaryFieldKey(schema) {
            const fields = Array.isArray(schema?.fields) ? schema.fields : [];
            const textareas = fields.filter(field => field.type === 'textarea');
            if (!textareas.length) return null;

            const priority = textareas.find(field =>
                PRIMARY_FIELD_PRIORITIES.includes(String(field.key || '').toLowerCase())
            );
            return (priority || textareas[0]).key || null;
        }

        function getFieldPlacement(field) {
            const key = String(field.key || '').toLowerCase();
            if (PRIMARY_FIELD_KEY && field.key === PRIMARY_FIELD_KEY) return 'primary';
            if (TOP_FIELD_KEYS.includes(key)) return 'top';
            return 'details';
        }

        function setPreviewMode(mode) {
            PREVIEW_MODE = mode === 'preview' ? 'preview' : 'write';
            const writeBtn = document.getElementById('preview-tab-write');
            const previewBtn = document.getElementById('preview-tab-preview');
            const previewEl = document.getElementById('primary-preview');
            const editorSlot = document.getElementById('primary-editor-slot');

            if (writeBtn && previewBtn) {
                writeBtn.classList.toggle('tab-active', PREVIEW_MODE === 'write');
                previewBtn.classList.toggle('tab-active', PREVIEW_MODE === 'preview');
            }

            if (previewEl && editorSlot) {
                if (PREVIEW_MODE === 'preview') {
                    previewEl.classList.remove('hidden');
                    editorSlot.classList.add('hidden');
                    updatePrimaryPreview(true);
                } else {
                    previewEl.classList.add('hidden');
                    editorSlot.classList.remove('hidden');
                }
            }
        }

        function renderMarkdownPreview(text) {
            if (window.marked && typeof window.marked.parse === 'function') {
                return window.marked.parse(text || '', { breaks: true, gfm: true });
            }
            const escaped = escapeHtml(text || '').replace(/\n/g, '<br>');
            return `<div>${escaped}</div>`;
        }

        function updatePrimaryPreview(force = false) {
            if (PREVIEW_MODE !== 'preview' && !force) return;
            const previewEl = document.getElementById('primary-preview');
            if (!previewEl || !PRIMARY_FIELD_KEY) return;
            const input = document.getElementById(`field_${PRIMARY_FIELD_KEY}`);
            if (!input || typeof input.value !== 'string') return;
            previewEl.innerHTML = renderMarkdownPreview(input.value);
            updateContentStats(input.value);
        }

        /**
         * Update word count and reading time display
         */
        function updateContentStats(text) {
            const statsDiv = document.getElementById('content-stats');
            if (!statsDiv) return;
            
            // Count words
            const words = (text || '').trim().split(/\s+/).filter(w => w.length > 0).length;
            
            // Calculate reading time (avg 200 words per minute)
            const readingTime = Math.ceil(words / 200) || 0;
            
            // Update display
            document.getElementById('word-count').textContent = `Words: ${words}`;
            document.getElementById('reading-time').textContent = `Reading time: ${readingTime} min`;
            statsDiv.style.display = 'block';
        }

        function getPrimaryEditorInput() {
            if (!PRIMARY_FIELD_KEY) return null;
            return document.getElementById(`field_${PRIMARY_FIELD_KEY}`);
        }

        function scheduleUndoSnapshot() {
            if (UNDO_SUSPENDED || !CURRENT_SCHEMA || !CURRENT_PAGE_ID) return;
            if (UNDO_TIMER) clearTimeout(UNDO_TIMER);
            UNDO_TIMER = setTimeout(() => {
                pushUndoSnapshot();
            }, UNDO_DEBOUNCE_MS);
        }

        function pushUndoSnapshot(options = {}) {
            if (UNDO_SUSPENDED || !CURRENT_SCHEMA || !CURRENT_PAGE_ID) return;
            const content = collectCurrentFormContent();
            const serialized = JSON.stringify(content || {});
            const last = UNDO_STACK[UNDO_STACK.length - 1];
            if (!options.force && last && last.serialized === serialized) return;

            UNDO_STACK.push({
                pageId: CURRENT_PAGE_ID,
                timestamp: Date.now(),
                content,
                serialized
            });

            if (UNDO_STACK.length > MAX_UNDO_STACK) {
                UNDO_STACK.shift();
            }

            if (!options.keepRedo) {
                REDO_STACK = [];
            }

            updateUndoRedoButtons();
            renderUndoHistory();
        }

        function resetUndoStack() {
            UNDO_STACK = [];
            REDO_STACK = [];
            pushUndoSnapshot({ force: true, keepRedo: true });
            updateUndoRedoButtons();
            renderUndoHistory();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            if (undoBtn) undoBtn.disabled = UNDO_STACK.length < 2;
            if (redoBtn) redoBtn.disabled = REDO_STACK.length === 0;
        }

        function applyUndoSnapshot(entry) {
            if (!entry || entry.pageId !== CURRENT_PAGE_ID) return;
            UNDO_SUSPENDED = true;
            CURRENT_CONTENT = { ...entry.content };
            buildForm();
            markEditorDirty(true);
            const primaryInput = getPrimaryEditorInput();
            if (primaryInput) {
                updateContentStats(primaryInput.value);
            }
            updatePrimaryPreview(true);
            renderDocumentOutline();
            UNDO_SUSPENDED = false;
        }

        function undoLastChange() {
            if (UNDO_STACK.length < 2) return;
            const current = UNDO_STACK.pop();
            REDO_STACK.push(current);
            const previous = UNDO_STACK[UNDO_STACK.length - 1];
            applyUndoSnapshot(previous);
            updateUndoRedoButtons();
            renderUndoHistory();
        }

        function redoLastChange() {
            if (!REDO_STACK.length) return;
            const entry = REDO_STACK.pop();
            UNDO_STACK.push(entry);
            applyUndoSnapshot(entry);
            updateUndoRedoButtons();
            renderUndoHistory();
        }

        function clearUndoHistory() {
            if (!CURRENT_PAGE_ID) return;
            if (!confirm('Clear edit history for this page? Undo and redo will reset.')) return;
            resetUndoStack();
        }

        function restoreUndoSnapshot(index) {
            if (index < 0 || index >= UNDO_STACK.length) return;
            const tail = UNDO_STACK.splice(index + 1);
            if (tail.length) {
                REDO_STACK = tail.concat(REDO_STACK);
            }
            const target = UNDO_STACK[index];
            applyUndoSnapshot(target);
            updateUndoRedoButtons();
            renderUndoHistory();
        }

        function renderUndoHistory() {
            const list = document.getElementById('undo-history-list');
            if (!list) return;
            if (!UNDO_STACK.length) {
                list.innerHTML = '<small style="color: var(--muted-color);">No edits yet</small>';
                return;
            }

            const start = Math.max(0, UNDO_STACK.length - 8);
            const items = UNDO_STACK.slice(start).map((entry, idx) => {
                const actualIndex = start + idx;
                const time = new Date(entry.timestamp).toLocaleTimeString();
                const label = actualIndex === UNDO_STACK.length - 1 ? 'Current' : 'Snapshot';
                return `
                    <div class="undo-history-item">
                        <span>${label} - ${time}</span>
                        <button type="button" class="outline" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;" onclick="restoreUndoSnapshot(${actualIndex})">Restore</button>
                    </div>
                `;
            });

            list.innerHTML = items.join('');
        }

        function scheduleOutlineUpdate() {
            if (OUTLINE_TIMER) clearTimeout(OUTLINE_TIMER);
            OUTLINE_TIMER = setTimeout(() => {
                renderDocumentOutline();
            }, 300);
        }

        function renderDocumentOutline() {
            const list = document.getElementById('outline-list');
            const status = document.getElementById('outline-status');
            const input = getPrimaryEditorInput();
            if (!list || !status) return;
            if (!input) {
                list.innerHTML = '';
                status.textContent = 'No primary text field available.';
                return;
            }

            const text = String(input.value || '');
            const lines = text.split('\n');
            let cursor = 0;
            OUTLINE_ENTRIES = [];

            lines.forEach((line, idx) => {
                const match = line.match(/^(#{1,3})\s+(.+)$/);
                if (match) {
                    const level = match[1].length;
                    const title = match[2].trim();
                    OUTLINE_ENTRIES.push({
                        level,
                        title,
                        position: cursor,
                        line: idx + 1
                    });
                }
                cursor += line.length + 1;
            });

            if (!OUTLINE_ENTRIES.length) {
                list.innerHTML = '';
                status.textContent = 'No headings found. Use #, ##, or ### to build an outline.';
                return;
            }

            status.textContent = `${OUTLINE_ENTRIES.length} heading(s) found.`;
            list.innerHTML = OUTLINE_ENTRIES.map((entry, index) => {
                const levelClass = entry.level === 2 ? 'outline-level-2' : entry.level === 3 ? 'outline-level-3' : '';
                return `
                    <div class="outline-item ${levelClass}" onclick="jumpToOutlineEntry(${index})">
                        <strong>${escapeHtml(entry.title)}</strong>
                        <small>Line ${entry.line}</small>
                    </div>
                `;
            }).join('');
        }

        function jumpToOutlineEntry(index) {
            const entry = OUTLINE_ENTRIES[index];
            const input = getPrimaryEditorInput();
            if (!entry || !input) return;
            input.focus();
            input.setSelectionRange(entry.position, entry.position);
        }

        function initCommandPalette() {
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-palette-input');
            if (!palette || !input) return;

            input.addEventListener('input', () => {
                renderCommandPaletteList(input.value);
            });

            palette.addEventListener('click', event => {
                if (event.target === palette) {
                    closeCommandPalette();
                }
            });
        }

        function getPaletteStorageKey(pageId) {
            const key = pageId ? `page:${pageId}` : 'global';
            return `loon_palette_recents:${key}`;
        }

        function getRecentPaletteCommands(pageId) {
            const key = getPaletteStorageKey(pageId);
            const raw = localStorage.getItem(key);
            if (!raw) return [];
            try {
                const parsed = JSON.parse(raw);
                return Array.isArray(parsed) ? parsed : [];
            } catch {
                return [];
            }
        }

        function addRecentPaletteCommand(label) {
            const key = getPaletteStorageKey(CURRENT_PAGE_ID);
            const existing = getRecentPaletteCommands(CURRENT_PAGE_ID);
            const next = [label, ...existing.filter(item => item !== label)].slice(0, 6);
            localStorage.setItem(key, JSON.stringify(next));
        }

        function openCommandPalette() {
            const palette = document.getElementById('command-palette');
            const input = document.getElementById('command-palette-input');
            if (!palette || !input) return;
            COMMAND_PALETTE_OPEN = true;
            palette.classList.add('open');
            palette.setAttribute('aria-hidden', 'false');
            input.value = '';
            renderCommandPaletteList('');
            setTimeout(() => input.focus(), 0);
        }

        function closeCommandPalette() {
            const palette = document.getElementById('command-palette');
            if (!palette) return;
            COMMAND_PALETTE_OPEN = false;
            palette.classList.remove('open');
            palette.setAttribute('aria-hidden', 'true');
        }

        function handleCommandPaletteKeydown(event) {
            const input = document.getElementById('command-palette-input');
            if (!COMMAND_PALETTE_OPEN || !input) return;

            if (event.key === 'Escape') {
                event.preventDefault();
                closeCommandPalette();
                return;
            }

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                COMMAND_PALETTE_INDEX = Math.min(COMMAND_PALETTE_INDEX + 1, COMMAND_PALETTE_RESULTS.length - 1);
                updateCommandPaletteActive();
                return;
            }

            if (event.key === 'ArrowUp') {
                event.preventDefault();
                COMMAND_PALETTE_INDEX = Math.max(COMMAND_PALETTE_INDEX - 1, 0);
                updateCommandPaletteActive();
                return;
            }

            if (event.key === 'Enter') {
                event.preventDefault();
                executeCommandPaletteAction(COMMAND_PALETTE_INDEX);
            }
        }

        function getCommandPaletteActions() {
            const hasPage = !!CURRENT_PAGE_ID && !!CURRENT_SCHEMA;
            const canPublish = SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor');
            const actions = [
                {
                    label: 'Open Page',
                    detail: 'Focus the Page ID input',
                    run: () => document.getElementById('pageId')?.focus()
                },
                {
                    label: 'Browse Pages',
                    detail: 'Open page browser',
                    run: () => loadPageList()
                },
                {
                    label: 'Create New Page',
                    detail: 'Open new page dialog',
                    run: () => showNewPageDialog()
                },
                {
                    label: 'Save Changes',
                    detail: 'Save or stage current page',
                    when: () => hasPage,
                    run: () => handlePrimarySaveAction()
                },
                {
                    label: 'Save Draft',
                    detail: 'Save as draft',
                    when: () => hasPage && SESSION && SESSION.role !== 'contributor',
                    run: () => saveContentAsDraft()
                },
                {
                    label: 'Publish Page',
                    detail: 'Publish current page',
                    when: () => hasPage && canPublish,
                    run: () => publishContent()
                },
                {
                    label: 'Toggle Preview',
                    detail: PREVIEW_MODE === 'preview' ? 'Switch to write mode' : 'Switch to preview mode',
                    when: () => hasPage && PRIMARY_FIELD_KEY,
                    run: () => setPreviewMode(PREVIEW_MODE === 'preview' ? 'write' : 'preview')
                },
                {
                    label: 'Reader View',
                    detail: 'Open public view of current page',
                    when: () => hasPage,
                    run: () => previewAsReader()
                },
                {
                    label: 'Toggle Batch Mode',
                    detail: BATCH_MODE_ENABLED ? 'Disable batch staging' : 'Enable batch staging',
                    when: () => !!SESSION,
                    run: () => setBatchModeEnabled(!BATCH_MODE_ENABLED)
                },
                {
                    label: 'Content Health Dashboard',
                    detail: 'Switch to health tab',
                    when: () => SESSION && SESSION.role === 'admin',
                    run: () => switchTab('health')
                }
            ].filter(action => !action.when || action.when());

            const recentLabels = getRecentPaletteCommands(CURRENT_PAGE_ID);
            if (!recentLabels.length) return actions;

            const actionMap = new Map(actions.map(action => [action.label, action]));
            const recentActions = recentLabels
                .map(label => actionMap.get(label))
                .filter(Boolean)
                .map(action => ({
                    ...action,
                    detail: action.detail ? `Recent: ${action.detail}` : 'Recent command'
                }));

            const remaining = actions.filter(action => !recentLabels.includes(action.label));
            return [...recentActions, ...remaining];
        }

        function renderCommandPaletteList(query) {
            const list = document.getElementById('command-palette-list');
            if (!list) return;
            const normalized = String(query || '').trim().toLowerCase();
            const actions = getCommandPaletteActions();
            COMMAND_PALETTE_RESULTS = actions.filter(action => {
                if (!normalized) return true;
                const haystack = `${action.label} ${action.detail || ''}`.toLowerCase();
                return haystack.includes(normalized);
            });

            COMMAND_PALETTE_INDEX = 0;

            if (!COMMAND_PALETTE_RESULTS.length) {
                list.innerHTML = '<div class="command-palette-empty">No commands found.</div>';
                COMMAND_PALETTE_INDEX = 0;
                return;
            }

            COMMAND_PALETTE_INDEX = Math.min(COMMAND_PALETTE_INDEX, COMMAND_PALETTE_RESULTS.length - 1);
            list.innerHTML = COMMAND_PALETTE_RESULTS.map((action, idx) => `
                <div class="command-palette-item ${idx === COMMAND_PALETTE_INDEX ? 'active' : ''}" onclick="executeCommandPaletteAction(${idx})">
                    <div>
                        <strong>${escapeHtml(action.label)}</strong>
                        ${action.detail ? `<div><small>${escapeHtml(action.detail)}</small></div>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function updateCommandPaletteActive() {
            const items = document.querySelectorAll('.command-palette-item');
            items.forEach((item, idx) => {
                item.classList.toggle('active', idx === COMMAND_PALETTE_INDEX);
            });
        }

        function executeCommandPaletteAction(index) {
            const action = COMMAND_PALETTE_RESULTS[index];
            if (!action) return;
            closeCommandPalette();
            addRecentPaletteCommand(action.label);
            action.run();
        }

        /**
         * Show a live preview of the page as readers will see it
         */
        async function previewAsReader() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load or create a page first', 'error');
                return;
            }

            // First, save current changes so preview is up-to-date
            showStatus('editor-status', 'Preparing preview...', 'info');
            
            try {
                // Check if we have unsaved changes
                const hasDirty = HAS_LOCAL_CHANGES || hasQueuedChangeForCurrentPage();
                
                if (hasDirty) {
                    const proceed = confirm('You have unsaved changes. Save them first before previewing?');
                    if (proceed) {
                        // quietly save without showing dialog
                        await saveContent();
                    }
                }
                
                // Open the public page in a new tab
                const url = `${window.location.origin}/index.html?page=${encodeURIComponent(CURRENT_PAGE_ID)}`;
                window.open(url, '_blank', 'noopener,noreferrer');
                showStatus('editor-status', 'Preview opened in new tab', 'success');
                
            } catch (e) {
                showStatus('editor-status', `Preview failed: ${e.message}`, 'error');
            }
        }

        async function loadEditor() {
            const pageId = document.getElementById('pageId').value.trim().toLowerCase();
            
            if (!pageId) {
                showStatus('editor-status', 'Please enter a Page ID', 'error');
                return;
            }
            if (!/^[a-z0-9_-]+$/.test(pageId)) {
                showStatus('editor-status', 'Page ID must use lowercase letters, numbers, hyphens, or underscores.', 'error');
                return;
            }

            showStatus('editor-status', 'Loading...', 'info');
            document.getElementById('editor-container').classList.add('hidden');

            try {
                // Fetch schema
                const schemaRes = await fetch(`/data/${pageId}/schema.json`);
                if (!schemaRes.ok) {
                    if (schemaRes.status === 404) {
                        throw new Error(`Page "${pageId}" not found. Create it with + New Page or choose an existing page from Browse Pages.`);
                    }
                    throw new Error(`Failed to load page "${pageId}" (HTTP ${schemaRes.status}).`);
                }
                CURRENT_SCHEMA = await schemaRes.json();
                CURRENT_PAGE_ID = pageId;
                localStorage.setItem(STORAGE_KEYS.LAST_PAGE, pageId);

                // Fetch content
                const contentRes = await fetch(`/data/${pageId}/content.json`);
                CURRENT_CONTENT = contentRes.ok ? await contentRes.json() : {};

                // If batch mode has staged content for this page, prefer staged state
                const queued = getQueuedChangeForPage(pageId);
                if (queued && queued.content) {
                    CURRENT_CONTENT = { ...queued.content };
                }
                renderLoadedPage(pageId, queued);

            } catch (e) {
                showStatus('editor-status', e.message, 'error');
                document.getElementById('editor-container').classList.add('hidden');
            }
        }

        function renderLoadedPage(pageId, queued = null) {
            // Build form
            buildForm();
            markEditorDirty(false);
            maybeRestoreAutosave(pageId);
            resetUndoStack();
            const primaryInput = getPrimaryEditorInput();
            if (primaryInput) {
                updateContentStats(primaryInput.value);
                renderDocumentOutline();
            }
            updateAutosaveSnapshotsList();
            refreshLinkPageList();
            loadRevisionHistory();
            hydrateWorkflowPanelFromContent();
            loadWatchActivity();
            loadReusableBlocks();

            // Show editor
            document.getElementById('editor-container').classList.remove('hidden');
            document.getElementById('editor-title').textContent = CURRENT_SCHEMA.title || `Editing: ${pageId}`;

            // Show metadata if exists
            if (CURRENT_CONTENT._meta) {
                const meta = CURRENT_CONTENT._meta;
                let metaHtml = '';
                if (meta.createdBy) metaHtml += `Created by: ${escapeHtml(meta.createdBy)}`;
                if (meta.created) metaHtml += ` on ${new Date(meta.created).toLocaleDateString()}`;
                if (meta.modifiedBy) metaHtml += ` | Last modified by: ${escapeHtml(meta.modifiedBy)}`;
                if (meta.lastModified) metaHtml += ` on ${new Date(meta.lastModified).toLocaleString()}`;

                const metaEl = document.getElementById('content-meta');
                metaEl.innerHTML = metaHtml;
                metaEl.classList.remove('hidden');
            }

            // Show delete button for admin/editor only
            const deleteBtn = document.getElementById('delete-btn');
            if (SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor')) {
                deleteBtn.style.display = 'inline-block';
            } else {
                deleteBtn.style.display = 'none';
            }

            // Show duplicate button for admins, editors, and contributors (clone own work)
            const duplicateBtn = document.getElementById('duplicate-page-btn');
            if (SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor' || SESSION.role === 'contributor')) {
                duplicateBtn.style.display = 'inline-block';
            } else {
                duplicateBtn.style.display = 'none';
            }

            // Show draft/publish buttons based on role
            const saveBtn = document.getElementById('save-btn');
            const draftBtn = document.getElementById('draft-btn');
            const publishBtn = document.getElementById('publish-btn');

            if (SESSION && SESSION.role === 'contributor') {
                // Contributors can only save drafts
                saveBtn.style.display = 'none';
                draftBtn.style.display = 'inline-block';
            } else {
                saveBtn.style.display = 'inline-block';
                draftBtn.style.display = 'inline-block';
            }

            if (SESSION && (SESSION.role === 'admin' || SESSION.role === 'editor')) {
                // Only admins and editors can publish
                publishBtn.style.display = 'inline-block';
            } else {
                publishBtn.style.display = 'none';
            }

            // Show content status if available
            if (CURRENT_CONTENT._meta && CURRENT_CONTENT._meta.status) {
                updateContentStatus(CURRENT_CONTENT._meta.status, CURRENT_CONTENT._meta.modifiedBy);
            } else {
                document.getElementById('content-status').style.display = 'none';
            }

            if (queued) {
                document.getElementById('last-saved').textContent = `Loaded staged ${getStagedLabel(queued.saveAs)} change from this browser session`;
                showStatus('editor-status', `Loaded staged change for "${pageId}". Push all changes when ready.`, 'info');
                markEditorDirty(false);
            } else {
                document.getElementById('last-saved').textContent = '';
            }
            updateBatchUi();
            applyRoleBasedUI();
            if (!queued) hideStatus('editor-status');
            updateAutosaveIndicator();
        }

        /**
         * Load and display available pages
         */
        async function loadPageList() {
            const browser = document.getElementById('page-browser');
            const list = document.getElementById('page-list');
            const filter = document.getElementById('page-browser-filter');
            
            browser.classList.remove('hidden');
            list.innerHTML = '<p>Loading pages...</p>';
            if (filter) filter.value = '';
            PAGE_CONTENT_CACHE.clear();
            resetAdvancedPageSearch(true);
            
            try {
                const headers = { };
                if (SESSION && SESSION.token) {
                    headers['Authorization'] = `Bearer ${SESSION.token}`;
                }
                
                const res = await fetch('/api/pages', { headers });
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to load pages');
                }
                
                if (data.pages.length === 0) {
                    list.innerHTML = '<p style="color: var(--muted-color);">No pages found. Create a page by adding a folder to /data/ with schema.json</p>';
                    PAGE_BROWSER_ITEMS = [];
                    return;
                }

                PAGE_BROWSER_ITEMS = [...data.pages].sort((a, b) => {
                    const left = String(a.title || a.pageId || '').toLowerCase();
                    const right = String(b.title || b.pageId || '').toLowerCase();
                    return left.localeCompare(right);
                });
                PAGE_BROWSER_CAN_EDIT_ALL = !!data.canEditAll;
                renderPageBrowserList(PAGE_BROWSER_ITEMS);

                const pageVerb = PAGE_BROWSER_CAN_EDIT_ALL ? 'edit' : 'view';
                showStatus('page-browser-status', `Showing ${PAGE_BROWSER_ITEMS.length} page(s) you can ${pageVerb}`, 'info');
                
            } catch (e) {
                list.innerHTML = `<p style="color: var(--error);">${escapeHtml(e.message)}</p>`;
            }
        }

        function renderPageBrowserList(items) {
            const list = document.getElementById('page-list');
            if (!list) return;
            if (!items.length) {
                list.innerHTML = '<p style="color: var(--muted-color);">No pages match your filter.</p>';
                return;
            }

            const actionLabel = PAGE_BROWSER_CAN_EDIT_ALL ? 'Edit' : 'Open';
            list.innerHTML = items.map(page => {
                const isSelected = BULK_SELECTED_PAGES.has(page.pageId);
                const highlight = LAST_PAGE_QUERY ? String(LAST_PAGE_QUERY).trim().toLowerCase() : '';
                const displayTitle = highlight ? highlightMatch(page.title || page.pageId, highlight) : escapeHtml(page.title || page.pageId);
                const displayId = highlight ? highlightMatch(page.pageId, highlight) : escapeHtml(page.pageId);
                const displayAuthor = page.createdBy
                    ? (highlight ? highlightMatch(page.createdBy, highlight) : escapeHtml(page.createdBy))
                    : '';
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: ${isSelected ? 'var(--primary)' : 'var(--muted-border-color)'}; border-radius: 4px; color: ${isSelected ? 'white' : 'inherit'};">
                        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
                            <input type="checkbox" ${isSelected ? 'checked' : ''} onchange="togglePageSelection('${escapeHtml(page.pageId)}')" style="cursor: pointer;">
                            <div>
                                <strong>${displayTitle}</strong>
                                <span style="color: ${isSelected ? 'rgba(255,255,255,0.8)' : 'var(--muted-color)'}; font-size: 0.85rem; margin-left: 0.5rem;">${displayId}</span>
                                ${displayAuthor ? `<br><small style="color: ${isSelected ? 'rgba(255,255,255,0.8)' : 'var(--muted-color)'};">By ${displayAuthor}</small>` : ''}
                            </div>
                        </div>
                        <button onclick="selectPage('${escapeHtml(page.pageId)}')" class="outline" style="padding: 0.25rem 0.75rem; ${isSelected ? 'display: none;' : ''}">${actionLabel}</button>
                    </div>
                `;
            }).join('');
            
            updateBulkActionsPanel();
            applyRoleBasedUI();
        }

        function getAdvancedPageSearchCriteria() {
            const limitRaw = parseInt(document.getElementById('page-advanced-limit')?.value || '60', 10);
            const limit = Number.isFinite(limitRaw) && limitRaw > 0 ? limitRaw : 60;
            return {
                query: String(document.getElementById('page-advanced-query')?.value || '').trim().toLowerCase(),
                status: String(document.getElementById('page-advanced-status')?.value || '').trim().toLowerCase(),
                author: String(document.getElementById('page-advanced-author')?.value || '').trim().toLowerCase(),
                updatedFrom: document.getElementById('page-advanced-updated-from')?.value || '',
                updatedTo: document.getElementById('page-advanced-updated-to')?.value || '',
                includeContent: !!document.getElementById('page-advanced-content')?.checked,
                limit
            };
        }

        function resetAdvancedPageSearch(silent = false) {
            const inputs = [
                'page-advanced-query',
                'page-advanced-status',
                'page-advanced-author',
                'page-advanced-updated-from',
                'page-advanced-updated-to',
                'page-advanced-content',
                'page-advanced-limit'
            ];
            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                if (el.type === 'checkbox') {
                    el.checked = false;
                } else if (el.type === 'number') {
                    el.value = '60';
                } else {
                    el.value = '';
                }
            });

            if (!silent) {
                filterPageBrowserList();
            }
        }

        function applyAdvancedPageSearch() {
            applyPageBrowserFilters({ forceContent: true });
        }

        async function filterPageBrowserList() {
            await applyPageBrowserFilters();
        }

        async function applyPageBrowserFilters(options = {}) {
            const filter = document.getElementById('page-browser-filter');
            const simpleQuery = String(filter?.value || '').trim().toLowerCase();
            const advanced = getAdvancedPageSearchCriteria();
            const combinedQuery = [simpleQuery, advanced.query].filter(Boolean).join(' ').trim();
            const advancedActive = !!(advanced.query || advanced.status || advanced.author || advanced.updatedFrom || advanced.updatedTo || advanced.includeContent || options.forceContent);
            const resultLimit = advancedActive ? advanced.limit : PAGE_BROWSER_ITEMS.length;
            LAST_PAGE_QUERY = combinedQuery;

            let filtered = PAGE_BROWSER_ITEMS.filter(page => {
                const title = String(page.title || '').toLowerCase();
                const id = String(page.pageId || '').toLowerCase();
                const matchesQuery = !combinedQuery || title.includes(combinedQuery) || id.includes(combinedQuery);

                let matchesAuthor = true;
                if (advanced.author) {
                    const createdBy = String(page.createdBy || '').toLowerCase();
                    matchesAuthor = createdBy.includes(advanced.author);
                }

                let matchesUpdated = true;
                if (advanced.updatedFrom || advanced.updatedTo) {
                    const lastModified = page.lastModified ? new Date(page.lastModified) : null;
                    if (!lastModified || Number.isNaN(lastModified.getTime())) {
                        matchesUpdated = false;
                    } else {
                        if (advanced.updatedFrom) {
                            matchesUpdated = matchesUpdated && lastModified >= new Date(advanced.updatedFrom);
                        }
                        if (advanced.updatedTo) {
                            const endDate = new Date(advanced.updatedTo);
                            endDate.setHours(23, 59, 59, 999);
                            matchesUpdated = matchesUpdated && lastModified <= endDate;
                        }
                    }
                }

                return matchesQuery && matchesAuthor && matchesUpdated;
            });

            const needsContent = !!advanced.status || advanced.includeContent || options.forceContent;
            if (!needsContent) {
                renderPageBrowserList(filtered.slice(0, resultLimit));
                return;
            }

            showStatus('page-browser-status', 'Searching content...', 'info');
            const results = [];
            for (const page of filtered) {
                if (results.length >= resultLimit) break;
                const contentPack = await fetchPageContentForSearch(page.pageId);
                if (!contentPack) continue;

                const { content, text } = contentPack;
                let matchesStatus = true;
                if (advanced.status) {
                    const status = String(content?._meta?.workflowStatus || content?._meta?.status || '').toLowerCase();
                    matchesStatus = status === advanced.status;
                }

                let matchesAuthor = true;
                if (advanced.author) {
                    const createdBy = String(page.createdBy || '').toLowerCase();
                    const modifiedBy = String(content?._meta?.modifiedBy || '').toLowerCase();
                    matchesAuthor = createdBy.includes(advanced.author) || modifiedBy.includes(advanced.author);
                }

                let matchesContent = true;
                if (advanced.includeContent && combinedQuery) {
                    matchesContent = text.includes(combinedQuery);
                }

                if (matchesStatus && matchesAuthor && matchesContent) {
                    results.push(page);
                }
            }

            renderPageBrowserList(results);
            showStatus('page-browser-status', `Advanced search returned ${results.length} page(s).`, 'info');
        }

        async function fetchPageContentForSearch(pageId) {
            if (PAGE_CONTENT_CACHE.has(pageId)) {
                return PAGE_CONTENT_CACHE.get(pageId);
            }

            try {
                const res = await fetch(`/data/${pageId}/content.json`);
                if (!res.ok) return null;
                const content = await res.json();
                const text = collectSearchText(content);
                const pack = { content, text };
                PAGE_CONTENT_CACHE.set(pageId, pack);
                return pack;
            } catch {
                return null;
            }
        }

        function collectSearchText(content) {
            const parts = [];
            const visit = value => {
                if (typeof value === 'string') {
                    parts.push(value);
                } else if (Array.isArray(value)) {
                    value.forEach(visit);
                } else if (value && typeof value === 'object') {
                    Object.keys(value).forEach(key => {
                        if (key === '_meta') return;
                        visit(value[key]);
                    });
                }
            };

            visit(content);
            return parts.join(' ').toLowerCase();
        }
        
        function selectPage(pageId) {
            document.getElementById('pageId').value = pageId;
            document.getElementById('page-browser').classList.add('hidden');
            loadEditor();
        }

        /**
         * Bulk Actions: Toggle page selection
         */
        function togglePageSelection(pageId) {
            if (BULK_SELECTED_PAGES.has(pageId)) {
                BULK_SELECTED_PAGES.delete(pageId);
            } else {
                BULK_SELECTED_PAGES.add(pageId);
            }
            renderPageBrowserList(PAGE_BROWSER_ITEMS);
        }

        /**
         * Update bulk actions panel visibility and count
         */
        function updateBulkActionsPanel() {
            const panel = document.getElementById('bulk-actions-panel');
            const count = document.getElementById('bulk-selected-count');
            if (!panel || !count) return;

            const selected = BULK_SELECTED_PAGES.size;
            count.textContent = selected;
            panel.style.display = selected > 0 ? 'block' : 'none';
        }

        /**
         * Bulk select all visible pages
         */
        function bulkSelectAll() {
            PAGE_BROWSER_ITEMS.forEach(page => BULK_SELECTED_PAGES.add(page.pageId));
            renderPageBrowserList(PAGE_BROWSER_ITEMS);
        }

        /**
         * Clear bulk selection
         */
        function bulkClearSelection() {
            BULK_SELECTED_PAGES.clear();
            renderPageBrowserList(PAGE_BROWSER_ITEMS);
        }

        /**
         * Bulk publish selected pages
         */
        async function bulkPublishPages() {
            return runBulkPublish('publish');
        }

        /**
         * Bulk unpublish selected pages
         */
        async function bulkUnpublishPages() {
            return runBulkPublish('unpublish');
        }

        async function runBulkPublish(action) {
            if (BULK_SELECTED_PAGES.size === 0) {
                showStatus('page-browser-status', 'Select pages first', 'error');
                return;
            }

            const count = BULK_SELECTED_PAGES.size;
            const verb = action === 'unpublish' ? 'Unpublish' : 'Publish';
            const dryRun = LOCAL_MODE && document.getElementById('bulk-dry-run')?.checked;
            if (!dryRun && !confirm(`${verb} ${count} page(s)?`)) return;

            showStatus('page-browser-status', `${verb}ing ${count} page(s)...`, 'info');

            if (LOCAL_MODE) {
                try {
                    const res = await fetch('/api/bulk-publish', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SESSION.token}`
                        },
                        body: JSON.stringify({
                            pageIds: Array.from(BULK_SELECTED_PAGES),
                            action,
                            dryRun
                        })
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || 'Bulk publish failed');

                    const results = Array.isArray(data.results) ? data.results : [];
                    const failed = results.filter(item => !item.ok).length;
                    const success = results.filter(item => item.ok).length;

                    if (!dryRun) {
                        BULK_SELECTED_PAGES.clear();
                        renderPageBrowserList(PAGE_BROWSER_ITEMS);
                    }

                    const suffix = failed > 0 ? `. ${failed} failed.` : '';
                    const prefix = dryRun ? 'Dry run complete.' : `${verb}ed ${success} page(s)`;
                    showStatus('page-browser-status', `${prefix}${suffix}`, success > 0 ? 'success' : 'error');
                    return;
                } catch (e) {
                    showStatus('page-browser-status', e.message, 'error');
                    return;
                }
            }

            let success = 0;
            let failed = 0;
            for (const pageId of BULK_SELECTED_PAGES) {
                try {
                    const res = await fetch('/api/publish', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SESSION.token}`
                        },
                        body: JSON.stringify({ pageId, action })
                    });
                    if (res.ok) {
                        success++;
                    } else {
                        failed++;
                    }
                } catch {
                    failed++;
                }
            }

            BULK_SELECTED_PAGES.clear();
            renderPageBrowserList(PAGE_BROWSER_ITEMS);
            showStatus('page-browser-status', `${verb}ed ${success} page(s)${failed > 0 ? `. ${failed} failed.` : ''}`, success > 0 ? 'success' : 'error');
        }

        /**
         * Bulk set workflow status
         */
        async function bulkSetWorkflowStatus() {
            const status = document.getElementById('bulk-workflow-status')?.value;
            if (!status || BULK_SELECTED_PAGES.size === 0) {
                showStatus('page-browser-status', 'Select pages and status first', 'error');
                return;
            }

            const count = BULK_SELECTED_PAGES.size;
            if (!confirm(`Change ${count} page(s) to "${status}"?`)) return;

            showStatus('page-browser-status', `Updating ${count} page(s)...`, 'info');
            let success = 0;
            let failed = 0;

            for (const pageId of BULK_SELECTED_PAGES) {
                try {
                    const res = await fetch('/api/workflow', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SESSION.token}`
                        },
                        body: JSON.stringify({
                            pageId,
                            status,
                            scheduledFor: null
                        })
                    });

                    if (res.ok) {
                        success++;
                    } else {
                        failed++;
                    }
                } catch (e) {
                    failed++;
                }
            }

            BULK_SELECTED_PAGES.clear();
            document.getElementById('bulk-workflow-status').value = '';
            renderPageBrowserList(PAGE_BROWSER_ITEMS);
            showStatus('page-browser-status', `Updated ${success} page(s)${failed > 0 ? `. ${failed} failed.` : ''}`, success > 0 ? 'success' : 'error');
        }
        
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function escapeRegExp(value) {
            return String(value || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function highlightMatch(text, query) {
            const raw = String(text || '');
            const safeQuery = escapeRegExp(query);
            if (!safeQuery) return escapeHtml(raw);
            const regex = new RegExp(safeQuery, 'ig');
            return escapeHtml(raw).replace(regex, match => `<mark>${match}</mark>`);
        }

        // =================================================================
        // NEW PAGE CREATION
        // =================================================================
        const TEMPLATE_HELP = {
            '': 'Start with a blank page and add fields as needed.',
            'landing-page': 'Hero, intro, calls to action, and section blocks for a homepage or campaign.',
            'announcement': 'Short notice with urgency, dates, and a call to action.',
            'blog-post': 'Title, summary, body, tags, and publication status.',
            'business-hours': 'Operating hours, status, and contact details.',
            'class-workshop': 'Class details, schedule, pricing, and registration link.',
            'contact-page': 'Organization contact info, address, and links.',
            'directory-entry': 'Listing-style entry with summary and contact fields.',
            'documentation-page': 'Doc title, summary, main body, and reference links.',
            'event': 'Event details, timing, location, and registration.',
            'faq': 'Question, answer, keywords, and order for a help entry.',
            'food-truck': 'Location, hours, status, and menu link for a mobile vendor.',
            'job-posting': 'Role details, requirements, and how to apply.',
            'menu-page': 'Menu sections and items for an easy-to-scan list.',
            'menu-pricing': 'Services or items with prices and specials.',
            'portfolio': 'Project details, images, and links.',
            'product-service': 'Offering description, pricing, and call to action.',
            'property-listing': 'Listing details, features, and contact info.',
            'service-status': 'Service status, incident details, and updates.',
            'team-profile': 'Bio, role, and contact info for a person.',
            'testimonial': 'Quote, author details, and rating.',
            'todo-page': 'Task list with owners, dates, and status.'
        };

        function updateTemplateHelp() {
            const select = document.getElementById('new-page-template');
            const help = document.getElementById('new-page-template-help');
            if (!select || !help) return;
            const value = select.value || '';
            help.textContent = TEMPLATE_HELP[value] || TEMPLATE_HELP[''];
        }

        function showNewPageDialog() {
            document.getElementById('new-page-dialog').classList.remove('hidden');
            document.getElementById('page-browser').classList.add('hidden');
            updateTemplateHelp();
            document.getElementById('new-page-id').focus();
        }
        
        function cancelNewPage() {
            document.getElementById('new-page-dialog').classList.add('hidden');
            document.getElementById('new-page-id').value = '';
            document.getElementById('new-page-title').value = '';
            document.getElementById('new-page-template').value = '';
            updateTemplateHelp();
            document.getElementById('new-page-status').innerHTML = '';
        }
        
        async function createNewPage() {
            const pageId = document.getElementById('new-page-id').value.trim().toLowerCase();
            const title = document.getElementById('new-page-title').value.trim() || pageId;
            const template = document.getElementById('new-page-template').value.trim() || null;
            const statusDiv = document.getElementById('new-page-status');
            
            // Validation
            if (!pageId) {
                statusDiv.innerHTML = '<p style="color: var(--error);">Page ID is required</p>';
                return;
            }
            
            if (!/^[a-z0-9_-]+$/.test(pageId)) {
                statusDiv.innerHTML = '<p style="color: var(--error);">Page ID must contain only lowercase letters, numbers, hyphens, and underscores</p>';
                return;
            }
            
            statusDiv.innerHTML = '<p>Creating page...</p>';
            
            try {
                const response = await fetch('/api/pages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: pageId,
                        title: title,
                        template: template
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to create page');
                }
                
                // Success! Load the new page
                statusDiv.innerHTML = '<p style="color: var(--success);">Page created! Loading editor...</p>';
                
                setTimeout(() => {
                    cancelNewPage();
                    document.getElementById('pageId').value = pageId;

                    // Use API response data immediately so new pages open without waiting
                    // for static /data propagation on the next deployment.
                    if (data.schema && typeof data.schema === 'object') {
                        CURRENT_PAGE_ID = pageId;
                        CURRENT_SCHEMA = data.schema;
                        CURRENT_CONTENT = (data.content && typeof data.content === 'object') ? data.content : {};
                        localStorage.setItem(STORAGE_KEYS.LAST_PAGE, pageId);
                        const queued = getQueuedChangeForPage(pageId);
                        if (queued && queued.content) {
                            CURRENT_CONTENT = { ...queued.content };
                        }
                        renderLoadedPage(pageId, queued);
                        showStatus('editor-status', `Page "${pageId}" created and loaded.`, 'success');
                    } else {
                        loadEditor();
                    }
                }, 1000);
                
            } catch (e) {
                statusDiv.innerHTML = `<p style="color: var(--error);">Error: ${escapeHtml(e.message)}</p>`;
            }
        }

        /**
         * Show duplicate page dialog
         */
        function showDuplicatePageDialog() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page first', 'error');
                return;
            }
            document.getElementById('duplicate-page-dialog').classList.remove('hidden');
            document.getElementById('dup-page-id').focus();
            document.getElementById('dup-page-title').value = (CURRENT_SCHEMA?.title || CURRENT_PAGE_ID) + ' (Copy)';
        }
        
        /**
         * Cancel duplicate page dialog
         */
        function cancelDuplicatePage() {
            document.getElementById('duplicate-page-dialog').classList.add('hidden');
            document.getElementById('dup-page-id').value = '';
            document.getElementById('dup-page-title').value = '';
            document.getElementById('duplicate-page-status').innerHTML = '';
        }
        
        /**
         * Duplicate the current page
         */
        async function duplicatePage() {
            const newPageId = document.getElementById('dup-page-id').value.trim().toLowerCase();
            const newTitle = document.getElementById('dup-page-title').value.trim() || newPageId;
            const statusDiv = document.getElementById('duplicate-page-status');
            
            // Validation
            if (!newPageId) {
                statusDiv.innerHTML = '<p style="color: var(--error);">New Page ID is required</p>';
                return;
            }
            
            if (!/^[a-z0-9_-]+$/.test(newPageId)) {
                statusDiv.innerHTML = '<p style="color: var(--error);">Page ID must contain only lowercase letters, numbers, hyphens, and underscores</p>';
                return;
            }
            
            if (newPageId === CURRENT_PAGE_ID) {
                statusDiv.innerHTML = '<p style="color: var(--error);">New Page ID must be different from the original</p>';
                return;
            }
            
            statusDiv.innerHTML = '<p>Duplicating page...</p>';
            
            try {
                // Create the new page with same schema
                const createRes = await fetch('/api/pages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: newPageId,
                        title: newTitle,
                        schema: CURRENT_SCHEMA
                    })
                });
                
                const createData = await createRes.json();
                
                if (!createRes.ok) {
                    throw new Error(createData.error || 'Failed to create duplicate page');
                }
                
                // Now save the content to the new page
                const contentToSave = { ...CURRENT_CONTENT };
                if (contentToSave._meta) {
                    contentToSave._meta = {
                        ...contentToSave._meta,
                        createdBy: SESSION.username,
                        created: new Date().toISOString(),
                        modifiedBy: SESSION.username,
                        lastModified: new Date().toISOString(),
                        status: 'draft',
                        workflowStatus: 'draft'
                    };
                } else {
                    contentToSave._meta = {
                        createdBy: SESSION.username,
                        created: new Date().toISOString(),
                        modifiedBy: SESSION.username,
                        lastModified: new Date().toISOString(),
                        status: 'draft',
                        workflowStatus: 'draft'
                    };
                }
                
                const saveRes = await fetch('/api/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: newPageId,
                        content: contentToSave
                    })
                });
                
                const saveData = await saveRes.json();
                
                if (!saveRes.ok) {
                    throw new Error(saveData.error || 'Failed to save duplicated content');
                }
                
                // Success! Load the new page
                statusDiv.innerHTML = '<p style="color: var(--success);">Page duplicated! Loading new page...</p>';
                
                setTimeout(() => {
                    cancelDuplicatePage();
                    document.getElementById('pageId').value = newPageId;
                    
                    // Load the newly created page
                    CURRENT_PAGE_ID = newPageId;
                    CURRENT_SCHEMA = createData.schema || CURRENT_SCHEMA;
                    CURRENT_CONTENT = contentToSave;
                    localStorage.setItem(STORAGE_KEYS.LAST_PAGE, newPageId);
                    renderLoadedPage(newPageId, null);
                    showStatus('editor-status', `Page "${newPageId}" created as a duplicate. It's in draft status.`, 'success');
                }, 1000);
                
            } catch (e) {
                statusDiv.innerHTML = `<p style="color: var(--error);">Error: ${escapeHtml(e.message)}</p>`;
            }
        }

        // =================================================================
        // SESSIONS MANAGEMENT (Admin only)
        // =================================================================
        async function loadSessions() {
            const list = document.getElementById('session-list');
            list.innerHTML = '<tr><td colspan="5">Loading...</td></tr>';
            
            try {
                const res = await fetch('/api/sessions', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to load sessions');
                }
                
                if (data.sessions.length === 0) {
                    list.innerHTML = '<tr><td colspan="5">No active sessions</td></tr>';
                    return;
                }
                
                list.innerHTML = data.sessions.map(s => `
                    <tr>
                        <td>
                            ${escapeHtml(s.username)}
                            ${s.isCurrent ? ' <small style="color: var(--primary);">(you)</small>' : ''}
                        </td>
                        <td><span class="role-badge role-${s.role}">${s.role}</span></td>
                        <td>${s.created ? new Date(s.created).toLocaleString() : 'Unknown'}</td>
                        <td><code style="font-size: 0.8rem;">${escapeHtml(s.ip)}</code></td>
                        <td class="actions">
                            ${s.isCurrent ? '<span style="color: var(--muted-color);">Current</span>' : 
                              '<span style="color: var(--muted-color);">Use Revoke All</span>'}
                        </td>
                    </tr>
                `).join('');
                
                showStatus('sessions-status', `${data.total} active session(s)`, 'info');
                
            } catch (e) {
                list.innerHTML = `<tr><td colspan="5" style="color: var(--error);">${escapeHtml(e.message)}</td></tr>`;
            }
        }
        
        async function forceLogoutUser() {
            const username = document.getElementById('force-logout-username').value.trim().toLowerCase();
            
            if (!username) {
                showStatus('sessions-status', 'Enter a username', 'error');
                return;
            }
            
            if (username === SESSION.username) {
                showStatus('sessions-status', 'Cannot revoke your own sessions', 'error');
                return;
            }
            
            if (!confirm(`Revoke ALL sessions for user "${username}"? They will be logged out immediately.`)) {
                return;
            }
            
            try {
                const res = await fetch('/api/sessions', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username: username, all: true })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to revoke sessions');
                }
                
                document.getElementById('force-logout-username').value = '';
                showStatus('sessions-status', data.message, 'success');
                loadSessions(); // Refresh list
                
            } catch (e) {
                showStatus('sessions-status', e.message, 'error');
            }
        }

        /**
         * Delete current page content
         */
        async function deleteContent() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }
            
            if (!confirm(`Delete all content for "${CURRENT_PAGE_ID}"?\n\nThis cannot be undone. The page structure will remain but all content will be removed.`)) {
                return;
            }
            
            showStatus('editor-status', 'Deleting...', 'info');
            
            try {
                const res = await fetch('/api/content', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ pageId: CURRENT_PAGE_ID })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    if (res.status === 401 && handleSessionError(new Error(data.error || 'Unauthorized'))) {
                        return;
                    }
                    throw new Error(data.error || 'Delete failed');
                }
                
                // Clear editor
                CURRENT_CONTENT = {};
                document.getElementById('editor-form').innerHTML = '';
                document.getElementById('editor-container').classList.add('hidden');
                document.getElementById('content-meta').classList.add('hidden');
                clearAutosaveForPage(CURRENT_PAGE_ID);
                markEditorDirty(false);
                
                const commitLabel = data.commit ? data.commit.substring(0, 7) : 'local';
                showStatus('editor-status', `Content deleted. Commit: ${commitLabel}`, 'success');
                
                // Refresh page list if visible
                const browser = document.getElementById('page-browser');
                if (!browser.classList.contains('hidden')) {
                    loadPageList();
                }
                
            } catch (e) {
                showStatus('editor-status', e.message, 'error');
            }
        }

        function buildForm() {
            const container = document.getElementById('editor-form');
            const topContainer = document.getElementById('editor-top-fields');
            const primarySlot = document.getElementById('primary-editor-slot');
            const bodyShell = document.getElementById('editor-body-shell');
            const previewEl = document.getElementById('primary-preview');
            const primaryLabel = document.getElementById('primary-field-label');
            const primaryHint = document.getElementById('primary-field-hint');

            container.innerHTML = '';
            if (topContainer) topContainer.innerHTML = '';
            if (primarySlot) primarySlot.innerHTML = '';
            if (previewEl) previewEl.innerHTML = '';

            if (!CURRENT_SCHEMA || !CURRENT_SCHEMA.fields) {
                container.innerHTML = '<p>Invalid schema: no fields defined</p>';
                return;
            }

            PRIMARY_FIELD_KEY = determinePrimaryFieldKey(CURRENT_SCHEMA);

            let hasPrimaryField = false;
            let hasTopFields = false;

            CURRENT_SCHEMA.fields.forEach(field => {
                const wrapper = document.createElement('div');
                wrapper.className = 'form-field editor-field-card';

                // Label
                const label = document.createElement('label');
                label.setAttribute('for', `field_${field.key}`);
                label.textContent = field.label || field.key;
                if (field.required) {
                    label.innerHTML += ' <span style="color: var(--error);">*</span>';
                }
                wrapper.appendChild(label);

                // Input
                let input;
                const value = CURRENT_CONTENT[field.key] ?? field.default ?? '';

                switch (field.type) {
                    case 'textarea':
                        input = document.createElement('textarea');
                        input.value = value;
                        if (field.rows) input.rows = field.rows;
                        break;

                    case 'select':
                        input = document.createElement('select');
                        (field.options || []).forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt;
                            option.textContent = opt;
                            if (opt === value) option.selected = true;
                            input.appendChild(option);
                        });
                        break;

                    case 'checkbox':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = Boolean(value);
                        input.role = 'switch';
                        break;

                    case 'number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = value;
                        if (field.min !== undefined) input.min = field.min;
                        if (field.max !== undefined) input.max = field.max;
                        break;

                    case 'image':
                        input = document.createElement('div');
                        input.style.cssText = 'display: flex; gap: 0.5rem; align-items: flex-start; flex-wrap: wrap;';
                        
                        if (value) {
                            const img = document.createElement('img');
                            img.src = value;
                            img.style.cssText = 'max-width: 200px; max-height: 150px; border-radius: 8px; object-fit: cover;';
                            input.appendChild(img);
                        }
                        
                        const uploadBtn = document.createElement('button');
                        uploadBtn.type = 'button';
                        uploadBtn.textContent = value ? 'Change Image' : 'Upload Image';
                        uploadBtn.onclick = () => uploadImageForField(`field_${field.key}`);
                        input.appendChild(uploadBtn);
                        break;

                    default:
                        input = document.createElement('input');
                        input.type = field.type || 'text';
                        input.value = value;
                        if (field.maxlength) input.maxLength = field.maxlength;
                        if (field.pattern) input.pattern = field.pattern;
                        break;
                }

                input.id = `field_${field.key}`;
                input.name = field.key;
                if (field.placeholder) input.placeholder = field.placeholder;
                if (field.required) input.required = true;

                if (field.type !== 'image') {
                    const changeEvent = field.type === 'checkbox' || field.type === 'select' ? 'change' : 'input';
                    input.addEventListener(changeEvent, () => {
                        markEditorDirty(true);
                        scheduleAutoStage();
                        scheduleAutosave();
                        scheduleUndoSnapshot();
                        if (field.key === PRIMARY_FIELD_KEY) {
                            updatePrimaryPreview();
                            updateContentStats(input.value);
                            scheduleOutlineUpdate();
                        }
                    });
                    if (field.type === 'textarea' || field.type === 'text' || field.type === 'url') {
                        input.addEventListener('focus', () => {
                            LAST_FOCUSED_FIELD_ID = input.id;
                        });
                    }
                    if (field.type === 'textarea') {
                        input.addEventListener('paste', (event) => {
                            handleImagePaste(event, input);
                        });
                        input.addEventListener('dragover', (event) => {
                            handleImageDragOver(event);
                        });
                        input.addEventListener('drop', (event) => {
                            handleImageDrop(event, input);
                        });
                    }
                }

                wrapper.appendChild(input);

                // Description
                const autoHint = field.type === 'textarea'
                    ? 'Supports markdown formatting. Paste an image to upload automatically. Use "Formatting + Media" tools below for quick insert.'
                    : field.type === 'image'
                        ? 'Upload image here for this field. For inline body images, use "Formatting + Media > Upload + Insert Image".'
                        : '';
                const descriptionText = field.description
                    ? (autoHint ? `${field.description} ${autoHint}` : field.description)
                    : autoHint;
                if (descriptionText) {
                    const desc = document.createElement('small');
                    desc.textContent = descriptionText;
                    wrapper.appendChild(desc);
                }

                const placement = getFieldPlacement(field);
                if (placement === 'primary' && primarySlot) {
                    hasPrimaryField = true;
                    if (primaryLabel) primaryLabel.textContent = field.label || field.key || 'Main Content';
                    if (primaryHint) {
                        primaryHint.textContent = descriptionText || 'Supports markdown formatting.';
                    }
                    primarySlot.appendChild(wrapper);
                } else if (placement === 'top' && topContainer) {
                    hasTopFields = true;
                    topContainer.appendChild(wrapper);
                } else {
                    container.appendChild(wrapper);
                }
            });

            if (bodyShell) {
                bodyShell.classList.toggle('hidden', !hasPrimaryField);
            }
            if (topContainer) {
                topContainer.classList.toggle('hidden', !hasTopFields);
            }

            if (!hasPrimaryField) {
                PREVIEW_MODE = 'write';
            }
            setPreviewMode(PREVIEW_MODE);
        }

        function collectCurrentFormContent() {
            const content = {};
            CURRENT_SCHEMA.fields.forEach(field => {
                const input = document.getElementById(`field_${field.key}`);
                if (!input) return;

                if (field.type === 'checkbox') {
                    content[field.key] = input.checked;
                } else if (field.type === 'number') {
                    content[field.key] = input.value ? Number(input.value) : null;
                } else if (field.type === 'image') {
                    content[field.key] = CURRENT_CONTENT[field.key] || '';
                } else {
                    content[field.key] = input.value;
                }
            });

            if (CURRENT_CONTENT && CURRENT_CONTENT._meta) {
                content._meta = { ...CURRENT_CONTENT._meta };
            }

            return content;
        }

        async function sendSaveRequest(pageId, content, saveAs = null) {
            const payload = { pageId, content };
            if (saveAs === 'draft') payload.saveAs = 'draft';

            const res = await fetch('/api/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${SESSION.token}`
                },
                body: JSON.stringify(payload)
            });

            const data = await res.json();
            if (res.status === 401) throw new Error(data.error || 'Session expired');
            if (!res.ok) throw new Error(data.error || 'Save failed');
            clearAutosaveForPage(pageId);
            return data;
        }

        /**
         * Validate form fields and return any errors
         */
        function validateFormFields() {
            const errors = [];
            
            if (!CURRENT_SCHEMA || !CURRENT_SCHEMA.fields) {
                return errors;
            }
            
            // Clear previous validation highlights
            document.querySelectorAll('.editor-field-card.invalid').forEach(el => {
                el.classList.remove('invalid');
                const msg = el.querySelector('.field-error-message');
                if (msg) msg.remove();
            });
            
            // Check each field
            CURRENT_SCHEMA.fields.forEach(field => {
                const input = document.getElementById(`field_${field.key}`);
                if (!input) return;
                
                const value = field.type === 'checkbox' ? input.checked : input.value;
                const fieldLabel = field.label || field.key;
                let fieldError = null;
                
                // Check required
                if (field.required) {
                    if (field.type === 'checkbox') {
                        if (!value) {
                            fieldError = `${fieldLabel} is required (must be checked)`;
                        }
                    } else {
                        if (!value || String(value).trim() === '') {
                            fieldError = `${fieldLabel} is required`;
                        }
                    }
                }
                
                // Check pattern if present
                if (!fieldError && field.pattern && value && field.type !== 'checkbox') {
                    let pattern;
                    try {
                        pattern = new RegExp(`^${field.pattern}$`);
                    } catch {
                        fieldError = `${fieldLabel} has an invalid pattern.`;
                        pattern = null;
                    }
                    if (pattern && !pattern.test(String(value))) {
                        fieldError = `${fieldLabel} format is invalid (pattern: ${field.pattern})`;
                    }
                }
                
                // Add error message to field
                if (fieldError) {
                    errors.push(fieldError);
                    let wrapper = input.parentElement;
                    if (!wrapper.classList.contains('editor-field-card')) {
                        wrapper = input.parentElement.parentElement;
                    }
                    wrapper.classList.add('invalid');
                    const msg = document.createElement('span');
                    msg.className = 'field-error-message';
                    msg.textContent = fieldError;
                    wrapper.appendChild(msg);
                }
            });
            
            return errors;
        }

        /**
         * Show validation summary dialog
         */
        function showValidationErrors(errors) {
            if (errors.length === 0) return false;
            
            const summary = document.createElement('div');
            summary.className = 'validation-summary';
            summary.innerHTML = `
                <h4>Please fix these validation errors:</h4>
                <ul>${errors.map(e => `<li>${escapeHtml(e)}</li>`).join('')}</ul>
            `;
            
            const editor = document.getElementById('editor-container');
            if (editor) {
                editor.insertBefore(summary, editor.firstChild);
                setTimeout(() => summary.remove(), 8000);
            }
            
            return true;
        }

        async function saveContent() {
            if (!CURRENT_SCHEMA || !CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }

            // Validate before saving
            const validationErrors = validateFormFields();
            if (validationErrors.length > 0) {
                showValidationErrors(validationErrors);
                showStatus('editor-status', `Validation failed: ${validationErrors.length} error(s)`, 'error');
                return;
            }

            if (BATCH_MODE_ENABLED) {
                stageCurrentContentChange();
                return;
            }
            if (EDITOR_BUSY) return;

            setEditorBusy(true);
            const content = collectCurrentFormContent();
            showStatus('editor-status', 'Saving...', 'info');

            try {
                await sendSaveRequest(CURRENT_PAGE_ID, content);
                CURRENT_CONTENT = content;
                document.getElementById('last-saved').textContent = 'Saved just now';
                markEditorDirty(false);
                showStatus('editor-status', 'Changes saved successfully', 'success');
                setTimeout(() => hideStatus('editor-status'), 3000);
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Save failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        async function saveContentAsDraft() {
            if (!CURRENT_SCHEMA || !CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }

            if (BATCH_MODE_ENABLED) {
                stageCurrentContentChange('draft');
                updateContentStatus('draft');
                return;
            }
            if (EDITOR_BUSY) return;

            setEditorBusy(true);
            const content = collectCurrentFormContent();
            showStatus('editor-status', 'Saving as draft...', 'info');

            try {
                const data = await sendSaveRequest(CURRENT_PAGE_ID, content, 'draft');
                CURRENT_CONTENT = content;
                document.getElementById('last-saved').textContent = 'Saved as draft just now';
                markEditorDirty(false);
                showStatus('editor-status', 'Saved as draft (not yet published)', 'success');
                updateContentStatus('draft', data.modifiedBy);
                setTimeout(() => hideStatus('editor-status'), 3000);
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Draft save failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        async function publishContent() {
            if (!CURRENT_PAGE_ID) {
                showStatus('editor-status', 'No page loaded', 'error');
                return;
            }

            // Only allow admin and editor roles to publish
            if (SESSION.role !== 'admin' && SESSION.role !== 'editor') {
                showStatus('editor-status', 'Only admins and editors can publish content', 'error');
                return;
            }

            // Check for validation errors - warn but allow override
            const validationErrors = validateFormFields();
            if (validationErrors.length > 0) {
                showValidationErrors(validationErrors);
                if (!confirm(`There are ${validationErrors.length} validation error(s). Publish anyway?`)) {
                    return;
                }
            }

            if (hasQueuedChangeForCurrentPage()) {
                showStatus('editor-status', 'Push staged changes for this page before publishing.', 'error');
                return;
            }
            if (EDITOR_BUSY) return;
            setEditorBusy(true);

            showStatus('editor-status', 'Publishing...', 'info');
            
            try {
                const res = await fetch('/api/publish', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({
                        pageId: CURRENT_PAGE_ID,
                        action: 'publish'
                    })
                });

                const data = await res.json();

                if (res.status === 401) {
                    throw new Error(data.error || 'Session expired');
                }
                
                if (!res.ok) {
                    throw new Error(data.error || 'Publish failed');
                }

                showStatus('editor-status', 'Content published successfully!', 'success');
                updateContentStatus('published', data.publishedBy);

                setTimeout(() => hideStatus('editor-status'), 3000);

            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Publish failed: ${e.message}`, 'error');
                }
            } finally {
                setEditorBusy(false);
            }
        }

        function updateContentStatus(status, user) {
            const statusDiv = document.getElementById('content-status');
            const statusText = document.getElementById('status-text');
            
            statusDiv.style.display = 'block';
            if (status === 'draft') {
                statusDiv.style.background = '#fff3cd';
                statusDiv.style.borderLeftColor = '#ffc107';
                statusText.innerHTML = `<span style="color: #856404;">[DRAFT] This is a draft (not yet published)</span>`;
            } else if (status === 'published') {
                statusDiv.style.background = '#d4edda';
                statusDiv.style.borderLeftColor = '#28a745';
                statusText.innerHTML = `<span style="color: #155724;">[PUBLISHED] This content is published and live</span>`;
            }
        }

        function triggerImportFileDialog() {
            if (!CURRENT_SCHEMA || !CURRENT_PAGE_ID) {
                showStatus('editor-status', 'Load a page before importing content.', 'error');
                return;
            }
            const input = document.getElementById('import-file-input');
            input.value = '';
            input.click();
        }

        function formatImportPreviewValue(value) {
            if (value === null || value === undefined) return '';
            let text = '';
            if (typeof value === 'string') {
                text = value;
            } else {
                try {
                    text = JSON.stringify(value);
                } catch {
                    text = String(value);
                }
            }
            if (text.length > 160) {
                return `${text.slice(0, 160)}...`;
            }
            return text;
        }

        function renderImportPreview(preview) {
            const panel = document.getElementById('import-preview-panel');
            if (!panel) return;
            const keys = preview?.keys || [];
            const mapped = preview?.mapped || {};
            const rows = keys.map(key => {
                const value = formatImportPreviewValue(mapped[key]);
                return `<li><strong>${escapeHtml(key)}</strong>: <code>${escapeHtml(value)}</code></li>`;
            }).join('');

            panel.innerHTML = `
                <h5>Import Preview</h5>
                <small>File: ${escapeHtml(preview.fileName || 'unknown')}</small>
                ${rows ? `<ul>${rows}</ul>` : '<small>No fields will be imported.</small>'}
                <div style="display:flex; gap:0.5rem; flex-wrap:wrap; margin-top:0.5rem;">
                    <button type="button" class="secondary" onclick="applyImportPreview()">Apply Import</button>
                    <button type="button" class="outline" onclick="clearImportPreview()">Cancel</button>
                </div>
            `;
            panel.classList.remove('hidden');
        }

        function clearImportPreview() {
            PENDING_IMPORT = null;
            const panel = document.getElementById('import-preview-panel');
            if (panel) {
                panel.innerHTML = '';
                panel.classList.add('hidden');
            }
        }

        function applyImportPreview() {
            if (!PENDING_IMPORT || !PENDING_IMPORT.mapped) return;
            const keys = Object.keys(PENDING_IMPORT.mapped);
            if (!keys.length) {
                showStatus('editor-status', 'Import preview has no mapped fields.', 'info');
                clearImportPreview();
                return;
            }

            CURRENT_CONTENT = {
                ...(CURRENT_CONTENT || {}),
                ...PENDING_IMPORT.mapped
            };
            buildForm();
            markEditorDirty(true);
            showStatus('editor-status', `Imported ${keys.length} field(s). Review and save.`, 'success');
            scheduleAutoStage();
            clearImportPreview();
        }

        async function handleImportFileChosen(event) {
            const file = event?.target?.files?.[0];
            if (!file) return;

            try {
                const lowerName = String(file.name || '').toLowerCase();
                const needsBinary = lowerName.endsWith('.docx') || lowerName.endsWith('.pdf') || lowerName.endsWith('.odt');
                const text = needsBinary ? null : await file.text();
                const buffer = needsBinary ? await file.arrayBuffer() : null;
                const imported = await parseImportedFile(file.name, text, buffer);
                const mapped = mapImportedDataToSchema(imported);
                const keys = Object.keys(mapped);

                if (!keys.length) {
                    showStatus('editor-status', 'Import succeeded, but no matching schema fields were found.', 'info');
                    return;
                }
                PENDING_IMPORT = {
                    fileName: file.name,
                    mapped,
                    keys
                };
                renderImportPreview(PENDING_IMPORT);
                showStatus('editor-status', `Import ready: ${keys.length} field(s) detected. Review the preview before applying.`, 'info');
            } catch (e) {
                showStatus('editor-status', `Import failed: ${e.message}`, 'error');
            }
        }

        async function parseImportedFile(fileName, text, buffer) {
            const lower = String(fileName || '').toLowerCase();
            if (lower.endsWith('.json')) {
                const parsed = JSON.parse(text);
                if (parsed && typeof parsed === 'object' && parsed.content && typeof parsed.content === 'object') {
                    return parsed.content;
                }
                if (parsed && typeof parsed === 'object') return parsed;
                throw new Error('JSON import must be an object.');
            }

            if (lower.endsWith('.tid')) {
                return parseTidFile(text);
            }

            if (lower.endsWith('.md') || lower.endsWith('.markdown')) {
                return { content: text, body: text, markdown: text };
            }

            if (lower.endsWith('.html') || lower.endsWith('.htm')) {
                return { content: text, body: text, html: text };
            }

            if (lower.endsWith('.docx')) {
                const extracted = await extractDocxText(buffer);
                return { __importedText: extracted, title: getFileTitleHint(fileName) };
            }

            if (lower.endsWith('.pdf')) {
                const extracted = await extractPdfText(buffer);
                return { __importedText: extracted, title: getFileTitleHint(fileName) };
            }

            if (lower.endsWith('.rtf')) {
                const extracted = extractRtfText(text);
                return { __importedText: extracted, title: getFileTitleHint(fileName) };
            }

            if (lower.endsWith('.odt')) {
                const extracted = await extractOdtText(buffer);
                return { __importedText: extracted, title: getFileTitleHint(fileName) };
            }

            if (lower.endsWith('.csv')) {
                const markdownTable = csvToMarkdown(text);
                return { __importedText: markdownTable, title: getFileTitleHint(fileName) };
            }

            return { content: text, body: text, text };
        }

        function getFileTitleHint(fileName) {
            const raw = String(fileName || '').replace(/\.[^.]+$/, '');
            return raw || 'Imported Document';
        }

        function parseTidFile(text) {
            const lines = text.split(/\r?\n/);
            const headers = {};
            let index = 0;

            while (index < lines.length) {
                const line = lines[index];
                if (!line.trim()) {
                    index += 1;
                    break;
                }

                const separator = line.indexOf(':');
                if (separator > 0) {
                    const key = line.slice(0, separator).trim();
                    const value = line.slice(separator + 1).trim();
                    headers[key] = value;
                }
                index += 1;
            }

            const body = lines.slice(index).join('\n').trim();
            if (body && !headers.text) headers.text = body;

            if (headers.tags) {
                headers.tags = headers.tags
                    .split(/\s+/)
                    .map(tag => tag.trim())
                    .filter(Boolean)
                    .join(', ');
            }

            return headers;
        }

        async function extractDocxText(buffer) {
            if (!buffer || !window.mammoth || typeof window.mammoth.extractRawText !== 'function') {
                throw new Error('DOCX import requires mammoth.js (not available).');
            }
            const result = await window.mammoth.extractRawText({ arrayBuffer: buffer });
            return String(result?.value || '').trim();
        }

        async function extractPdfText(buffer) {
            if (!buffer || !window.pdfjsLib) {
                throw new Error('PDF import requires pdf.js (not available).');
            }
            const loadingTask = window.pdfjsLib.getDocument({ data: buffer });
            const pdf = await loadingTask.promise;
            const pages = [];

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum += 1) {
                const page = await pdf.getPage(pageNum);
                const content = await page.getTextContent();
                const text = content.items.map(item => item.str).join(' ');
                pages.push(text.trim());
            }

            return pages.filter(Boolean).join('\n\n');
        }

        function extractRtfText(text) {
            if (!text) return '';
            let cleaned = text
                .replace(/\\par[d]?/g, '\n')
                .replace(/\\'[0-9a-fA-F]{2}/g, ' ')
                .replace(/\\u-?\d+\??/g, ' ')
                .replace(/\\[a-zA-Z]+-?\d* ?/g, '')
                .replace(/[{}]/g, '');
            cleaned = cleaned.replace(/\n\s+\n/g, '\n\n').trim();
            return cleaned;
        }

        async function extractOdtText(buffer) {
            if (!buffer || !window.zip) {
                throw new Error('ODT import requires zip.js (not available).');
            }

            const reader = new window.zip.ZipReader(new window.zip.Uint8ArrayReader(new Uint8Array(buffer)));
            const entries = await reader.getEntries();
            const contentEntry = entries.find(entry => entry.filename === 'content.xml');
            if (!contentEntry) {
                await reader.close();
                throw new Error('ODT import failed: content.xml not found.');
            }

            const xmlText = await contentEntry.getData(new window.zip.TextWriter());
            await reader.close();

            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            const nodes = Array.from(xmlDoc.querySelectorAll('text\\:p, text\\:h'));
            const lines = nodes.map(node => node.textContent.trim()).filter(Boolean);
            return lines.join('\n\n');
        }

        function csvToMarkdown(text) {
            const rows = parseCsv(text || '');
            if (!rows.length) return '';
            const header = rows[0];
            const body = rows.slice(1);
            const headerLine = `| ${header.map(cell => String(cell || '').trim()).join(' | ')} |`;
            const separatorLine = `| ${header.map(() => '---').join(' | ')} |`;
            const bodyLines = body.map(row => `| ${row.map(cell => String(cell || '').trim()).join(' | ')} |`);
            return [headerLine, separatorLine, ...bodyLines].join('\n');
        }

        function parseCsv(text) {
            const rows = [];
            let current = [];
            let cell = '';
            let inQuotes = false;

            for (let i = 0; i < text.length; i += 1) {
                const char = text[i];
                const next = text[i + 1];

                if (char === '"') {
                    if (inQuotes && next === '"') {
                        cell += '"';
                        i += 1;
                    } else {
                        inQuotes = !inQuotes;
                    }
                    continue;
                }

                if (char === ',' && !inQuotes) {
                    current.push(cell);
                    cell = '';
                    continue;
                }

                if ((char === '\n' || char === '\r') && !inQuotes) {
                    if (char === '\r' && next === '\n') {
                        i += 1;
                    }
                    current.push(cell);
                    if (current.length > 1 || current[0] !== '') {
                        rows.push(current);
                    }
                    current = [];
                    cell = '';
                    continue;
                }

                cell += char;
            }

            if (cell.length || current.length) {
                current.push(cell);
                rows.push(current);
            }

            return rows;
        }

        function mapImportedDataToSchema(imported) {
            const source = imported && typeof imported === 'object' ? imported : {};
            const lowerMap = {};
            Object.entries(source).forEach(([key, value]) => {
                lowerMap[key.toLowerCase()] = value;
            });

            if (source.__importedText) {
                const primaryKey = PRIMARY_FIELD_KEY || 'content';
                if (!source[primaryKey]) {
                    source[primaryKey] = source.__importedText;
                }
            }

            const aliases = {
                title: ['title', 'name', 'headline'],
                body: ['body', 'text', 'content', 'markdown', 'html', 'description'],
                content: ['content', 'body', 'text', 'markdown', 'html', 'description'],
                text: ['text', 'body', 'content', 'markdown', 'description'],
                description: ['description', 'summary', 'body', 'content', 'text'],
                tags: ['tags', 'categories', 'keywords']
            };

            const mapped = {};
            for (const field of (CURRENT_SCHEMA?.fields || [])) {
                const direct = source[field.key];
                const lowerDirect = lowerMap[field.key.toLowerCase()];
                let value = direct !== undefined ? direct : lowerDirect;

                if (value === undefined) {
                    const keys = aliases[field.key.toLowerCase()] || [field.key.toLowerCase()];
                    for (const alias of keys) {
                        if (lowerMap[alias] !== undefined) {
                            value = lowerMap[alias];
                            break;
                        }
                    }
                }

                if (value === undefined || value === null) continue;

                if (field.type === 'checkbox') {
                    mapped[field.key] = value === true || String(value).toLowerCase() === 'true';
                } else if (field.type === 'number') {
                    const numeric = Number(value);
                    if (!Number.isNaN(numeric)) mapped[field.key] = numeric;
                } else {
                    mapped[field.key] = String(value);
                }
            }

            return mapped;
        }

        async function selectAndUploadImage() {
            return new Promise(resolve => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';

                fileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        resolve(null);
                        return;
                    }

                    if (file.size > 10 * 1024 * 1024) {
                        showStatus('editor-status', 'Image too large. Maximum 10MB.', 'error');
                        resolve(null);
                        return;
                    }

                    showStatus('editor-status', `Uploading ${file.name}...`, 'info');

                    try {
                        const formData = new FormData();
                        formData.append('file', file);

                        const res = await fetch('/api/upload', {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${SESSION.token}`
                            },
                            body: formData
                        });

                        const data = await res.json();

                        if (res.status === 401) {
                            throw new Error(data.error || 'Session expired');
                        }
                        if (!res.ok) {
                            throw new Error(data.error || 'Upload failed');
                        }

                        resolve({
                            id: data.id,
                            url: data.url,
                            fileName: file.name
                        });
                    } catch (e) {
                        if (!handleSessionError(e)) {
                            showStatus('editor-status', `Upload failed: ${e.message}`, 'error');
                        }
                        resolve(null);
                    }
                };

                fileInput.click();
            });
        }

        async function uploadImageBlob(blob, fileName = 'pasted-image.png') {
            if (!blob) return null;
            if (blob.size > 10 * 1024 * 1024) {
                showStatus('editor-status', 'Image too large. Maximum 10MB.', 'error');
                return null;
            }

            showStatus('editor-status', `Uploading ${fileName}...`, 'info');

            try {
                const formData = new FormData();
                const file = new File([blob], fileName, { type: blob.type || 'image/png' });
                formData.append('file', file);

                const res = await fetch('/api/upload', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: formData
                });

                const data = await res.json();

                if (res.status === 401) {
                    throw new Error(data.error || 'Session expired');
                }
                if (!res.ok) {
                    throw new Error(data.error || 'Upload failed');
                }

                return {
                    id: data.id,
                    url: data.url,
                    fileName: fileName
                };
            } catch (e) {
                if (!handleSessionError(e)) {
                    showStatus('editor-status', `Upload failed: ${e.message}`, 'error');
                }
                return null;
            }
        }

        async function handleImagePaste(event, targetInput) {
            const items = event?.clipboardData?.items;
            if (!items || !items.length) return;

            const imageItem = Array.from(items).find(item => item.type && item.type.startsWith('image/'));
            if (!imageItem) return;

            event.preventDefault();
            const blob = imageItem.getAsFile();
            if (!blob) return;

            const upload = await uploadImageBlob(blob, `pasted-${Date.now()}.png`);
            if (!upload) return;

            const alt = 'Image';
            const token = `![${alt}](${upload.url})`;
            insertSnippetAtCursor(targetInput, token);
            showStatus('editor-status', 'Pasted image uploaded and inserted.', 'success');
        }

        function handleImageDragOver(event) {
            if (!event) return;
            event.preventDefault();
            if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'copy';
            }
        }

        async function handleImageDrop(event, targetInput) {
            if (!event) return;
            const files = event.dataTransfer?.files;
            if (!files || !files.length) return;

            const imageFile = Array.from(files).find(file => file.type && file.type.startsWith('image/'));
            if (!imageFile) return;

            event.preventDefault();
            const upload = await uploadImageBlob(imageFile, imageFile.name || `dropped-${Date.now()}.png`);
            if (!upload) return;

            const alt = imageFile.name ? imageFile.name.replace(/\.[^.]+$/, '') : 'Image';
            const token = `![${alt}](${upload.url})`;
            insertSnippetAtCursor(targetInput, token);
            showStatus('editor-status', 'Dropped image uploaded and inserted.', 'success');
        }

        async function uploadImageForField(fieldId) {
            const upload = await selectAndUploadImage();
            if (!upload) return;

            // Find the input field for this image and update it
            const field = document.getElementById(fieldId);
            if (field && field.parentElement) {
                // Find the image element or create display
                let img = field.querySelector('img');
                if (!img) {
                    img = document.createElement('img');
                    img.style.cssText = 'max-width: 200px; max-height: 150px; border-radius: 8px; object-fit: cover;';
                    field.insertBefore(img, field.firstChild);
                }
                img.src = upload.url;

                // Update the hidden value
                CURRENT_CONTENT[fieldId.replace('field_', '')] = upload.url;
                markEditorDirty(true);
                scheduleAutoStage();
            }

            showStatus('editor-status', `Image uploaded: ${upload.id}`, 'success');
            setTimeout(() => hideStatus('editor-status'), 3000);
        }

        // =================================================================
        // USER MANAGEMENT
        // =================================================================
        async function loadUsers() {
            const tbody = document.getElementById('user-list');
            tbody.innerHTML = '<tr><td colspan="4">Loading...</td></tr>';

            try {
                const res = await fetch('/api/users', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });

                if (res.status === 401 || res.status === 403) {
                    const data = await res.json();
                    throw new Error(data.error || 'Session expired');
                }
                
                if (!res.ok) {
                    throw new Error('Failed to load users');
                }

                const data = await res.json();
                const users = data.users || data;

                if (users.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4">No users found</td></tr>';
                    return;
                }

                tbody.innerHTML = users.map(user => `
                    <tr>
                        <td><strong>${escapeHtml(user.username)}</strong></td>
                        <td>
                            <select onchange="changeUserRole('${escapeHtml(user.username)}', this.value)" ${user.username === SESSION.username ? 'disabled' : ''} style="font-size: 0.95rem; padding: 0.25rem;">
                                <option value="contributor" ${user.role === 'contributor' ? 'selected' : ''}>Contributor</option>
                                <option value="editor" ${user.role === 'editor' ? 'selected' : ''}>Editor</option>
                                <option value="admin" ${user.role === 'admin' ? 'selected' : ''}>Admin</option>
                            </select>
                        </td>
                        <td>${user.created ? new Date(user.created).toLocaleDateString() : '-'}</td>
                        <td class="actions">
                            ${user.username !== SESSION.username ? `
                                <button class="secondary" onclick="resetPassword('${escapeHtml(user.username)}')" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Reset Password</button>
                                <button class="contrast" onclick="deleteUser('${escapeHtml(user.username)}')" style="padding: 0.25rem 0.5rem; font-size: 0.85rem;">Delete</button>
                            ` : '<em>Current user</em>'}
                        </td>
                    </tr>
                `).join('');

            } catch (e) {
                if (!handleSessionError(e)) {
                    tbody.innerHTML = `<tr><td colspan="4" style="color: var(--error);">${e.message}</td></tr>`;
                }
            }
        }

        async function createUser() {
            const username = document.getElementById('new-username').value.trim().toLowerCase();
            const password = document.getElementById('new-password').value;
            const role = document.getElementById('new-role').value;

            if (!username) {
                showStatus('users-status', 'Username required', 'error');
                return;
            }

            try {
                const res = await fetch('/api/users', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username, password: password || undefined, role })
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error || 'Failed to create user');
                }

                // Show result with password
                const resultEl = document.getElementById('create-user-result');
                resultEl.className = 'status-message status-success';
                resultEl.innerHTML = `
                    <strong>User created:</strong> ${escapeHtml(data.username)}<br>
                    <strong>Password:</strong> <code>${escapeHtml(data.password)}</code><br>
                    <small>Share this password securely with the user.</small>
                `;
                resultEl.classList.remove('hidden');

                // Clear form
                document.getElementById('new-username').value = '';
                document.getElementById('new-password').value = '';

                // Reload list
                loadUsers();

            } catch (e) {
                showStatus('users-status', e.message, 'error');
            }
        }

        async function resetPassword(username) {
            if (!confirm(`Reset password for ${username}?`)) return;

            try {
                const res = await fetch('/api/users', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username, resetPassword: true })
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error || 'Failed to reset password');
                }

                alert(`New password for ${username}:\n\n${data.newPassword}\n\nShare this securely with the user.`);

            } catch (e) {
                showStatus('users-status', e.message, 'error');
            }
        }

        async function deleteUser(username) {
            if (!confirm(`Delete user ${username}? This cannot be undone.`)) return;

            try {
                const res = await fetch('/api/users', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username })
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.error || 'Failed to delete user');
                }

                showStatus('users-status', `User ${username} deleted`, 'success');
                loadUsers();

            } catch (e) {
                showStatus('users-status', e.message, 'error');
            }
        }

        async function changeUserRole(username, newRole) {
            if (!confirm(`Change ${username}'s role to "${newRole}"?`)) {
                loadUsers();  // Reload to reset dropdown
                return;
            }
            
            try {
                const res = await fetch('/api/users', {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SESSION.token}`
                    },
                    body: JSON.stringify({ username, role: newRole })
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to update role');
                }
                
                showStatus('users-status', `${username} role changed to ${newRole}`, 'success');
                loadUsers();
                
            } catch (e) {
                showStatus('users-status', e.message, 'error');
                loadUsers();  // Reload to reset dropdown
            }
        }

        async function loadAuditLog() {
            const loading = document.getElementById('audit-loading');
            const tbody = document.getElementById('audit-table')?.querySelector('tbody');
            const limit = document.getElementById('audit-limit').value || 100;
            
            if (!tbody) return;
            loading.classList.remove('hidden');
            tbody.innerHTML = '';
            
            try {
                const res = await fetch(`/api/audit?limit=${limit}`, {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                
                const data = await res.json();
                
                if (!res.ok) {
                    throw new Error(data.error || 'Failed to load audit log');
                }
                
                AUDIT_LOG_DATA = data.logs || [];
                renderAuditLog(AUDIT_LOG_DATA);
                
                const status = document.getElementById('audit-filter-status');
                if (status) {
                    status.textContent = `Loaded ${AUDIT_LOG_DATA.length} record(s). ${AUDIT_LOG_DATA.length > 0 ? 'Use filters to narrow results.' : ''}`;
                }
                
            } catch (e) {
                tbody.innerHTML = `<tr><td colspan="4" style="color: var(--error);">Error: ${escapeHtml(e.message)}</td></tr>`;
            } finally {
                loading.classList.add('hidden');
            }
        }

        /**
         * Render audit log with optional data override
         */
        function renderAuditLog(logs) {
            const tbody = document.getElementById('audit-table')?.querySelector('tbody');
            if (!tbody) return;
            
            if (!logs || logs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--muted-color);">No audit records</td></tr>';
                return;
            }
            
            tbody.innerHTML = logs.map(log => `
                <tr>
                    <td><small>${new Date(log.timestamp).toLocaleString()}</small></td>
                    <td><strong>${escapeHtml(log.username)}</strong></td>
                    <td><code style="font-size: 0.8rem;">${escapeHtml(log.action)}</code></td>
                    <td><small>${escapeHtml(JSON.stringify(log.details || {}))}</small></td>
                </tr>
            `).join('');
        }

        /**
         * Apply filters to audit logs
         */
        function applyAuditFilters() {
            if (AUDIT_LOG_DATA.length === 0) {
                const status = document.getElementById('audit-filter-status');
                if (status) status.textContent = 'No logs loaded. Click "Load Logs" first.';
                return;
            }

            const userFilter = (document.getElementById('audit-filter-user')?.value || '').toLowerCase().trim();
            const actionFilter = document.getElementById('audit-filter-action')?.value || '';
            const dateFromStr = document.getElementById('audit-filter-date-from')?.value;
            const dateToStr = document.getElementById('audit-filter-date-to')?.value;

            const dateFrom = dateFromStr ? new Date(dateFromStr).getTime() : 0;
            const dateTo = dateToStr ? new Date(dateToStr).getTime() + 86400000 : Infinity;

            const filtered = AUDIT_LOG_DATA.filter(log => {
                // Username filter
                if (userFilter && !log.username.toLowerCase().includes(userFilter)) {
                    return false;
                }
                // Action filter
                if (actionFilter && log.action !== actionFilter) {
                    return false;
                }
                // Date range filter
                const logTime = new Date(log.timestamp).getTime();
                if (logTime < dateFrom || logTime > dateTo) {
                    return false;
                }
                return true;
            });

            renderAuditLog(filtered);
            
            const status = document.getElementById('audit-filter-status');
            if (status) {
                const appliedFilters = [];
                if (userFilter) appliedFilters.push(`user: "${userFilter}"`);
                if (actionFilter) appliedFilters.push(`action: "${actionFilter}"`);
                if (dateFromStr) appliedFilters.push(`from: ${dateFromStr}`);
                if (dateToStr) appliedFilters.push(`to: ${dateToStr}`);
                
                const filterText = appliedFilters.length > 0 ? ` (${appliedFilters.join(', ')})` : '';
                status.textContent = `Showing ${filtered.length} of ${AUDIT_LOG_DATA.length} record(s)${filterText}`;
            }
        }
        
        async function downloadAuditLog() {
            let logsToExport = AUDIT_LOG_DATA;
            
            // If no logs loaded, fetch them first
            if (logsToExport.length === 0) {
                const limit = document.getElementById('audit-limit').value || 1000;
                try {
                    const res = await fetch(`/api/audit?limit=${limit}`, {
                        headers: { 'Authorization': `Bearer ${SESSION.token}` }
                    });
                    const data = await res.json();
                    if (!res.ok) throw new Error(data.error || 'Failed to download');
                    logsToExport = data.logs || [];
                } catch (e) {
                    const status = document.getElementById('audit-filter-status');
                    if (status) status.textContent = 'Error downloading: ' + e.message;
                    return;
                }
            }

            // Apply current filters to export
            const userFilter = (document.getElementById('audit-filter-user')?.value || '').toLowerCase().trim();
            const actionFilter = document.getElementById('audit-filter-action')?.value || '';
            const dateFromStr = document.getElementById('audit-filter-date-from')?.value;
            const dateToStr = document.getElementById('audit-filter-date-to')?.value;

            let logsToDownload = logsToExport;
            if (userFilter || actionFilter || dateFromStr || dateToStr) {
                const dateFrom = dateFromStr ? new Date(dateFromStr).getTime() : 0;
                const dateTo = dateToStr ? new Date(dateToStr).getTime() + 86400000 : Infinity;

                logsToDownload = logsToExport.filter(log => {
                    if (userFilter && !log.username.toLowerCase().includes(userFilter)) return false;
                    if (actionFilter && log.action !== actionFilter) return false;
                    const logTime = new Date(log.timestamp).getTime();
                    if (logTime < dateFrom || logTime > dateTo) return false;
                    return true;
                });
            }

            // Convert to CSV with headers
            const csv = [
                ['Timestamp', 'User', 'Action', 'Details'],
                ...logsToDownload.map(log => [
                    new Date(log.timestamp).toISOString(),
                    log.username,
                    log.action,
                    JSON.stringify(log.details || {})
                ])
            ].map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `audit-log-${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            const status = document.getElementById('audit-filter-status');
            if (status) status.textContent = `Downloaded ${logsToDownload.length} record(s) as CSV`;
        }

        // =================================================================
        // CONTENT HEALTH DASHBOARD
        // =================================================================
        async function scanContentHealth() {
            const loading = document.getElementById('health-loading');
            const summary = document.getElementById('health-summary');
            const issues = document.getElementById('health-issues');
            const noIssues = document.getElementById('health-no-issues');
            const statusEl = document.getElementById('health-scan-status');

            loading.classList.remove('hidden');
            summary.style.display = 'none';
            issues.style.display = 'none';
            noIssues.style.display = 'none';
            statusEl.textContent = 'Scanning...';

            try {
                // Get all pages
                const res = await fetch('/api/pages?minimal=true', {
                    headers: { 'Authorization': `Bearer ${SESSION.token}` }
                });
                const pagesData = await res.json();
                if (!res.ok) {
                    throw new Error(pagesData.error || 'Failed to load pages');
                }
                const allPages = (pagesData.pages || []).map(page => page.pageId || page);

                const issues_found = [];
                let criticalCount = 0;
                let warningCount = 0;

                // Scan each page
                for (const page of allPages) {
                    try {
                        // Load page content
                        const schemaRes = await fetch(`/data/${page}/schema.json`);
                        const schema = await schemaRes.json();

                        const contentRes = await fetch(`/data/${page}/content.json`);
                        const content = await contentRes.json();
                        const meta = content._meta || {};

                        // Check draft age
                        if (meta.status === 'draft') {
                            const created = new Date(meta.created).getTime();
                            const now = Date.now();
                            const daysOld = Math.floor((now - created) / (1000 * 60 * 60 * 24));
                            if (daysOld > 60) {
                                criticalCount++;
                                issues_found.push({
                                    page,
                                    severity: 'critical',
                                    type: 'old_draft',
                                    message: `Draft page older than 60 days (${daysOld} days old)`,
                                    meta
                                });
                            } else if (daysOld > 30) {
                                warningCount++;
                                issues_found.push({
                                    page,
                                    severity: 'warning',
                                    type: 'old_draft',
                                    message: `Draft page older than 30 days (${daysOld} days old)`,
                                    meta
                                });
                            }
                        }

                        // Check required fields
                        if (schema.fields && Array.isArray(schema.fields)) {
                            const requiredFields = schema.fields
                                .filter(field => field.required)
                                .map(field => field.key);

                            for (const field of requiredFields) {
                                if (!content[field] || content[field] === '') {
                                    criticalCount++;
                                    issues_found.push({
                                        page,
                                        severity: 'critical',
                                        type: 'missing_required_field',
                                        message: `Missing required field: "${field}"`,
                                        field
                                    });
                                }
                            }
                        }

                        // Check for broken images
                        const contentStr = JSON.stringify(content);
                        const imageMatches = contentStr.match(/https?:\/\/[^\s"']+\.(jpg|jpeg|png|gif|webp|svg)/gi) || [];
                        const brokenImages = [];

                        for (const url of imageMatches) {
                            // Basic validation: check if URL looks malformed
                            try {
                                new URL(url);
                            } catch (e) {
                                brokenImages.push(url);
                            }
                        }

                        if (brokenImages.length > 0) {
                            warningCount++;
                            issues_found.push({
                                page,
                                severity: 'warning',
                                type: 'image_issues',
                                message: `${brokenImages.length} image URL(s) may be broken`,
                                images: brokenImages
                            });
                        }

                    } catch (e) {
                        // Silently skip pages with errors
                        console.error(`Error scanning page ${page}:`, e);
                    }
                }

                // Display results
                const healthScore = Math.max(0, Math.round(100 - (issues_found.length / allPages.length) * 100));
                
                document.getElementById('health-total').textContent = allPages.length;
                document.getElementById('health-critical').textContent = criticalCount;
                document.getElementById('health-warnings').textContent = warningCount;
                document.getElementById('health-score').textContent = healthScore + '%';

                loading.classList.add('hidden');
                summary.style.display = 'grid';

                if (issues_found.length === 0) {
                    noIssues.style.display = 'block';
                    statusEl.textContent = 'No issues found';
                } else {
                    issues.style.display = 'block';
                    renderHealthIssues(issues_found);
                    statusEl.textContent = `Found ${issues_found.length} issue(s)`;
                }

            } catch (e) {
                loading.classList.add('hidden');
                statusEl.textContent = 'Error: ' + e.message;
                console.error('Health scan error:', e);
            }
        }

        function renderHealthIssues(issues) {
            const list = document.getElementById('health-issues-list');
            list.innerHTML = '';

            // Group by severity
            const critical = issues.filter(i => i.severity === 'critical');
            const warnings = issues.filter(i => i.severity === 'warning');

            // Render critical issues
            if (critical.length > 0) {
                const criticalSection = document.createElement('div');
                criticalSection.innerHTML = '<h5 style="color: #d32f2f; margin-bottom: 0.75rem;">Critical Issues</h5>';
                
                for (const issue of critical) {
                    const issueEl = document.createElement('div');
                    issueEl.style.cssText = 'padding: 0.75rem; background: #ffebee; border-left: 4px solid #d32f2f; border-radius: 4px;';
                    
                    let content = `<strong>${escapeHtml(issue.page)}</strong> - ${escapeHtml(issue.message)}`;
                    
                    if (issue.type === 'old_draft' && issue.meta.status === 'draft') {
                        content += `<br/><button onclick="publishPageById('${escapeHtml(issue.page)}')" class="secondary" style="margin-top: 0.5rem; font-size: 0.85rem;">Publish</button>`;
                    }
                    
                    issueEl.innerHTML = content;
                    criticalSection.appendChild(issueEl);
                }
                
                list.appendChild(criticalSection);
            }

            // Render warnings
            if (warnings.length > 0) {
                const warningSection = document.createElement('div');
                warningSection.innerHTML = '<h5 style="color: #f57c00; margin-bottom: 0.75rem; margin-top: 1rem;">Warnings</h5>';
                
                for (const issue of warnings) {
                    const issueEl = document.createElement('div');
                    issueEl.style.cssText = 'padding: 0.75rem; background: #fff3e0; border-left: 4px solid #f57c00; border-radius: 4px;';
                    
                    let content = `<strong>${escapeHtml(issue.page)}</strong> - ${escapeHtml(issue.message)}`;
                    
                    if (issue.images && issue.images.length > 0) {
                        content += '<details style="margin-top: 0.5rem;"><summary style="cursor: pointer;">View URLs</summary><div style="margin-top: 0.5rem; font-size: 0.85rem; font-family: monospace;">' +
                            issue.images.map(img => `<div>${escapeHtml(img)}</div>`).join('') +
                            '</div></details>';
                    }
                    
                    issueEl.innerHTML = content;
                    warningSection.appendChild(issueEl);
                }
                
                list.appendChild(warningSection);
            }
        }

        async function publishPageById(pageId) {
            try {
                const res = await fetch('/api/publish', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${SESSION.token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ pageId, action: 'publish' })
                });

                const data = await res.json();
                if (!res.ok) throw new Error(data.error || 'Failed to publish');

                // Re-scan to update health
                setTimeout(() => scanContentHealth(), 1000);
            } catch (e) {
                alert('Error publishing: ' + e.message);
            }
        }

        // =================================================================
        // UTILITIES
        // =================================================================
        function mapSetupError(message) {
            const msg = String(message || '');
            const lower = msg.toLowerCase();

            if (lower.includes('invalid setup token')) {
                return [
                    'Invalid setup token.',
                    'Confirm SETUP_TOKEN in Cloudflare Pages -> Settings -> Environment variables (Production), then paste that exact value here.'
                ].join('\n');
            }
            if (lower.includes('setup token') && lower.includes('not configured')) {
                return [
                    'SETUP_TOKEN is not configured.',
                    'Add SETUP_TOKEN as a Secret in Cloudflare Pages, redeploy, then refresh this page.'
                ].join('\n');
            }
            if (lower.includes('kv') && lower.includes('not configured')) {
                return [
                    'KV binding is missing.',
                    'In Cloudflare Pages -> Settings -> Bindings, bind LOON_DB (preferred) or KV, then redeploy.'
                ].join('\n');
            }
            if (lower.includes('setup already completed')) {
                return [
                    'Initial setup is already complete.',
                    'Use the normal login form. If you need access, reset admin credentials from an existing admin account.'
                ].join('\n');
            }
            if (lower.includes('too many setup attempts')) {
                return 'Too many setup attempts. Wait about 1 minute, then retry.';
            }
            return msg || 'Initial setup failed.';
        }

        function mapLoginError(message) {
            const msg = String(message || '');
            const lower = msg.toLowerCase();

            if (lower.includes('invalid credentials')) {
                return 'Login failed. Check username/password and try again.';
            }
            if (lower.includes('too many') && lower.includes('login')) {
                return 'Too many login attempts. Wait about 1 minute and try again.';
            }
            if (lower.includes('kv') && lower.includes('not configured')) {
                return [
                    'Login is blocked because KV is not configured.',
                    'Set LOON_DB (preferred) or KV binding in Cloudflare Pages Settings -> Bindings, then redeploy.'
                ].join('\n');
            }
            return msg || 'Login failed.';
        }

        function dismissPostSetupBanner() {
            sessionStorage.removeItem(STORAGE_KEYS.POST_SETUP_NOTICE);
            document.getElementById('post-setup-banner').classList.add('hidden');
        }

        function maybeShowFirstPageWizard() {
            if (!SESSION || SESSION.role !== 'admin') return;
            const dismissed = localStorage.getItem(STORAGE_KEYS.FIRST_PAGE_WIZARD_DISMISSED) === '1';
            if (dismissed) return;
            document.getElementById('first-page-wizard').classList.remove('hidden');
        }

        function dismissFirstPageWizard() {
            localStorage.setItem(STORAGE_KEYS.FIRST_PAGE_WIZARD_DISMISSED, '1');
            document.getElementById('first-page-wizard').classList.add('hidden');
        }

        function startFirstPageWizard() {
            switchTab('editor');
            showNewPageDialog();

            const idEl = document.getElementById('new-page-id');
            const titleEl = document.getElementById('new-page-title');
            const templateEl = document.getElementById('new-page-template');

            if (idEl && !idEl.value.trim()) {
                idEl.value = 'welcome';
            }
            if (titleEl && !titleEl.value.trim()) {
                titleEl.value = 'Welcome';
            }
            if (templateEl && !templateEl.value) {
                templateEl.value = 'blog-post';
            }

            const statusEl = document.getElementById('new-page-status');
            if (statusEl) {
                statusEl.className = 'status-message status-info';
                statusEl.textContent = 'Step 1: Confirm Page ID/Title, then click Create Page. Step 2: Add content and click Save Changes.';
                statusEl.classList.remove('hidden');
            }
        }

        async function copySetupTokenRotationReminder() {
            const reminder = [
                'LOON security follow-up:',
                'Rotate or remove SETUP_TOKEN in Cloudflare Pages -> Settings -> Environment variables (Production).',
                'Then redeploy so the change takes effect.'
            ].join(' ');
            try {
                await navigator.clipboard.writeText(reminder);
                alert('Copied setup-token rotation reminder.');
            } catch (err) {
                alert(reminder);
            }
        }

        function showStatus(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.className = `status-message status-${type}`;
            el.textContent = message;
            el.classList.remove('hidden');
        }

        function hideStatus(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function showError(elementId, message) {
            const el = document.getElementById(elementId);
            el.className = 'status-message status-error';
            el.textContent = message;
            el.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function togglePassword() {
            const input = document.getElementById('password');
            const btn = document.querySelector('.password-toggle');
            if (input.type === 'password') {
                input.type = 'text';
                btn.textContent = 'Hide';
            } else {
                input.type = 'password';
                btn.textContent = 'Show';
            }
        }
    </script>
</body>
</html>
